/******************************************************************************
Copyright (C), 2001-2014, Hisilicon Tech. Co., Ltd.
******************************************************************************
File Name     : nocs_check.c
Version       : Initial Draft
Author        : Hisilicon hisecurity group
Created       : 2013/12/26
Last Modified :
Description   : Test sample of BSD API
Function List :
History       :
******************************************************************************/
#include "nocs_bsd.h"
#include "nocs_bsd_impl.h"
#include "hi_type.h"
#include "drv_cipher_intf.h"
#include "nocs_check.h"
#include "hi_flash.h"
#include "hi3716cv2_0_Test_Vectors_1_x.h"
#include "ca_common.h"
#include "ca_reg.h"
#include "hi_common.h"
#ifndef HI_MINIBOOT_SUPPORT
#include "common.h"
#else
#include "app.h"
#endif

#ifdef HI_ADVCA_FUNCTION_RELEASE
#define HI_DEBUG_BSD(fmt...) //HI_TRACE(HI_LOG_LEVEL_ERROR, HI_DEBUG_ID_ECS, fmt)
#else
#define HI_DEBUG_BSD(fmt...) printf(fmt)
#endif

#define UNIQUEDATA_START_ADDR_V200  0x800
#define UNIQUEDATA_START_ADDR_V300  0x1800

const TUnsignedInt8 uniqueDataRef[UNIQUEDATA_LEN] = {
        0x9b,0x10,0x36,0x1f,0xe4,0x7f,0x11,0x42,0x0c,0xc6,0x53,0x6b,0x67,0x6e,0x08,0x21,
        0x36,0x98,0x9c,0x37,0x2b,0xc5,0x6f,0x24,0x76,0x25,0x4e,0x30,0x0c,0x50,0xb0,0xbb,
        0x55,0x7f,0x19,0x58,0x23,0x7b,0x00,0x40,0x0c,0x09,0xbb,0x5b,0x22,0x87,0xc4,0x28,
        0x42,0x5f,0xa4,0x71,0xc1,0xa6,0xc9,0x7c,0x07,0x16,0xd7,0x3e,0xcb,0x1f,0xb0,0x8d,
        0x16,0x51,0x9f,0x6f,0x7c,0x55,0x60,0x9b,0x44,0x7a,0xe4,0xea,0xeb,0x8b,0x13,0xdd,
        0x42,0xef,0x1a,0x17,0xc2,0x2d,0x89,0xbf,0x27,0xf2,0xe9,0x6f,0x8f,0x72,0x76,0x1b,
        0x92,0x8d,0x8d,0xe3,0x97,0x90,0x5f,0xd3,0x36,0xd5,0x1f,0xbd,0x3e,0xc9,0x12,0xbf,
        0x9d,0x78,0x4b,0x92,0xf9,0x76,0x6e,0x51,0xe1,0x02,0x8e,0xcb,0x09,0xfc,0xa0,0x63,
        0x1e,0xce,0x0f,0x5f,0x68,0xd3,0x6b,0xb8,0x65,0x6b,0x2f,0x35,0xc7,0xce,0x43,0x76,
        0xe1,0x3e,0xa7,0x38,0x58,0x77,0x91,0x20,0x5b,0x7c,0x51,0x7e,0x08,0x14,0xe2,0x7d,
        0xd4,0xf1,0xf7,0x10,0xca,0xc7,0x73,0x85,0x52,0x05,0x9b,0xf0,0x9f,0x42,0x39,0x0f,
        0xcb,0xe0,0xf1,0x66,0x89,0x52,0xc0,0x9e,0x3a,0x24,0xb3,0x1b,0xd7,0x3f,0x13,0xa1,
        0x81,0x01,0xfb,0x1a,0x99,0xdd,0x01,0xcf,0xed,0x0a,0x01,0x35,0x7c,0x15,0x0a,0xb3,
        0x88,0x69,0x44,0x10,0x88,0xc0,0x4f,0x77,0x02,0xc1,0xbe,0x08,0x40,0x33,0x86,0x23,
        0x67,0xa4,0xd2,0x22,0xef,0xc8,0x14,0x70,0x44,0x4f,0x12,0x6d,0x3c,0x17,0xc8,0x22,
        0xb0,0x0c,0x71,0xb1,0xcd,0x8c,0xe0,0x24,0x66,0x26,0x4e,0x0d,0xfb,0x55,0x71,0xc9,
        0x4e,0x2b,0x9a,0x6d,0x9f,0xf6,0xcf,0x73,0x76,0x1a,0x80,0x52,0xaa,0xaf,0x98,0x25,
        0x24,0xdf,0x6d,0xc8,0xea,0x4b,0x6e,0xeb,0x64,0x41,0x4d,0xb7,0x5a,0xa7,0x3b,0x20,
        0x75,0x56,0x93,0x44,0x62,0x8d,0xf4,0x1e,0x49,0x3a,0xd3,0x48,0x78,0xb0,0x4f,0xb0,
        0x5f,0xe7,0x3e,0x07,0xea,0x2a,0x58,0x15,0x22,0xc9,0x8d,0x7f,0x37,0x8b,0xef,0xf4,
        0x71,0x9c,0xd5,0x6a,0x95,0x6e,0x68,0xe7,0xe6,0xaa,0x0f,0xac,0x1f,0xaa,0xa8,0x9a,
        0xba,0x40,0xc0,0x94,0x27,0x66,0x3d,0x76,0xee,0xb7,0xf5,0xa0,0x26,0x5d,0xb9,0x17,
        0xa7,0x57,0xbc,0x2a,0xe8,0x14,0x6c,0xb4,0x42,0xc0,0x11,0x86,0x76,0xb8,0x0d,0x89,
        0xd8,0xac,0xcf,0x07,0x44,0xd9,0xa1,0xaf,0xe5,0x70,0x22,0xae,0x77,0x76,0x46,0x99,
        0xc8,0xdc,0xd0,0xe4,0x47,0xc1,0x54,0xdc,0x5d,0x0f,0xb9,0x90,0xd1,0xeb,0xff,0xa8,
        0x12,0x7b,0x4c,0x25,0x77,0x09,0xdb,0x70,0x62,0x8e,0x7c,0x0f,0xb0,0xb9,0xe8,0x6a,
        0xba,0xc8,0xa0,0x5f,0x74,0x56,0xc5,0x92,0xa4,0x4d,0xc7,0xeb,0xd8,0xe3,0xa4,0xc7,
        0x10,0x4e,0x25,0x4f,0x39,0xe1,0x78,0xe9,0x8d,0x1c,0x56,0xef,0x05,0x64,0xc6,0x87,
        0xb9,0x02,0xa9,0xc4,0x99,0x7f,0xaa,0xbb,0xa1,0x5c,0xa8,0xcc,0x10,0x62,0xef,0xb8,
        0xc1,0xaa,0x3b,0xc4,0x2b,0xaa,0xe3,0x97,0xf2,0x6e,0xbe,0x83,0x52,0x43,0x75,0x83,
        0x0f,0xe3,0x1a,0x15,0x02,0x61,0x71,0x17,0xc3,0xa2,0xaa,0x1a,0x10,0x0d,0x30,0xaf,
        0xd9,0xbc,0x4c,0x32,0xbc,0x11,0x4a,0x20,0xae,0x14,0xc2,0x55,0x43,0xa5,0x70,0x4f,
        0x99,0x40,0xc1,0x33,0x6e,0x69,0xa2,0x0c,0x01,0x11,0xcd,0xd6,0xa7,0xe1,0x49,0x87,
        0xb8,0x98,0x23,0x38,0xe8,0x52,0xe3,0xed,0x9f,0x62,0x42,0xc3,0x81,0xe7,0xaa,0xe1,
        0xfb,0x1f,0xf2,0xe6,0x6a,0x12,0xd5,0x70,0x5d,0xcd,0xcb,0x1f,0xe5,0x09,0x99,0x28,
        0x3c,0xdb,0x62,0xa3,0xb2,0x67,0x22,0x21,0x00,0xa9,0xd1,0x0f,0x0c,0xea,0x59,0xcc,
        0x54,0x95,0xc0,0x0d,0xaf,0x3b,0x8e,0x20,0xcf,0x4e,0xd1,0xf1,0xd9,0x50,0x7c,0xce,
        0x61,0x36,0x93,0x1b,0x41,0x85,0xeb,0x2d,0x02,0x99,0xc1,0xe7,0x85,0xf4,0x26,0x1d,
        0x66,0xf7,0x67,0x85,0x4a,0xf0,0x39,0x7a,0x25,0x92,0xef,0x4f,0x58,0x0f,0x19,0x9d,
        0x59,0xbb,0x2e,0xfe,0x5b,0x8c,0xa6,0x29,0x6c,0xf9,0x64,0x87,0x3c,0xf2,0xff,0x42,
        0x11,0xf2,0xb8,0x13,0x4b,0x58,0x91,0xa9,0x71,0x6a,0xac,0x9b,0x92,0xd4,0xfe,0xf9,
        0x4d,0x17,0xec,0x2d,0xcc,0x65,0xd5,0x7b,0xf0,0xe1,0x75,0x0b,0xfd,0xd2,0xe3,0x8e,
        0x32,0x62,0x30,0x71,0x6c,0x33,0xc5,0xd5,0x99,0xd4,0xbe,0xfb,0x91,0xc3,0xaa,0x0a,
        0xbf,0xe9,0x36,0x66,0x17,0xb3,0x66,0xe8,0x5b,0x1c,0x63,0xf7,0x62,0x44,0x01,0x65,
        0x7b,0xdf,0x82,0xbc,0x2b,0xf5,0x84,0xe0,0xec,0x59,0xe3,0xd2,0xe7,0x78,0xae,0xea,
        0x10,0xf3,0xc6,0x21,0xe1,0x90,0xc1,0x64,0xd1,0x4f,0x26,0x26,0x27,0x1d,0x71,0x00,
        0x0b,0x75,0xac,0xa7,0x72,0x23,0x9d,0xec,0x20,0x6d,0x8a,0x8e,0x6b,0x2a,0x4f,0xa1,
        0xa3,0x64,0x62,0xa0,0x48,0xe0,0x76,0xfd,0xc7,0x26,0x5a,0x57,0x4e,0x3e,0xcf,0x3d,
        0xc2,0x38,0xa5,0xb5,0xeb,0x5c,0x59,0xf9,0x3a,0x24,0x77,0x2a,0x64,0xad,0xa1,0x07,
        0x59,0xf5,0xa7,0x18,0xa7,0xdd,0xc8,0x84,0xd3,0x04,0x8b,0x7f,0x79,0xfd,0x6f,0xb9,
        0x33,0xa5,0x16,0xed,0xa2,0x31,0xf1,0xbc,0x36,0x3d,0xc1,0x2b,0x43,0xc8,0xa7,0x64,
        0x8f,0x83,0x46,0x68,0x3e,0xa9,0x8d,0xb5,0x50,0x39,0xe7,0x47,0xdd,0xd1,0xa8,0xa7,
        0xf1,0x78,0xbd,0x1e,0xc5,0x72,0x90,0xcd,0xd0,0x63,0x9d,0x05,0x38,0xc8,0xa0,0x92,
        0xca,0x6e,0x2d,0x1a,0x53,0x3d,0xca,0x08,0x61,0xbb,0xd6,0x21,0xda,0xb4,0xf1,0x4e,
        0x08,0xa6,0x4c,0x3e,0x76,0x63,0xe5,0x1e,0x13,0x6c,0xa5,0xd6,0x89,0xdc,0x65,0xbe,
        0x1f,0xd1,0x9d,0x54,0x95,0xdb,0xb2,0x59,0x23,0xbc,0x54,0x6b,0xad,0xf3,0x90,0xf6,
        0xcf,0x89,0x21,0x13,0xf8,0x1c,0x7a,0x5d,0x3f,0x61,0xfb,0x27,0xd2,0x19,0xe1,0x6d,
        0xe5,0x35,0xaf,0xc5,0xec,0x7f,0xce,0x83,0xae,0x7d,0x24,0xf0,0x26,0x4a,0x77,0x66,
        0xbf,0x16,0x72,0x78,0x67,0x40,0x5b,0xeb,0x0b,0x41,0xe6,0xd0,0xe4,0xe3,0xc3,0x3c,
        0x74,0x00,0x76,0xa4,0x59,0x80,0xe9,0x42,0xd7,0x2a,0xe8,0x3a,0xcf,0xea,0x9a,0xfc,
        0x17,0x6a,0x93,0xd0,0x21,0x89,0x56,0x98,0x73,0xd9,0xff,0xb0,0xc9,0xae,0x38,0x0e,
        0xb8,0xd4,0xa2,0xd5,0xd1,0x3a,0xa8,0x3f,0x8d,0x04,0x5b,0x55,0xf2,0xd1,0x80,0xf2,
        0xf2,0x37,0x55,0x23,0xb2,0x46,0x3e,0xc7,0x4a,0xd0,0x5c,0x26,0xdb,0x03,0x7a,0x18,
        0x9d,0xca,0xad,0x5a,0xa3,0x5e,0x18,0x5f,0xeb,0xc6,0x71,0x25,0x29,0x8e,0xd5,0x6b
};

/*Turn 4Bytes Vector into int*/
TUnsignedInt32 convertToInt(TBsd4BytesVector pVector)
{
    TUnsignedInt32 Result = 0;
    TUnsignedInt32 i = 0;

    if(HI_NULL == pVector)
    {
        return 0x0;
    }

    for ( i = 0 ; i < 4 ; i++ )
    {
        Result = (Result<<8) + pVector[i];
    }

    return Result;
}

extern int get_bootmedia(char **media, void *arg);

TBsdStatus nagra_BootCodeCheck(HI_VOID)
{
    TBsdStatus bsdRet = BSD_NO_ERROR;
    HI_S32 Ret = HI_SUCCESS;
    TBsd4BytesVector nuid;
    TUnsignedInt32 intNuid;
    TUnsignedInt8 pxInputData[UNIQUEDATA_LEN];        /*the data of unique data enc from the scs unchecked area*/
    TUnsignedInt8 pxOutputData[UNIQUEDATA_LEN];      /*the data to write to the scs unchecked area*/
    TUnsignedInt8 *dataBuf = NULL;                               /*the buf used for reading from or writing to the flash*/
    TUnsignedInt8 needEncrypt = 0;
    TUnsignedInt32 inputCmd = 0;
    HI_HANDLE hFlash;
    TUnsignedInt32 i;
    HI_Flash_InterInfo_S flashInfo;
    HI_FLASH_TYPE_E bootType;
    HI_U32 bootMedia = 0;
    HI_U32 u32UniqueDataStartAddress = 0;

    /* Initialize the BSD driver */
    bsdRet = bsdInitialize (NULL);
    if (BSD_NO_ERROR != bsdRet)
    {
        HI_DEBUG_BSD("BSD Initialize ERROR! bsdRet = 0x%x\n", bsdRet);
        return bsdRet;
    }
    
    u32UniqueDataStartAddress = UNIQUEDATA_START_ADDR_V300;
    
    bootMedia = get_bootmedia(NULL, NULL);

    if (BOOT_MEDIA_SPIFLASH == bootMedia)
    {
        bootType = HI_FLASH_TYPE_SPI_0;
    }
    else if (BOOT_MEDIA_NAND == bootMedia)
    {
        bootType = HI_FLASH_TYPE_NAND_0;
    }
    else
    {
        HI_DEBUG_BSD("Get Boot Mode ERROR!\n");
        bsdRet = BSD_ERROR;
        goto TERMINATE;
    }

    /*Open the Boot Flash*/
    hFlash = HI_Flash_OpenByTypeAndAddr(bootType, 0, 0x200000);
    if (HI_INVALID_HANDLE == hFlash)
    {
        HI_DEBUG_BSD("HI_Flash_Open failed\n");
        bsdRet = BSD_ERROR;
        goto TERMINATE;
    }

    if (HI_FLASH_TYPE_SPI_0 == bootType)
    {
        HI_DEBUG_BSD("Open SPI FLASH Successful!\n");
    }
    else if (HI_FLASH_TYPE_NAND_0 == bootType)
    {
        HI_DEBUG_BSD("Open NAND FLASH Successful!\n");
    }
    
    /*Get the blocksize of the boot flash*/
    Ret = HI_Flash_GetInfo(hFlash, &flashInfo);
    if (HI_SUCCESS != Ret)
    {
        HI_DEBUG_BSD("HI_Flash_GetInfo Failed:%#x\n",Ret);
        bsdRet = BSD_ERROR;
        goto FLASHCLOSE;
    }

    dataBuf = 0x08000000;
    /* read the whole blocksize data from boot code */
    Ret = HI_Flash_Read(hFlash, UNIQUEDATA_START_ADDR_V300, dataBuf, flashInfo.BlockSize, HI_FLASH_RW_FLAG_RAW);
    if (Ret <= 0)
    {
        HI_DEBUG_BSD("HI_Flash_Read Failed:%#x\n",Ret);
        bsdRet = BSD_ERROR;
        goto FLASHCLOSE;
    }

    /*Get the unique data enc from the SCS_Uncheck_Area*/
    memcpy(pxInputData, dataBuf, UNIQUEDATA_LEN);

    /* Get the NUID in order to retrieve the known output vector computed
    for this specific chipset in the ¡°Chipset_XYZ_Test_Vectors_1_x.h¡± file*/
    bsdRet = bsdGetNuid(nuid);
    if (BSD_NO_ERROR != bsdRet)
    {
        HI_DEBUG_BSD("BSD Get NUID ERROR! bsdRet = 0x%x\n", bsdRet);
        goto FLASHCLOSE;
    }
    
    /* The nuid is a MSBF 4-byte vector therefore it must be converted
    into a integer before it could be used*/
    intNuid = convertToInt(nuid);
    if (intNuid >= 0x80)
    {
        HI_DEBUG_BSD("BSD NUID Invalid!\n");
        bsdRet = BSD_ERROR;
        goto FLASHCLOSE;
    }

    /* Check the start and end of the encrypted form of the STB Unique
    Data Decryption Boot Code stored in the Flash device */
    if ((pxInputData[0] == UniqueDataEnc[intNuid][0]) &&
        (pxInputData[0x400-16] == UniqueDataEnc[intNuid][16]))
    {
        HI_DEBUG_BSD("\033[0;32m""STB Unique Data Decryption Boot Code Encrypted form Successful\n""\033[0m");

         /* Decrypt the STB Unique Data Decryption Boot Code from the SCS_Uncheck_Area */;
        bsdRet = bsdDecryptDataWithSecretContentKey(BSD_R2R_ALGORITHM_TDES,
                    pxInputData,
                    pxOutputData,
                    UNIQUEDATA_LEN);
        if (BSD_NO_ERROR != bsdRet)
        {
            HI_DEBUG_BSD("BSD Decrypt ERROR! bsdRet = 0x%x\n", bsdRet);
            goto FLASHCLOSE;
        }

        /* Compare OutputData with the content of UniqueDataRef.bin */
        if (!memcmp(pxOutputData, uniqueDataRef, UNIQUEDATA_LEN))
        {
            HI_DEBUG_BSD("\033[0;32m""STB Unique Data Decryption Boot Code Successful\n""\033[0m");
        }
        else
        {
            HI_DEBUG_BSD("\033[0;32m""STB Unique Data Decryption Boot Code Failed\n""\033[0m");

            needEncrypt = 1;
        }
    }
    else
    {
        HI_DEBUG_BSD("\033[0;32m""STB Unique Data Decryption Boot Code Encrypted form Failed\n""\033[0m");

        needEncrypt = 1;
        /* The Test Application still goes on */
    }

    /*print the UniqueDataRef*/
    HI_DEBUG_BSD("UniqueDataRef = ");
    for (i = 0; i< UNIQUEDATA_LEN - 1; i++)
    {
        if (i % 16 == 0)
        {
            HI_DEBUG_BSD("\n");
        }

        HI_DEBUG_BSD("0x%02x,", uniqueDataRef[i]);
    }
    HI_DEBUG_BSD("0x%02x\n", uniqueDataRef[UNIQUEDATA_LEN - 1]);
    
    if (1 == needEncrypt)
    {
        /* The user has to be able to terminate the function or to carry on
            the following instructions */
            
        HI_DEBUG_BSD("Please select:\n"
            "[a] Update the content of SCS_Unchecked_Area\n"
            "[b] Terminate the STB Unique Data Decryption Boot Code\n");

#ifndef HI_MINIBOOT_SUPPORT
        inputCmd = fgetc(stdin);
#else
        inputCmd = 'a';
#endif

        if ('a' == inputCmd)
        {
            HI_DEBUG_BSD("encrypting and writing to the flash...\n");
            /* Encrypt the STB Unique Data Decryption Boot Code from the
            SCS_UNCHECK_AREA */;
            memcpy(pxInputData, uniqueDataRef, UNIQUEDATA_LEN);
            bsdEncryptDataWithSecretContentKey(BSD_R2R_ALGORITHM_TDES,
                        pxInputData,
                        pxOutputData,
                        UNIQUEDATA_LEN);

            /*print the pxOutputData*/
            HI_DEBUG_BSD("pxOutputData = ");
            for (i = 0; i < UNIQUEDATA_LEN - 1; i++)
            {
                if (i % 16 == 0)
                {
                    HI_DEBUG_BSD("\n");
                }

                HI_DEBUG_BSD("0x%02x,", pxOutputData[i]);
            }
            HI_DEBUG_BSD("0x%02x\n", pxOutputData[UNIQUEDATA_LEN - 1]);

            memcpy(dataBuf, pxOutputData, UNIQUEDATA_LEN);
            /*write the encrypted data into flash*/
            Ret = HI_Flash_Write(hFlash,UNIQUEDATA_START_ADDR_V300,dataBuf,flashInfo.BlockSize,HI_FLASH_RW_FLAG_ERASE_FIRST);
            if (Ret <= 0)
            {
                HI_DEBUG_BSD("HI_Flash_Write Failed:%#x\n",Ret);
                goto FLASHCLOSE;
            }

            HI_DEBUG_BSD("\033[0;32m""STB Unique Data Write Boot Code Successful\n""\033[0m");
        }
        else if ('b' == inputCmd)
        {
            HI_DEBUG_BSD("prepare to quit!\n");
            goto FLASHCLOSE;
        }
        else
        {
            HI_DEBUG_BSD("Invalid Choice!\n");
            goto FLASHCLOSE;
        }
    }

FLASHCLOSE:
    HI_Flash_Close(hFlash);
    
TERMINATE:
    /* Terminate the BSD driver */
    bsdTerminate (NULL);

    return bsdRet;
}

