/*******************************************************************************
* All rights reserved, Copyright (C) huawei LIMITED 2012
*------------------------------------------------------------------------------
* File Name   : test_crypto.c
* Description :
* Platform    :
* Author      : qiqingchao
* Version     : V1.0
* Date        : 2013.7.17
* Notes       :
*
*------------------------------------------------------------------------------
* Modifications:
*   Date        Author          Modifications
*******************************************************************************/
/*******************************************************************************
 * This source code has been made available to you by HUAWEI on an
 * AS-IS basis. Anyone receiving this source code is licensed under HUAWEI
 * copyrights to use it in any way he or she deems fit, including copying it,
 * modifying it, compiling it, and redistributing it either with or without
 * modifications. Any person who transfers this source code or any derivative
 * work must include the HUAWEI copyright notice and this paragraph in
 * the transferred software.
*******************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#define TEEC_DEBUG
#include "tee_client_api.h"
#include "../CommomData_for_TestSuite.h"
#if 0
uint8_t AAD1_VALUE[] = {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07};
uint8_t TEE_ATTR_AES_256_VALUE01[] = {0x60, 0x3d, 0xeb, 0x10, 0x15, 0xca, 0x71, 0xbe, 0x2b, 0x73, 0xae,
                                      0xf0, 0x85, 0x7d, 0x77, 0x81, 0x1f, 0x35, 0x2c, 0x07, 0x3b, 0x61,
                                      0x08, 0xd7, 0x2d, 0x98, 0x10, 0xa3, 0x09, 0x14, 0xdf, 0xf4};
uint8_t IV1_VALUE_64bits_DES_DES3[] = {0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0x0,0xa,0xb,0xc,0xd,0xe,0xf};
uint8_t IV2_VALUE_128bits_AES[] = {0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0x0,0xa,0xb,0xc,0xd,0xe,0xf,
                                    0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0x0,0xa,0xb,0xc,0xd,0xe,0xf};
uint8_t IV_INVALID_LENGTH_VALUE[] = {0x01,0x02,0x03,0x04,0x05};
uint8_t NONCE1_VALUE_AES_CCM[] = {0x00,0x8D,0x49,0x3B,0x30,0xAE,0x8B,0x3C,0x96,0x96,0x76,0x6C,0xFA};
uint8_t NONCE2_VALUE_AES_GCM[] = {0xca,0xfe,0xba,0xbe,0xfa,0xce,0xdb,0xad,0xde,0xca,0xf8,0x88};

uint8_t DATA_FOR_CRYPTO1[] = {0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xa,0xb,0xc,0xd,0xe,0xf,
                              0xa,0xb,0xc,0xd,0xe,0xf,0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,
                              0xf,0xe,0xd,0xc,0xb,0xa,0x9,0x8,0x7,0x6,0x5,0x4,0x3,0x2,0x1,0x0,
                              0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xa,0xb,0xc,0xd,0xe,0xf,
                              0xa,0xb,0xc,0xd,0xe,0xf,0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,
                              0xf,0xe,0xd,0xc,0xb,0xa,0x9,0x8,0x7,0x6,0x5,0x4,0x3,0x2,0x1,0x0};
uint8_t DATA_FOR_CRYPTO1_PART1[] = {0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xa,0xb,0xc,0xd,0xe,0xf,
                                    0xa,0xb,0xc,0xd,0xe,0xf,0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9};
uint8_t DATA_FOR_CRYPTO1_PART2[] = {0xf,0xe,0xd,0xc,0xb,0xa,0x9,0x8,0x7,0x6,0x5,0x4,0x3,0x2,0x1,0x0,
                                    0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xa,0xb,0xc,0xd,0xe,0xf};
uint8_t DATA_FOR_CRYPTO1_PART3[] = {0xa,0xb,0xc,0xd,0xe,0xf,0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,
                                    0xf,0xe,0xd,0xc,0xb,0xa,0x9,0x8,0x7,0x6,0x5,0x4,0x3,0x2,0x1,0x0};
uint8_t TEE_ATTR_RSA_MODULUS_VALUE01[] = {
0xf0,0x1a,0x95,0xcd,0x5f,0x9f,0x1c,0xbc,0x5c,0x2e,0xc8,0x00,0x3b,0xfa,0xe0,0xd5,
0x72,0xea,0xfc,0x9e,0x74,0xe1,0x02,0x66,0xa8,0x13,0x3f,0x0c,0xe6,0x24,0xcb,0x1c,
0xa5,0xdf,0x64,0xfb,0x06,0xd7,0x13,0xce,0xaa,0x6c,0xee,0x16,0x7b,0xf8,0x92,0xaf,
0xc4,0x5b,0x46,0x18,0xc6,0x30,0xb6,0x04,0x1c,0x3a,0x2e,0xd7,0xca,0xb8,0xb5,0x00,
0x78,0x89,0xa0,0x69,0x37,0x84,0x59,0x99,0x0c,0x2f,0x00,0xe5,0x3b,0xe1,0x18,0xe0,
0xb9,0x2e,0x77,0x1d,0x32,0x7e,0x5f,0xf4,0x18,0xf3,0x9f,0x58,0xc6,0x83,0xe2,0x7a,
0xcb,0x89,0x18,0xc2,0x09,0x84,0x7e,0x9d,0x96,0xe0,0xb9,0x49,0x75,0xef,0xcf,0xff,
0xf0,0xb6,0x18,0xd3,0x7a,0xc1,0x6f,0x0c,0x55,0x33,0xbe,0x9d,0x63,0x06,0xd6,0x9f,
0xc1,0xa5,0xe9,0xbd,0xb1,0xb2,0x5d,0x5c,0xf9,0xab,0xa9,0xb5,0x6a,0x4e,0xa4,0xfa,
0x44,0x32,0xd6,0x71,0x2e,0x5f,0xa6,0x25,0xf8,0x40,0x24,0xc4,0x5b,0x61,0x55,0x1b,
0xac,0xa3,0x0a,0x11,0x8e,0x65,0x20,0xda,0x2c,0x0d,0xdf,0xdb,0x47,0x6b,0x61,0x18,
0x4d,0xfe,0xfd,0x2a,0x7e,0x77,0x40,0x44,0x43,0xc6,0x33,0x6c,0xe5,0x1b,0x8d,0x80,
0xf9,0x97,0xa2,0xe4,0xb9,0x34,0x3e,0x28,0x94,0x9f,0xbd,0xa8,0x2b,0x0a,0x4d,0x1a,
0xa8,0x06,0xe5,0x99,0x4e,0xb9,0x13,0x45,0xc8,0xf6,0x0f,0xd0,0x4d,0xbf,0xe7,0x8f,
0xed,0xca,0x8e,0xf8,0x8d,0x87,0x5f,0xd4,0xb4,0x1a,0x2c,0xc9,0xa7,0x67,0x7e,0xb2,
0x1b,0xc1,0xce,0xb6,0x83,0x7c,0xce,0xb4,0x3d,0x85,0xc7,0x53,0x30,0x7c,0xfe,0x85};
uint32_t TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01 = 0x10001;
static const TEEC_UUID UUID_TTA_testingInternalAPI_crypto =
{
        0x534D4152, 0x5443, 0x534C,
            { 0x54, 0x43, 0x52, 0x59, 0x50, 0x54, 0x4f, 0x31 }
};
#endif
static TEEC_UUID uuid = UUID_TTA_testingInternalAPI_crypto;
static uint8_t sign[512];
static uint8_t buffer[4];
static uint8_t AES_MAC_result[16];
static uint8_t HMAC_result[64];//MAX size

uint8_t *retrieveUint32toBuffer(uint32_t i)
{
    buffer[3] = i & 0xff;
    buffer[2] = i>>8 & 0xff;
    buffer[1] = i>>16 & 0xff;
    buffer[0] = i>>24 & 0xff;
    //TEEC_Error("%x,%x,%x,%x\n", buffer[0], buffer[1],buffer[2], buffer[3]);
    return buffer;
}

//Invoke_Crypto_AEDecryptFinal_AES_TEE_ALG_AES_GCM_Success
TEEC_Result Invoke_Crypto_AEDecryptFinal_AES_TEE_ALG_AES_GCM_Success(uint32_t tagLen)
{
    TEEC_Result result = 0;
    return result;
}
//Invoke_Crypto_AEDecryptFinal_AES_TEE_ALG_AES_CCM_Success
TEEC_Result Invoke_Crypto_AEDecryptFinal_AES_TEE_ALG_AES_CCM_Success(uint32_t tagLen, uint32_t mac_case,
            uint32_t algorithm, uint32_t short_buffer, uint32_t encrypt_decrypt, uint32_t AEupdate)
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    TEEC_SharedMemory SharedMem3;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_Data[3][32] = {0};
    uint8_t decrypt_Data[3][32] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));


    SharedMem3.buffer = NULL;
    SharedMem3.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    SharedMem3.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem3);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem3.buffer, 0, sizeof(DATA_FOR_CRYPTO1_PART1));
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    operation.started = 1;
    //Invoke_Crypto_InitObjectWithKeys
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    #if 0
    TEEC_Debug("%x, %x, %x\n", *(uint32_t *)SharedMem1.buffer, *(uint32_t *)(SharedMem1.buffer+4),
        *(uint32_t *)(SharedMem1.buffer+8));
    #endif
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //+++++++++++++++++++++encrypt++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_AES_256 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)NONCE1_VALUE_AES_CCM, sizeof(NONCE1_VALUE_AES_CCM));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = tagLen/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(NONCE1_VALUE_AES_CCM);
    operation.params[2].value.a = AAD1_LENGTH;
    operation.params[2].value.b = LENGTH_DATA_FOR_CRYPTO1;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //Invoke_Crypto_AEUpdateAAD
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)AAD1_VALUE, sizeof(AAD1_VALUE));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(AAD1_VALUE);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdateAAD, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEUpdate_for_encryption
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    if(AEupdate == 1 && short_buffer == OUTPUT_BUFFER_TOO_SHORT)
        operation.params[3].memref.size = 1;
    else
        operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)encrypt_Data[0], SharedMem2.buffer, 32);
    #if 0
    for(i=0; i<32; i++){
        TEEC_Debug("encrypt_Data[0][%d] = %x\n", i, *((uint8_t *)SharedMem2.buffer+i));
    }
    #endif
    //Invoke_Crypto_AEUpdate_for_encryption
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    memcpy((void *)encrypt_Data[1], SharedMem2.buffer, 32);
    #if 0
    for(i=0; i<32; i++){
        TEEC_Debug("encrypt_Data[1][%d] = %x\n", i, encrypt_Data[1][i]);
    }
    #endif

    //Invoke_Crypto_AEEncryptFinal
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_OUTPUT,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[2].memref.parent = &SharedMem3;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    if(short_buffer == OUTPUT_BUFFER_TOO_SHORT && encrypt_decrypt == TEE_MODE_ENCRYPT)
        operation.params[3].memref.size = 1;
    else
        operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEEncryptFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)encrypt_Data[2], SharedMem2.buffer, 32);
    #if 0
    for(i=0; i<32; i++){
        TEEC_Debug("encrypt_Data[2][%d] = %x\n", i, encrypt_Data[2][i]);
    }
    #endif

    //++++++++++++++++++++++++decrypt+++++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_DECRYPT;
    operation.params[1].value.a = SIZE_AES_256 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)NONCE1_VALUE_AES_CCM, sizeof(NONCE1_VALUE_AES_CCM));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = tagLen/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(NONCE1_VALUE_AES_CCM);
    operation.params[2].value.a = AAD1_LENGTH;
    operation.params[2].value.b = LENGTH_DATA_FOR_CRYPTO1;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEUpdateAAD
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)AAD1_VALUE, sizeof(AAD1_VALUE));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(AAD1_VALUE);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdateAAD, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEUpdate_for_decryption
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)encrypt_Data[0], sizeof(encrypt_Data[0]));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(encrypt_Data[0]);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(encrypt_Data[0]);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    memcpy((void *)decrypt_Data[0], SharedMem2.buffer, 32);

    //Invoke_Crypto_AEUpdate_for_decryption
    memcpy(SharedMem1.buffer, (void *)encrypt_Data[1], sizeof(encrypt_Data[1]));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(encrypt_Data[1]);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(encrypt_Data[1]);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    memcpy((void *)decrypt_Data[1], SharedMem2.buffer, 32);

    //Invoke_Crypto_AEDecryptFinal
    if(mac_case == INVALID_MAC){
        *(char *)(SharedMem3.buffer) = 0xff;
    }
    memcpy(SharedMem1.buffer, (void *)encrypt_Data[2], sizeof(encrypt_Data[2]));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(encrypt_Data[2]);
    operation.params[2].memref.parent = &SharedMem3;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(encrypt_Data[2]);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    if(short_buffer == OUTPUT_BUFFER_TOO_SHORT && encrypt_decrypt == TEE_MODE_DECRYPT)
        operation.params[3].memref.size = 1;
    else
        operation.params[3].memref.size = sizeof(encrypt_Data[2]);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEDecryptFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)decrypt_Data[2], SharedMem2.buffer, 32);

    if(memcmp(DATA_FOR_CRYPTO1, decrypt_Data, sizeof(decrypt_Data))){
        TEEC_Error("decrypt data is not equal to encrypt\n");
        #if 1
        for(i=0; i<sizeof(DATA_FOR_CRYPTO1); i++){
            TEEC_Error("DATA_FOR_CRYPTO1[%d] = %x, decrypt_Data[%d] = %x\n",
                i, DATA_FOR_CRYPTO1[i], i, *((uint8_t *)decrypt_Data+i));
        }
        #endif
        result = TEEC_ERROR_MAC_INVALID;
    }
cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    if(SharedMem3.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem3);

cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_AEDecryptFinal_AES_112_bits_TEE_ALG_AES_CCM(uint32_t tagLen, uint32_t mac_case,
            uint32_t algorithm, uint32_t short_buffer, uint32_t encrypt_decrypt, uint32_t AEupdate)
{
          TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    TEEC_SharedMemory SharedMem3;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_Data[3][32] = {0};
    uint8_t decrypt_Data[3][32] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
 //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));
    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));


    SharedMem3.buffer = NULL;
    SharedMem3.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    SharedMem3.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem3);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem3.buffer, 0, sizeof(DATA_FOR_CRYPTO1_PART1));
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

	    operation.started = 1;
    //Invoke_Crypto_InitObjectWithKeys
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    #if 0
    TEEC_Debug("%x, %x, %x\n", *(uint32_t *)SharedMem1.buffer, *(uint32_t *)(SharedMem1.buffer+4),
        *(uint32_t *)(SharedMem1.buffer+8));
    #endif
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
	 //+++++++++++++++++++++encrypt++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_AES_256 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)NONCE1_VALUE_AES_CCM, sizeof(NONCE1_VALUE_AES_CCM));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = tagLen/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(NONCE1_VALUE_AES_CCM);
    operation.params[2].value.a = AAD1_LENGTH;
    operation.params[2].value.b = LENGTH_DATA_FOR_CRYPTO1;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //Invoke_Crypto_AEUpdateAAD
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)AAD1_VALUE, sizeof(AAD1_VALUE));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(AAD1_VALUE);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdateAAD, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEUpdate_for_encryption
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    if(AEupdate == 1 && short_buffer == OUTPUT_BUFFER_TOO_SHORT)
        operation.params[3].memref.size = 1;
    else
        operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)encrypt_Data[0], SharedMem2.buffer, 32);
    #if 0
    for(i=0; i<32; i++){
        TEEC_Debug("encrypt_Data[0][%d] = %x\n", i, *((uint8_t *)SharedMem2.buffer+i));
    }
    #endif
    //Invoke_Crypto_AEUpdate_for_encryption
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    memcpy((void *)encrypt_Data[1], SharedMem2.buffer, 32);
    #if 0
    for(i=0; i<32; i++){
        TEEC_Debug("encrypt_Data[1][%d] = %x\n", i, encrypt_Data[1][i]);
    }
    #endif

    //Invoke_Crypto_AEEncryptFinal
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_OUTPUT,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[2].memref.parent = &SharedMem3;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    if(short_buffer == OUTPUT_BUFFER_TOO_SHORT && encrypt_decrypt == TEE_MODE_ENCRYPT)
        operation.params[3].memref.size = 1;
    else
        operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEEncryptFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)encrypt_Data[2], SharedMem2.buffer, 32);
    #if 0
    for(i=0; i<32; i++){
        TEEC_Debug("encrypt_Data[2][%d] = %x\n", i, encrypt_Data[2][i]);
    }
    #endif

    //++++++++++++++++++++++++decrypt+++++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_DECRYPT;
    operation.params[1].value.a = SIZE_AES_256 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)NONCE1_VALUE_AES_CCM, sizeof(NONCE1_VALUE_AES_CCM));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = tagLen/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(NONCE1_VALUE_AES_CCM);
    operation.params[2].value.a = AAD1_LENGTH;
    operation.params[2].value.b = LENGTH_DATA_FOR_CRYPTO1;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEUpdateAAD
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)AAD1_VALUE, sizeof(AAD1_VALUE));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(AAD1_VALUE);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdateAAD, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEUpdate_for_decryption
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)encrypt_Data[0], sizeof(encrypt_Data[0]));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(encrypt_Data[0]);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(encrypt_Data[0]);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    memcpy((void *)decrypt_Data[0], SharedMem2.buffer, 32);

    //Invoke_Crypto_AEUpdate_for_decryption
    memcpy(SharedMem1.buffer, (void *)encrypt_Data[1], sizeof(encrypt_Data[1]));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(encrypt_Data[1]);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(encrypt_Data[1]);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    memcpy((void *)decrypt_Data[1], SharedMem2.buffer, 32);

    //Invoke_Crypto_AEDecryptFinal
    if(mac_case == INVALID_MAC){
        *(char *)(SharedMem3.buffer) = 0xff;
    }
    memcpy(SharedMem1.buffer, (void *)encrypt_Data[2], sizeof(encrypt_Data[2]));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(encrypt_Data[2]);
    operation.params[2].memref.parent = &SharedMem3;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(encrypt_Data[2]);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    if(short_buffer == OUTPUT_BUFFER_TOO_SHORT && encrypt_decrypt == TEE_MODE_DECRYPT)
        operation.params[3].memref.size = 1;
    else
        operation.params[3].memref.size = sizeof(encrypt_Data[2]);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEDecryptFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)decrypt_Data[2], SharedMem2.buffer, 32);

    if(memcmp(DATA_FOR_CRYPTO1, decrypt_Data, sizeof(decrypt_Data))){
        TEEC_Error("decrypt data is not equal to encrypt\n");
        #if 1
        for(i=0; i<sizeof(DATA_FOR_CRYPTO1); i++){
            TEEC_Error("DATA_FOR_CRYPTO1[%d] = %x, decrypt_Data[%d] = %x\n",
                i, DATA_FOR_CRYPTO1[i], i, *((uint8_t *)decrypt_Data+i));
        }
        #endif
        result = TEEC_ERROR_MAC_INVALID;
    }
cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    if(SharedMem3.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem3);

cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;
}

TEEC_Result Invoke_Crypto_AEDecryptFinal_AES_128_bits_TEE_ALG_AES_CCM(uint32_t tagLen, uint32_t mac_case,
            uint32_t algorithm, uint32_t short_buffer, uint32_t encrypt_decrypt, uint32_t AEupdate)
{
          TEEC_Context context01;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    TEEC_SharedMemory SharedMem3;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_Data[3][32] = {0};
    uint8_t decrypt_Data[3][32] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context01);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
 //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context01,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context01,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));


    SharedMem3.buffer = NULL;
    SharedMem3.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    SharedMem3.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context01,
                &SharedMem3);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem3.buffer, 0, sizeof(DATA_FOR_CRYPTO1_PART1));
    //OpenSession
    result = TEEC_OpenSession(&context01, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

	    operation.started = 1;
    //Invoke_Crypto_InitObjectWithKeys
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    #if 0
    TEEC_Debug("%x, %x, %x\n", *(uint32_t *)SharedMem1.buffer, *(uint32_t *)(SharedMem1.buffer+4),
        *(uint32_t *)(SharedMem1.buffer+8));
    #endif
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
	 //+++++++++++++++++++++encrypt++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_AES_256 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)NONCE1_VALUE_AES_CCM, sizeof(NONCE1_VALUE_AES_CCM));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = tagLen/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(NONCE1_VALUE_AES_CCM);
    operation.params[2].value.a = AAD1_LENGTH;
    operation.params[2].value.b = LENGTH_DATA_FOR_CRYPTO1;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //Invoke_Crypto_AEUpdateAAD
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)AAD1_VALUE, sizeof(AAD1_VALUE));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(AAD1_VALUE);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdateAAD, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEUpdate_for_encryption
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    if(AEupdate == 1 && short_buffer == OUTPUT_BUFFER_TOO_SHORT)
        operation.params[3].memref.size = 1;
    else
        operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)encrypt_Data[0], SharedMem2.buffer, 32);
    #if 0
    for(i=0; i<32; i++){
        TEEC_Debug("encrypt_Data[0][%d] = %x\n", i, *((uint8_t *)SharedMem2.buffer+i));
    }
    #endif
    //Invoke_Crypto_AEUpdate_for_encryption
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    memcpy((void *)encrypt_Data[1], SharedMem2.buffer, 32);
    #if 0
    for(i=0; i<32; i++){
        TEEC_Debug("encrypt_Data[1][%d] = %x\n", i, encrypt_Data[1][i]);
    }
    #endif

    //Invoke_Crypto_AEEncryptFinal
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_OUTPUT,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[2].memref.parent = &SharedMem3;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    if(short_buffer == OUTPUT_BUFFER_TOO_SHORT && encrypt_decrypt == TEE_MODE_ENCRYPT)
        operation.params[3].memref.size = 1;
    else
        operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEEncryptFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)encrypt_Data[2], SharedMem2.buffer, 32);
    #if 0
    for(i=0; i<32; i++){
        TEEC_Debug("encrypt_Data[2][%d] = %x\n", i, encrypt_Data[2][i]);
    }
    #endif

    //++++++++++++++++++++++++decrypt+++++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_DECRYPT;
    operation.params[1].value.a = SIZE_AES_256 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)NONCE1_VALUE_AES_CCM, sizeof(NONCE1_VALUE_AES_CCM));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = tagLen/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(NONCE1_VALUE_AES_CCM);
    operation.params[2].value.a = AAD1_LENGTH;
    operation.params[2].value.b = LENGTH_DATA_FOR_CRYPTO1;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEUpdateAAD
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)AAD1_VALUE, sizeof(AAD1_VALUE));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(AAD1_VALUE);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdateAAD, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEUpdate_for_decryption
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)encrypt_Data[0], sizeof(encrypt_Data[0]));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(encrypt_Data[0]);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(encrypt_Data[0]);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    memcpy((void *)decrypt_Data[0], SharedMem2.buffer, 32);

    //Invoke_Crypto_AEUpdate_for_decryption
    memcpy(SharedMem1.buffer, (void *)encrypt_Data[1], sizeof(encrypt_Data[1]));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(encrypt_Data[1]);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(encrypt_Data[1]);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    memcpy((void *)decrypt_Data[1], SharedMem2.buffer, 32);

    //Invoke_Crypto_AEDecryptFinal
    //mac_case = INVALID_MAC;
    if(mac_case == INVALID_MAC){
        *(char *)(SharedMem3.buffer) = 0xff;
    }
    memcpy(SharedMem1.buffer, (void *)encrypt_Data[2], sizeof(encrypt_Data[2]));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(encrypt_Data[2]);
    operation.params[2].memref.parent = &SharedMem3;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(encrypt_Data[2]);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    if(short_buffer == OUTPUT_BUFFER_TOO_SHORT && encrypt_decrypt == TEE_MODE_DECRYPT)
        operation.params[3].memref.size = 1;
    else
        operation.params[3].memref.size = sizeof(encrypt_Data[2]);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEDecryptFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)decrypt_Data[2], SharedMem2.buffer, 32);

    if(memcmp(DATA_FOR_CRYPTO1, decrypt_Data, sizeof(decrypt_Data))){
        TEEC_Error("decrypt data is not equal to encrypt\n");
        #if 1
        for(i=0; i<sizeof(DATA_FOR_CRYPTO1); i++){
            TEEC_Error("DATA_FOR_CRYPTO1[%d] = %x, decrypt_Data[%d] = %x\n",
                i, DATA_FOR_CRYPTO1[i], i, *((uint8_t *)decrypt_Data+i));
        }
        #endif
        result = TEEC_ERROR_MAC_INVALID;
    }
cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    if(SharedMem3.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem3);

cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context01);
cleanup_1:
    return result;
}

TEEC_Result Invoke_Crypto_AEDecryptFinal_AES_48_bits_TEE_ALG_AES_CCM(uint32_t tagLen, uint32_t mac_case,
            uint32_t algorithm, uint32_t short_buffer, uint32_t encrypt_decrypt, uint32_t AEupdate)
{
          TEEC_Context context01;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    TEEC_SharedMemory SharedMem3;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_Data[3][32] = {0};
    uint8_t decrypt_Data[3][32] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context01);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
 //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context01,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context01,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));


    SharedMem3.buffer = NULL;
    SharedMem3.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    SharedMem3.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context01,
                &SharedMem3);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem3.buffer, 0, sizeof(DATA_FOR_CRYPTO1_PART1));
    //OpenSession
    result = TEEC_OpenSession(&context01, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

	    operation.started = 1;
    //Invoke_Crypto_InitObjectWithKeys
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    #if 0
    TEEC_Debug("%x, %x, %x\n", *(uint32_t *)SharedMem1.buffer, *(uint32_t *)(SharedMem1.buffer+4),
        *(uint32_t *)(SharedMem1.buffer+8));
    #endif
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
	 //+++++++++++++++++++++encrypt++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_AES_256 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)NONCE1_VALUE_AES_CCM, sizeof(NONCE1_VALUE_AES_CCM));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = tagLen/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(NONCE1_VALUE_AES_CCM);
    operation.params[2].value.a = AAD1_LENGTH;
    operation.params[2].value.b = LENGTH_DATA_FOR_CRYPTO1;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //Invoke_Crypto_AEUpdateAAD
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)AAD1_VALUE, sizeof(AAD1_VALUE));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(AAD1_VALUE);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdateAAD, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEUpdate_for_encryption
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    if(AEupdate == 1 && short_buffer == OUTPUT_BUFFER_TOO_SHORT)
        operation.params[3].memref.size = 1;
    else
        operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)encrypt_Data[0], SharedMem2.buffer, 32);
    #if 0
    for(i=0; i<32; i++){
        TEEC_Debug("encrypt_Data[0][%d] = %x\n", i, *((uint8_t *)SharedMem2.buffer+i));
    }
    #endif
    //Invoke_Crypto_AEUpdate_for_encryption
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    memcpy((void *)encrypt_Data[1], SharedMem2.buffer, 32);
    #if 0
    for(i=0; i<32; i++){
        TEEC_Debug("encrypt_Data[1][%d] = %x\n", i, encrypt_Data[1][i]);
    }
    #endif

    //Invoke_Crypto_AEEncryptFinal
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_OUTPUT,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[2].memref.parent = &SharedMem3;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    if(short_buffer == OUTPUT_BUFFER_TOO_SHORT && encrypt_decrypt == TEE_MODE_ENCRYPT)
        operation.params[3].memref.size = 1;
    else
        operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEEncryptFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)encrypt_Data[2], SharedMem2.buffer, 32);
    #if 0
    for(i=0; i<32; i++){
        TEEC_Debug("encrypt_Data[2][%d] = %x\n", i, encrypt_Data[2][i]);
    }
    #endif

    //++++++++++++++++++++++++decrypt+++++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_DECRYPT;
    operation.params[1].value.a = SIZE_AES_256 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)NONCE1_VALUE_AES_CCM, sizeof(NONCE1_VALUE_AES_CCM));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = tagLen/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(NONCE1_VALUE_AES_CCM);
    operation.params[2].value.a = AAD1_LENGTH;
    operation.params[2].value.b = LENGTH_DATA_FOR_CRYPTO1;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEUpdateAAD
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)AAD1_VALUE, sizeof(AAD1_VALUE));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(AAD1_VALUE);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdateAAD, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEUpdate_for_decryption
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)encrypt_Data[0], sizeof(encrypt_Data[0]));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(encrypt_Data[0]);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(encrypt_Data[0]);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    memcpy((void *)decrypt_Data[0], SharedMem2.buffer, 32);

    //Invoke_Crypto_AEUpdate_for_decryption
    memcpy(SharedMem1.buffer, (void *)encrypt_Data[1], sizeof(encrypt_Data[1]));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(encrypt_Data[1]);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(encrypt_Data[1]);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    memcpy((void *)decrypt_Data[1], SharedMem2.buffer, 32);

    //Invoke_Crypto_AEDecryptFinal
    if(mac_case == INVALID_MAC){
        *(char *)(SharedMem3.buffer) = 0xff;
    }
    memcpy(SharedMem1.buffer, (void *)encrypt_Data[2], sizeof(encrypt_Data[2]));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(encrypt_Data[2]);
    operation.params[2].memref.parent = &SharedMem3;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(encrypt_Data[2]);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    if(short_buffer == OUTPUT_BUFFER_TOO_SHORT && encrypt_decrypt == TEE_MODE_DECRYPT)
        operation.params[3].memref.size = 1;
    else
        operation.params[3].memref.size = sizeof(encrypt_Data[2]);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEDecryptFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)decrypt_Data[2], SharedMem2.buffer, 32);

    if(memcmp(DATA_FOR_CRYPTO1, decrypt_Data, sizeof(decrypt_Data))){
        TEEC_Error("decrypt data is not equal to encrypt\n");
        #if 1
        for(i=0; i<sizeof(DATA_FOR_CRYPTO1); i++){
            TEEC_Error("DATA_FOR_CRYPTO1[%d] = %x, decrypt_Data[%d] = %x\n",
                i, DATA_FOR_CRYPTO1[i], i, *((uint8_t *)decrypt_Data+i));
        }
        #endif
        result = TEEC_ERROR_MAC_INVALID;
    }
cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    if(SharedMem3.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem3);

cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context01);
cleanup_1:
    return result;
}

TEEC_Result Invoke_Crypto_AEDecryptFinal_AES_64_bits_TEE_ALG_AES_CCM(uint32_t tagLen, uint32_t mac_case,
            uint32_t algorithm, uint32_t short_buffer, uint32_t encrypt_decrypt, uint32_t AEupdate)
{
          TEEC_Context context01;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    TEEC_SharedMemory SharedMem3;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_Data[3][32] = {0};
    uint8_t decrypt_Data[3][32] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context01);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
 //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context01,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context01,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));


    SharedMem3.buffer = NULL;
    SharedMem3.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    SharedMem3.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context01,
                &SharedMem3);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem3.buffer, 0, sizeof(DATA_FOR_CRYPTO1_PART1));
    //OpenSession
    result = TEEC_OpenSession(&context01, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

	    operation.started = 1;
    //Invoke_Crypto_InitObjectWithKeys
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    #if 0
    TEEC_Debug("%x, %x, %x\n", *(uint32_t *)SharedMem1.buffer, *(uint32_t *)(SharedMem1.buffer+4),
        *(uint32_t *)(SharedMem1.buffer+8));
    #endif
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
	 //+++++++++++++++++++++encrypt++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_AES_256 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)NONCE1_VALUE_AES_CCM, sizeof(NONCE1_VALUE_AES_CCM));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = tagLen/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(NONCE1_VALUE_AES_CCM);
    operation.params[2].value.a = AAD1_LENGTH;
    operation.params[2].value.b = LENGTH_DATA_FOR_CRYPTO1;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //Invoke_Crypto_AEUpdateAAD
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)AAD1_VALUE, sizeof(AAD1_VALUE));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(AAD1_VALUE);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdateAAD, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEUpdate_for_encryption
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    if(AEupdate == 1 && short_buffer == OUTPUT_BUFFER_TOO_SHORT)
        operation.params[3].memref.size = 1;
    else
        operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)encrypt_Data[0], SharedMem2.buffer, 32);
    #if 0
    for(i=0; i<32; i++){
        TEEC_Debug("encrypt_Data[0][%d] = %x\n", i, *((uint8_t *)SharedMem2.buffer+i));
    }
    #endif
    //Invoke_Crypto_AEUpdate_for_encryption
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    memcpy((void *)encrypt_Data[1], SharedMem2.buffer, 32);
    #if 0
    for(i=0; i<32; i++){
        TEEC_Debug("encrypt_Data[1][%d] = %x\n", i, encrypt_Data[1][i]);
    }
    #endif

    //Invoke_Crypto_AEEncryptFinal
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_OUTPUT,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[2].memref.parent = &SharedMem3;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    if(short_buffer == OUTPUT_BUFFER_TOO_SHORT && encrypt_decrypt == TEE_MODE_ENCRYPT)
        operation.params[3].memref.size = 1;
    else
        operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEEncryptFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)encrypt_Data[2], SharedMem2.buffer, 32);
    #if 0
    for(i=0; i<32; i++){
        TEEC_Debug("encrypt_Data[2][%d] = %x\n", i, encrypt_Data[2][i]);
    }
    #endif

    //++++++++++++++++++++++++decrypt+++++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_DECRYPT;
    operation.params[1].value.a = SIZE_AES_256 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)NONCE1_VALUE_AES_CCM, sizeof(NONCE1_VALUE_AES_CCM));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = tagLen/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(NONCE1_VALUE_AES_CCM);
    operation.params[2].value.a = AAD1_LENGTH;
    operation.params[2].value.b = LENGTH_DATA_FOR_CRYPTO1;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEUpdateAAD
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)AAD1_VALUE, sizeof(AAD1_VALUE));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(AAD1_VALUE);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdateAAD, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEUpdate_for_decryption
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)encrypt_Data[0], sizeof(encrypt_Data[0]));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(encrypt_Data[0]);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(encrypt_Data[0]);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    memcpy((void *)decrypt_Data[0], SharedMem2.buffer, 32);

    //Invoke_Crypto_AEUpdate_for_decryption
    memcpy(SharedMem1.buffer, (void *)encrypt_Data[1], sizeof(encrypt_Data[1]));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(encrypt_Data[1]);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(encrypt_Data[1]);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    memcpy((void *)decrypt_Data[1], SharedMem2.buffer, 32);

    //Invoke_Crypto_AEDecryptFinal
    if(mac_case == INVALID_MAC){
        *(char *)(SharedMem3.buffer) = 0xff;
    }
    memcpy(SharedMem1.buffer, (void *)encrypt_Data[2], sizeof(encrypt_Data[2]));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(encrypt_Data[2]);
    operation.params[2].memref.parent = &SharedMem3;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(encrypt_Data[2]);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    if(short_buffer == OUTPUT_BUFFER_TOO_SHORT && encrypt_decrypt == TEE_MODE_DECRYPT)
        operation.params[3].memref.size = 1;
    else
        operation.params[3].memref.size = sizeof(encrypt_Data[2]);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEDecryptFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)decrypt_Data[2], SharedMem2.buffer, 32);

    if(memcmp(DATA_FOR_CRYPTO1, decrypt_Data, sizeof(decrypt_Data))){
        TEEC_Error("decrypt data is not equal to encrypt\n");
        #if 1
        for(i=0; i<sizeof(DATA_FOR_CRYPTO1); i++){
            TEEC_Error("DATA_FOR_CRYPTO1[%d] = %x, decrypt_Data[%d] = %x\n",
                i, DATA_FOR_CRYPTO1[i], i, *((uint8_t *)decrypt_Data+i));
        }
        #endif
        result = TEEC_ERROR_MAC_INVALID;
    }
cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    if(SharedMem3.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem3);

cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context01);
cleanup_1:
    return result;
}

TEEC_Result Invoke_Crypto_AEDecryptFinal_AES_96_bits_TEE_ALG_AES_CCM(uint32_t tagLen, uint32_t mac_case,
            uint32_t algorithm, uint32_t short_buffer, uint32_t encrypt_decrypt, uint32_t AEupdate)
{
          TEEC_Context context01;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    TEEC_SharedMemory SharedMem3;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_Data[3][32] = {0};
    uint8_t decrypt_Data[3][32] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context01);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
 //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context01,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context01,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));


    SharedMem3.buffer = NULL;
    SharedMem3.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    SharedMem3.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context01,
                &SharedMem3);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem3.buffer, 0, sizeof(DATA_FOR_CRYPTO1_PART1));
    //OpenSession
    result = TEEC_OpenSession(&context01, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

	    operation.started = 1;
    //Invoke_Crypto_InitObjectWithKeys
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    #if 0
    TEEC_Debug("%x, %x, %x\n", *(uint32_t *)SharedMem1.buffer, *(uint32_t *)(SharedMem1.buffer+4),
        *(uint32_t *)(SharedMem1.buffer+8));
    #endif
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
	 //+++++++++++++++++++++encrypt++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_AES_256 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)NONCE1_VALUE_AES_CCM, sizeof(NONCE1_VALUE_AES_CCM));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = tagLen/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(NONCE1_VALUE_AES_CCM);
    operation.params[2].value.a = AAD1_LENGTH;
    operation.params[2].value.b = LENGTH_DATA_FOR_CRYPTO1;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //Invoke_Crypto_AEUpdateAAD
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)AAD1_VALUE, sizeof(AAD1_VALUE));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(AAD1_VALUE);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdateAAD, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEUpdate_for_encryption
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    if(AEupdate == 1 && short_buffer == OUTPUT_BUFFER_TOO_SHORT)
        operation.params[3].memref.size = 1;
    else
        operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)encrypt_Data[0], SharedMem2.buffer, 32);
    #if 0
    for(i=0; i<32; i++){
        TEEC_Debug("encrypt_Data[0][%d] = %x\n", i, *((uint8_t *)SharedMem2.buffer+i));
    }
    #endif
    //Invoke_Crypto_AEUpdate_for_encryption
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    memcpy((void *)encrypt_Data[1], SharedMem2.buffer, 32);
    #if 0
    for(i=0; i<32; i++){
        TEEC_Debug("encrypt_Data[1][%d] = %x\n", i, encrypt_Data[1][i]);
    }
    #endif

    //Invoke_Crypto_AEEncryptFinal
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_OUTPUT,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[2].memref.parent = &SharedMem3;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    if(short_buffer == OUTPUT_BUFFER_TOO_SHORT && encrypt_decrypt == TEE_MODE_ENCRYPT)
        operation.params[3].memref.size = 1;
    else
        operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEEncryptFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)encrypt_Data[2], SharedMem2.buffer, 32);
    #if 0
    for(i=0; i<32; i++){
        TEEC_Debug("encrypt_Data[2][%d] = %x\n", i, encrypt_Data[2][i]);
    }
    #endif

    //++++++++++++++++++++++++decrypt+++++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_DECRYPT;
    operation.params[1].value.a = SIZE_AES_256 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)NONCE1_VALUE_AES_CCM, sizeof(NONCE1_VALUE_AES_CCM));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = tagLen/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(NONCE1_VALUE_AES_CCM);
    operation.params[2].value.a = AAD1_LENGTH;
    operation.params[2].value.b = LENGTH_DATA_FOR_CRYPTO1;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEUpdateAAD
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)AAD1_VALUE, sizeof(AAD1_VALUE));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(AAD1_VALUE);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdateAAD, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEUpdate_for_decryption
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)encrypt_Data[0], sizeof(encrypt_Data[0]));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(encrypt_Data[0]);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(encrypt_Data[0]);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    memcpy((void *)decrypt_Data[0], SharedMem2.buffer, 32);

    //Invoke_Crypto_AEUpdate_for_decryption
    memcpy(SharedMem1.buffer, (void *)encrypt_Data[1], sizeof(encrypt_Data[1]));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(encrypt_Data[1]);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(encrypt_Data[1]);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    memcpy((void *)decrypt_Data[1], SharedMem2.buffer, 32);

    //Invoke_Crypto_AEDecryptFinal
    if(mac_case == INVALID_MAC){
        *(char *)(SharedMem3.buffer) = 0xff;
    }
    memcpy(SharedMem1.buffer, (void *)encrypt_Data[2], sizeof(encrypt_Data[2]));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(encrypt_Data[2]);
    operation.params[2].memref.parent = &SharedMem3;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(encrypt_Data[2]);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    if(short_buffer == OUTPUT_BUFFER_TOO_SHORT && encrypt_decrypt == TEE_MODE_DECRYPT)
        operation.params[3].memref.size = 1;
    else
        operation.params[3].memref.size = sizeof(encrypt_Data[2]);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEDecryptFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)decrypt_Data[2], SharedMem2.buffer, 32);

    if(memcmp(DATA_FOR_CRYPTO1, decrypt_Data, sizeof(decrypt_Data))){
        TEEC_Error("decrypt data is not equal to encrypt\n");
        #if 1
        for(i=0; i<sizeof(DATA_FOR_CRYPTO1); i++){
            TEEC_Error("DATA_FOR_CRYPTO1[%d] = %x, decrypt_Data[%d] = %x\n",
                i, DATA_FOR_CRYPTO1[i], i, *((uint8_t *)decrypt_Data+i));
        }
        #endif
        result = TEEC_ERROR_MAC_INVALID;
    }
cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    if(SharedMem3.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem3);

cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context01);
cleanup_1:
    return result;
}

TEEC_Result Invoke_Crypto_AEDecryptFinal_invalid_mac_01(uint32_t tagLen, uint32_t mac_case,
            uint32_t algorithm, uint32_t short_buffer, uint32_t encrypt_decrypt, uint32_t AEupdate)
{
TEEC_Context context01;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    TEEC_SharedMemory SharedMem3;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_Data[3][32] = {0};
    uint8_t decrypt_Data[3][32] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context01);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
 //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context01,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context01,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));


    SharedMem3.buffer = NULL;
    SharedMem3.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    SharedMem3.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context01,
                &SharedMem3);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem3.buffer, 0, sizeof(DATA_FOR_CRYPTO1_PART1));
    //OpenSession
    result = TEEC_OpenSession(&context01, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

	    operation.started = 1;
    //Invoke_Crypto_InitObjectWithKeys
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    #if 0
    TEEC_Debug("%x, %x, %x\n", *(uint32_t *)SharedMem1.buffer, *(uint32_t *)(SharedMem1.buffer+4),
        *(uint32_t *)(SharedMem1.buffer+8));
    #endif
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
	 //+++++++++++++++++++++encrypt++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_AES_256 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)NONCE1_VALUE_AES_CCM, sizeof(NONCE1_VALUE_AES_CCM));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = tagLen/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(NONCE1_VALUE_AES_CCM);
    operation.params[2].value.a = AAD1_LENGTH;
    operation.params[2].value.b = LENGTH_DATA_FOR_CRYPTO1;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //Invoke_Crypto_AEUpdateAAD
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)AAD1_VALUE, sizeof(AAD1_VALUE));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(AAD1_VALUE);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdateAAD, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEUpdate_for_encryption
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    if(AEupdate == 1 && short_buffer == OUTPUT_BUFFER_TOO_SHORT)
        operation.params[3].memref.size = 1;
    else
        operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)encrypt_Data[0], SharedMem2.buffer, 32);
    #if 0
    for(i=0; i<32; i++){
        TEEC_Debug("encrypt_Data[0][%d] = %x\n", i, *((uint8_t *)SharedMem2.buffer+i));
    }
    #endif
    //Invoke_Crypto_AEUpdate_for_encryption
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    memcpy((void *)encrypt_Data[1], SharedMem2.buffer, 32);
    #if 0
    for(i=0; i<32; i++){
        TEEC_Debug("encrypt_Data[1][%d] = %x\n", i, encrypt_Data[1][i]);
    }
    #endif

    //Invoke_Crypto_AEEncryptFinal
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_OUTPUT,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[2].memref.parent = &SharedMem3;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    if(short_buffer == OUTPUT_BUFFER_TOO_SHORT && encrypt_decrypt == TEE_MODE_ENCRYPT)
        operation.params[3].memref.size = 1;
    else
        operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEEncryptFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)encrypt_Data[2], SharedMem2.buffer, 32);
    #if 0
    for(i=0; i<32; i++){
        TEEC_Debug("encrypt_Data[2][%d] = %x\n", i, encrypt_Data[2][i]);
    }
    #endif

    //++++++++++++++++++++++++decrypt+++++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_DECRYPT;
    operation.params[1].value.a = SIZE_AES_256 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)NONCE1_VALUE_AES_CCM, sizeof(NONCE1_VALUE_AES_CCM));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = tagLen/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(NONCE1_VALUE_AES_CCM);
    operation.params[2].value.a = AAD1_LENGTH;
    operation.params[2].value.b = LENGTH_DATA_FOR_CRYPTO1;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEUpdateAAD
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)AAD1_VALUE, sizeof(AAD1_VALUE));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(AAD1_VALUE);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdateAAD, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEUpdate_for_decryption
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)encrypt_Data[0], sizeof(encrypt_Data[0]));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(encrypt_Data[0]);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(encrypt_Data[0]);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    memcpy((void *)decrypt_Data[0], SharedMem2.buffer, 32);

    //Invoke_Crypto_AEUpdate_for_decryption
    memcpy(SharedMem1.buffer, (void *)encrypt_Data[1], sizeof(encrypt_Data[1]));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(encrypt_Data[1]);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(encrypt_Data[1]);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    memcpy((void *)decrypt_Data[1], SharedMem2.buffer, 32);

    //Invoke_Crypto_AEDecryptFinal
    mac_case = INVALID_MAC;
    if(mac_case == INVALID_MAC){
        *(char *)(SharedMem3.buffer) = 0xff;
    }
    memcpy(SharedMem1.buffer, (void *)encrypt_Data[2], sizeof(encrypt_Data[2]));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(encrypt_Data[2]);
    operation.params[2].memref.parent = &SharedMem3;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(encrypt_Data[2]);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    if(short_buffer == OUTPUT_BUFFER_TOO_SHORT && encrypt_decrypt == TEE_MODE_DECRYPT)
        operation.params[3].memref.size = 1;
    else
        operation.params[3].memref.size = sizeof(encrypt_Data[2]);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEDecryptFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)decrypt_Data[2], SharedMem2.buffer, 32);

    if(memcmp(DATA_FOR_CRYPTO1, decrypt_Data, sizeof(decrypt_Data))){
        TEEC_Error("decrypt data is not equal to encrypt\n");
        #if 1
        for(i=0; i<sizeof(DATA_FOR_CRYPTO1); i++){
            TEEC_Error("DATA_FOR_CRYPTO1[%d] = %x, decrypt_Data[%d] = %x\n",
                i, DATA_FOR_CRYPTO1[i], i, *((uint8_t *)decrypt_Data+i));
        }
        #endif
        result = TEEC_ERROR_MAC_INVALID;
    }
cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    if(SharedMem3.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem3);

cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context01);
cleanup_1:
    return result;
}

TEEC_Result Invoke_Crypto_AEDecryptFinal_invalid_operation_01(uint32_t tagLen, uint32_t mac_case,
            uint32_t algorithm, uint32_t short_buffer, uint32_t encrypt_decrypt, uint32_t AEupdate)
{
TEEC_Context context01;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    TEEC_SharedMemory SharedMem3;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_Data[3][32] = {0};
    uint8_t decrypt_Data[3][32] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context01);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
 //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context01,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context01,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));


    SharedMem3.buffer = NULL;
    SharedMem3.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    SharedMem3.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context01,
                &SharedMem3);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem3.buffer, 0, sizeof(DATA_FOR_CRYPTO1_PART1));
    //OpenSession
    result = TEEC_OpenSession(&context01, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

	    operation.started = 1;
    //Invoke_Crypto_InitObjectWithKeys
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    #if 0
    TEEC_Debug("%x, %x, %x\n", *(uint32_t *)SharedMem1.buffer, *(uint32_t *)(SharedMem1.buffer+4),
        *(uint32_t *)(SharedMem1.buffer+8));
    #endif
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error(" 1 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
	 //+++++++++++++++++++++encrypt++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_AES_256 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("2 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("3 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)NONCE1_VALUE_AES_CCM, sizeof(NONCE1_VALUE_AES_CCM));//
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = tagLen/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(NONCE1_VALUE_AES_CCM);//
    operation.params[2].value.a = AAD1_LENGTH;
    operation.params[2].value.b = LENGTH_DATA_FOR_CRYPTO1;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("4 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //Invoke_Crypto_AEUpdateAAD
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)AAD1_VALUE, sizeof(AAD1_VALUE));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(AAD1_VALUE);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdateAAD, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("5 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEUpdate_for_encryption
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    if(AEupdate == 1 && short_buffer == OUTPUT_BUFFER_TOO_SHORT)
        operation.params[3].memref.size = 1;
    else
        operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("6 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)encrypt_Data[0], SharedMem2.buffer, 32);
    #if 0
    for(i=0; i<32; i++){
        TEEC_Debug("encrypt_Data[0][%d] = %x\n", i, *((uint8_t *)SharedMem2.buffer+i));
    }
    #endif
    //Invoke_Crypto_AEUpdate_for_encryption
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("7 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    memcpy((void *)encrypt_Data[1], SharedMem2.buffer, 32);
    #if 0
    for(i=0; i<32; i++){
        TEEC_Debug("encrypt_Data[1][%d] = %x\n", i, encrypt_Data[1][i]);
    }
    #endif

    //Invoke_Crypto_AEEncryptFinal
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_OUTPUT,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[2].memref.parent = &SharedMem3;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    if(short_buffer == OUTPUT_BUFFER_TOO_SHORT && encrypt_decrypt == TEE_MODE_ENCRYPT)
        operation.params[3].memref.size = 1;
    else
        operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEEncryptFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("8 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)encrypt_Data[2], SharedMem2.buffer, 32);
    #if 0
    for(i=0; i<32; i++){
        TEEC_Debug("encrypt_Data[2][%d] = %x\n", i, encrypt_Data[2][i]);
    }
    #endif

    //++++++++++++++++++++++++decrypt+++++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_MD5;//algorithm;
    operation.params[0].value.b = TEE_MODE_DIGEST;//TEE_MODE_DECRYPT;
    operation.params[1].value.a = SIZE_ZERO + SIZE_ZERO;//SIZE_AES_256 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("9 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEDecryptFinal
   // mac_case = INVALID_MAC;
    if(mac_case == INVALID_MAC){
        *(char *)(SharedMem3.buffer) = 0xff;
    }
   // memcpy(SharedMem1.buffer, (void *)encrypt_Data[2], sizeof(encrypt_Data[2]));
 memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);

    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(encrypt_Data[2]);
    operation.params[2].memref.parent = &SharedMem3;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(encrypt_Data[2]);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    if(short_buffer == OUTPUT_BUFFER_TOO_SHORT && encrypt_decrypt == TEE_MODE_DECRYPT)
        operation.params[3].memref.size = 1;
    else
        operation.params[3].memref.size = sizeof(encrypt_Data[2]);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEDecryptFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("10 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)decrypt_Data[2], SharedMem2.buffer, 32);

    if(memcmp(DATA_FOR_CRYPTO1, decrypt_Data, sizeof(decrypt_Data))){
        TEEC_Error("decrypt data is not equal to encrypt\n");
        #if 1
        for(i=0; i<sizeof(DATA_FOR_CRYPTO1); i++){
            TEEC_Error("DATA_FOR_CRYPTO1[%d] = %x, decrypt_Data[%d] = %x\n",
                i, DATA_FOR_CRYPTO1[i], i, *((uint8_t *)decrypt_Data+i));
        }
        #endif
        result = TEE_ERROR_TARGET_DEAD;//TEEC_ERROR_MAC_INVALID;
    }
cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    if(SharedMem3.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem3);

cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context01);
cleanup_1:
    return result;
}

TEEC_Result Invoke_Crypto_AEDecryptFinal_invalid_value_handle_01(uint32_t tagLen, uint32_t mac_case,
            uint32_t algorithm, uint32_t short_buffer, uint32_t encrypt_decrypt, uint32_t AEupdate)
{
          TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    TEEC_SharedMemory SharedMem3;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_Data[3][32] = {0};
    uint8_t decrypt_Data[3][32] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
 //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));
    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));


    SharedMem3.buffer = NULL;
    SharedMem3.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    SharedMem3.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem3);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem3.buffer, 0, sizeof(DATA_FOR_CRYPTO1_PART1));
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AEDecryptFinal
    if(mac_case == INVALID_MAC){
        *(char *)(SharedMem3.buffer) = 0xff;
    }
    operation.started = 1;
    memcpy(SharedMem1.buffer, (void *)encrypt_Data[2], sizeof(encrypt_Data[2]));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a =OPERATION_HANDLE_INVALID;// OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(encrypt_Data[2]);
    operation.params[2].memref.parent = &SharedMem3;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(encrypt_Data[2]);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(encrypt_Data[2]);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEDecryptFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)decrypt_Data[2], SharedMem2.buffer, 32);

    if(memcmp(DATA_FOR_CRYPTO1, decrypt_Data, sizeof(decrypt_Data))){
        TEEC_Error("decrypt data is not equal to encrypt\n");
        #if 0
        for(i=0; i<sizeof(DATA_FOR_CRYPTO1); i++){
            TEEC_Error("DATA_FOR_CRYPTO1[%d] = %x, decrypt_Data[%d] = %x\n",
                i, DATA_FOR_CRYPTO1[i], i, *((uint8_t *)decrypt_Data+i));
        }
        #endif
        result = TEEC_ERROR_MAC_INVALID;
    }
cleanup_4:
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    if(SharedMem3.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem3);

cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;
}

TEEC_Result Invoke_Crypto_AEDecryptFinal_operation_not_started_01(uint32_t tagLen, uint32_t mac_case,
            uint32_t algorithm, uint32_t short_buffer, uint32_t encrypt_decrypt, uint32_t AEupdate)
{
          TEEC_Context context01;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    TEEC_SharedMemory SharedMem3;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_Data[3][32] = {0};
    uint8_t decrypt_Data[3][32] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context01);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
 //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context01,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context01,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));


    SharedMem3.buffer = NULL;
    SharedMem3.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    SharedMem3.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context01,
                &SharedMem3);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem3.buffer, 0, sizeof(DATA_FOR_CRYPTO1_PART1));
    //OpenSession
    result = TEEC_OpenSession(&context01, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

	    operation.started = 1;
    //Invoke_Crypto_InitObjectWithKeys
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    #if 0
    TEEC_Debug("%x, %x, %x\n", *(uint32_t *)SharedMem1.buffer, *(uint32_t *)(SharedMem1.buffer+4),
        *(uint32_t *)(SharedMem1.buffer+8));
    #endif
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
	 //+++++++++++++++++++++encrypt++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_AES_256 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)NONCE1_VALUE_AES_CCM, sizeof(NONCE1_VALUE_AES_CCM));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = tagLen/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(NONCE1_VALUE_AES_CCM);
    operation.params[2].value.a = AAD1_LENGTH;
    operation.params[2].value.b = LENGTH_DATA_FOR_CRYPTO1;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //Invoke_Crypto_AEUpdateAAD
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)AAD1_VALUE, sizeof(AAD1_VALUE));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(AAD1_VALUE);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdateAAD, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEUpdate_for_encryption
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    if(AEupdate == 1 && short_buffer == OUTPUT_BUFFER_TOO_SHORT)
        operation.params[3].memref.size = 1;
    else
        operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)encrypt_Data[0], SharedMem2.buffer, 32);
    #if 0
    for(i=0; i<32; i++){
        TEEC_Debug("encrypt_Data[0][%d] = %x\n", i, *((uint8_t *)SharedMem2.buffer+i));
    }
    #endif
    //Invoke_Crypto_AEUpdate_for_encryption
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    memcpy((void *)encrypt_Data[1], SharedMem2.buffer, 32);
    #if 0
    for(i=0; i<32; i++){
        TEEC_Debug("encrypt_Data[1][%d] = %x\n", i, encrypt_Data[1][i]);
    }
    #endif

    //Invoke_Crypto_AEEncryptFinal
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_OUTPUT,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[2].memref.parent = &SharedMem3;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    if(short_buffer == OUTPUT_BUFFER_TOO_SHORT && encrypt_decrypt == TEE_MODE_ENCRYPT)
        operation.params[3].memref.size = 1;
    else
        operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEEncryptFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)encrypt_Data[2], SharedMem2.buffer, 32);
    #if 0
    for(i=0; i<32; i++){
        TEEC_Debug("encrypt_Data[2][%d] = %x\n", i, encrypt_Data[2][i]);
    }
    #endif

    //++++++++++++++++++++++++decrypt+++++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_DECRYPT;
    operation.params[1].value.a = SIZE_AES_256 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEDecryptFinal
    //mac_case = INVALID_MAC;
    if(mac_case == INVALID_MAC){
        *(char *)(SharedMem3.buffer) = 0xff;
    }
    memcpy(SharedMem1.buffer, (void *)encrypt_Data[2], sizeof(encrypt_Data[2]));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(encrypt_Data[2]);
    operation.params[2].memref.parent = &SharedMem3;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(encrypt_Data[2]);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    if(short_buffer == OUTPUT_BUFFER_TOO_SHORT && encrypt_decrypt == TEE_MODE_DECRYPT)
        operation.params[3].memref.size = 1;
    else
        operation.params[3].memref.size = sizeof(encrypt_Data[2]);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEDecryptFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)decrypt_Data[2], SharedMem2.buffer, 32);

    if(memcmp(DATA_FOR_CRYPTO1, decrypt_Data, sizeof(decrypt_Data))){
        TEEC_Error("decrypt data is not equal to encrypt\n");
        #if 1
        for(i=0; i<sizeof(DATA_FOR_CRYPTO1); i++){
            TEEC_Error("DATA_FOR_CRYPTO1[%d] = %x, decrypt_Data[%d] = %x\n",
                i, DATA_FOR_CRYPTO1[i], i, *((uint8_t *)decrypt_Data+i));
        }
        #endif
        result = TEEC_ERROR_MAC_INVALID;
    }
cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    if(SharedMem3.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem3);

cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context01);
cleanup_1:
    return result;
}

TEEC_Result Invoke_Crypto_CipherDoFinal_TEE_ALG_AES_ECB_NOPAD_Success()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[3][32] = {0};
    uint8_t decrypt_result[3][32] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_AES_ECB_NOPAD;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //Invoke_Crypto_CipherInit
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 0;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_CipherUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[0], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART1));

    //Invoke_Crypto_CipherUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[1], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART2));

    //Invoke_Crypto_CipherDoFinal
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherDoFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[2], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART3));

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_CipherDoFinal_TEE_ALG_AES_CTS_Success()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[3][32] = {0};
    uint8_t decrypt_result[3][32] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_AES_CTS;//TEE_ALG_AES_ECB_NOPAD;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //Invoke_Crypto_CipherInit
    memset(SharedMem1.buffer, 0, sizeof(IV2_LENGTH_128bits_AES));//
    memcpy(SharedMem1.buffer, (void *)IV2_VALUE_128bits_AES, sizeof(IV2_LENGTH_128bits_AES));//
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(IV2_LENGTH_128bits_AES);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_CipherUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[0], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART1));

    //Invoke_Crypto_CipherUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[1], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART2));

    //Invoke_Crypto_CipherDoFinal
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherDoFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[2], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART3));

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_CipherDoFinal_TEE_ALG_AES_CTR_Success()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[3][32] = {0};
    uint8_t decrypt_result[3][32] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_AES_CTR;//TEE_ALG_AES_ECB_NOPAD;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //Invoke_Crypto_CipherInit
    memset(SharedMem1.buffer, 0, sizeof(IV2_LENGTH_128bits_AES));//
    memcpy(SharedMem1.buffer, (void *)IV2_VALUE_128bits_AES, sizeof(IV2_LENGTH_128bits_AES));//
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size =sizeof(IV2_LENGTH_128bits_AES);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_CipherUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[0], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART1));

    //Invoke_Crypto_CipherUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[1], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART2));

    //Invoke_Crypto_CipherDoFinal
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherDoFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[2], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART3));

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_CipherDoFinal_TEE_ALG_AES_CBC_NOPAD_Success()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[3][32] = {0};
    uint8_t decrypt_result[3][32] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("1 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_AES_CBC_NOPAD;//TEE_ALG_AES_ECB_NOPAD;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("2 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("3 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //Invoke_Crypto_CipherInit
    memset(SharedMem1.buffer, 0, sizeof(IV2_LENGTH_128bits_AES));//
    memcpy(SharedMem1.buffer, (void *)IV2_VALUE_128bits_AES, sizeof(IV2_LENGTH_128bits_AES));//
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(IV2_LENGTH_128bits_AES);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("4 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_CipherUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("5 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[0], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART1));

    //Invoke_Crypto_CipherUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("6 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[1], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART2));

    //Invoke_Crypto_CipherDoFinal
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherDoFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("7 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[2], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART3));

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("8 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("9 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_CipherDoFinal_TEE_ALG_AES_XTS_Success()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[3][32] = {0};
    uint8_t decrypt_result[3][32] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("1 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

	 //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("2 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_AES_XTS;//TEE_ALG_AES_ECB_NOPAD;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_AES_256/8;//SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("3 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_SetOperationKey2
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,//
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    operation.params[1].value.a = OBJECT_HANDLE_02;//
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey2, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("4 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //Invoke_Crypto_CipherInit
        memset(SharedMem1.buffer, 0, sizeof(IV2_LENGTH_128bits_AES));//
    memcpy(SharedMem1.buffer, (void *)IV2_VALUE_128bits_AES, sizeof(IV2_LENGTH_128bits_AES));//
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(IV2_LENGTH_128bits_AES);//
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("5 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_CipherUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("6 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[0], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART1));

    //Invoke_Crypto_CipherUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("7 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[1], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART2));

    //Invoke_Crypto_CipherDoFinal
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherDoFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("8 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[2], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART3));

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("9 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("10 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_CipherDoFinal_TEE_ALG_DES3_CBC_NOPAD_Success()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[3][32] = {0};
    uint8_t decrypt_result[3][32] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_DES3_192_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_DES3_192_VALUE01, sizeof(TEE_ATTR_DES3_192_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_DES3;//TEE_TYPE_AES;
    operation.params[0].value.b =SIZE_DES3_192/8;// SIZE_AES_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_DES3_192_VALUE01);//sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("1 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_DES3_CBC_NOPAD;//TEE_ALG_AES_ECB_NOPAD;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_DES3_192/8 + SIZE_ZERO;//
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("2 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("3 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //Invoke_Crypto_CipherInit
        memset(SharedMem1.buffer, 0, sizeof(IV1_VALUE_64bits_DES_DES3));//
    memcpy(SharedMem1.buffer, (void *)IV1_VALUE_64bits_DES_DES3, sizeof(IV1_VALUE_64bits_DES_DES3));//
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(IV1_VALUE_64bits_DES_DES3);//
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("4 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_CipherUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("5 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[0], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART1));

    //Invoke_Crypto_CipherUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("6 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[1], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART2));

    //Invoke_Crypto_CipherDoFinal
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherDoFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("7 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[2], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART3));

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("8 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("9 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_CipherDoFinal_TEE_ALG_DES3_ECB_NOPAD_Success()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[3][32] = {0};
    uint8_t decrypt_result[3][32] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_DES3_192_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_DES3_192_VALUE01, sizeof(TEE_ATTR_DES3_192_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_DES3;//TEE_TYPE_AES;
    operation.params[0].value.b =SIZE_DES3_192/8;// SIZE_AES_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_DES3_192_VALUE01);//sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("1 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_DES3_ECB_NOPAD;//TEE_ALG_AES_ECB_NOPAD;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_DES3_192/8 + SIZE_ZERO;//
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("2 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("3 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //Invoke_Crypto_CipherInit
    //    memset(SharedMem1.buffer, 0, sizeof(IV1_VALUE_64bits_DES_DES3));//
   // memcpy(SharedMem1.buffer, (void *)IV1_VALUE_64bits_DES_DES3, sizeof(IV1_VALUE_64bits_DES_DES3));//
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 0;//sizeof(IV1_VALUE_64bits_DES_DES3);//
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("4 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_CipherUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("5 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[0], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART1));

    //Invoke_Crypto_CipherUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("6 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[1], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART2));

    //Invoke_Crypto_CipherDoFinal
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherDoFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("7 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[2], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART3));

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("8 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("9 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_CipherDoFinal_TEE_ALG_DES_CBC_NOPAD_Success()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[3][32] = {0};
    uint8_t decrypt_result[3][32] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_DES_64_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_DES_64_VALUE01, sizeof(TEE_ATTR_DES_64_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_DES;//TEE_TYPE_AES;
    operation.params[0].value.b =SIZE_DES_64/8;// SIZE_AES_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_DES_64_VALUE01);//sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("1 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_DES_CBC_NOPAD;//TEE_ALG_AES_ECB_NOPAD;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_DES_64/8 + SIZE_ZERO;//
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("2 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("3 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //Invoke_Crypto_CipherInit
        memset(SharedMem1.buffer, 0, sizeof(IV1_VALUE_64bits_DES_DES3));//
    memcpy(SharedMem1.buffer, (void *)IV1_VALUE_64bits_DES_DES3, sizeof(IV1_VALUE_64bits_DES_DES3));//
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(IV1_VALUE_64bits_DES_DES3);//
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("4 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_CipherUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("5 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[0], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART1));

    //Invoke_Crypto_CipherUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("6 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[1], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART2));

    //Invoke_Crypto_CipherDoFinal
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherDoFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("7 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[2], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART3));

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("8 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("9 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_CipherDoFinal_TEE_ALG_DES_ECB_NOPAD_Success()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[3][32] = {0};
    uint8_t decrypt_result[3][32] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_DES_64_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_DES_64_VALUE01, sizeof(TEE_ATTR_DES_64_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_DES;//TEE_TYPE_AES;
    operation.params[0].value.b =SIZE_DES_64/8;// SIZE_AES_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_DES_64_VALUE01);//sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("1 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_DES_ECB_NOPAD;//TEE_ALG_AES_ECB_NOPAD;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_DES_64/8 + SIZE_ZERO;//
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("2 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("3 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //Invoke_Crypto_CipherInit
     //   memset(SharedMem1.buffer, 0, sizeof(IV1_VALUE_64bits_DES_DES3));//
    //memcpy(SharedMem1.buffer, (void *)IV1_VALUE_64bits_DES_DES3, sizeof(IV1_VALUE_64bits_DES_DES3));//
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 0;//sizeof(IV1_VALUE_64bits_DES_DES3);//
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("4 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_CipherUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("5 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[0], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART1));

    //Invoke_Crypto_CipherUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("6 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[1], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART2));

    //Invoke_Crypto_CipherDoFinal
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherDoFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("7 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[2], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART3));

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("8 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("9 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

static uint8_t random1[BIG_SIZE] = {0};
static uint8_t random2[BIG_SIZE] = {0};

TEEC_Result Invoke_Crypto_GenerateRandom()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;

    //InitializeContext
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_GenerateRandom
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[3].memref.parent = &SharedMem1;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = BIG_SIZE;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_GenerateRandom, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    memcpy(random1, SharedMem1.buffer, BIG_SIZE);

    //Invoke_Crypto_GenerateRandom
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[3].memref.parent = &SharedMem1;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = BIG_SIZE;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_GenerateRandom, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    memcpy(random2, SharedMem1.buffer, BIG_SIZE);

    if(!memcmp(random1, random2, BIG_SIZE)){
        TEEC_Error("random1 == random2\n");
        result = TEEC_ERROR_GENERIC;
    }
cleanup_4:
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_CipherDoFinal_invalid_operation_class()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[3][32] = {0};
    uint8_t decrypt_result[3][32] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_DES_64_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_DES_64_VALUE01, sizeof(TEE_ATTR_DES_64_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_SHA224;//TEE_ALG_AES_ECB_NOPAD;
    operation.params[0].value.b = TEE_MODE_DIGEST;//TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_ZERO + SIZE_ZERO;//
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("2 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_CipherDoFinal
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherDoFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test 7 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[2], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART1));

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_CipherDoFinal_invalid_value_handle()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[3][32] = {0};
    uint8_t decrypt_result[3][32] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_DES_64_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_DES_64_VALUE01, sizeof(TEE_ATTR_DES_64_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }

    //Invoke_Crypto_CipherDoFinal
    operation.started = 1;
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_INVALID;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherDoFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test 7 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[2], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART2));

cleanup_4:
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_CipherDoFinal_operation_already_finalized()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[3][32] = {0};
    uint8_t decrypt_result[3][32] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_DES_64_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_DES_64_VALUE01, sizeof(TEE_ATTR_DES_64_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_DES;//TEE_TYPE_AES;
    operation.params[0].value.b =SIZE_DES_64/8;// SIZE_AES_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_DES_64_VALUE01);//sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("1 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_DES_CBC_NOPAD;//TEE_ALG_AES_ECB_NOPAD;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_DES_64/8 + SIZE_ZERO;//
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("2 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("3 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //Invoke_Crypto_CipherInit
        memset(SharedMem1.buffer, 0, sizeof(IV1_VALUE_64bits_DES_DES3));//
    memcpy(SharedMem1.buffer, (void *)IV1_VALUE_64bits_DES_DES3, sizeof(IV1_VALUE_64bits_DES_DES3));//
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(IV1_VALUE_64bits_DES_DES3);//
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("4 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_CipherUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("5 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[0], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART1));

    //Invoke_Crypto_CipherUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("6 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[1], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART2));

    //Invoke_Crypto_CipherDoFinal
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherDoFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("7 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[2], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART3));

	 //Invoke_Crypto_CipherDoFinal
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherDoFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("8 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[2], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART3));

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("9 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("10 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_CipherDoFinal_operation_not_started()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[3][32] = {0};
    uint8_t decrypt_result[3][32] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_DES_64_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_DES_64_VALUE01, sizeof(TEE_ATTR_DES_64_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;//TEE_TYPE_AES;
    operation.params[0].value.b =SIZE_AES_256/8;// SIZE_AES_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);//sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("1 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_AES_ECB_NOPAD;//TEE_ALG_AES_ECB_NOPAD;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;//
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("2 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_CipherDoFinal
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherDoFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test 7 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[2], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART1));

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}


TEEC_Result Invoke_Crypto_CipherDoFinal_short_buffer()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[3][32] = {0};
    uint8_t decrypt_result[3][32] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;//TEE_TYPE_AES;
    operation.params[0].value.b =SIZE_AES_256/8;// SIZE_AES_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);//sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("1 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_AES_ECB_NOPAD;//TEE_ALG_AES_ECB_NOPAD;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;//
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("2 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("3 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //Invoke_Crypto_CipherInit
     //   memset(SharedMem1.buffer, 0, sizeof(IV1_VALUE_64bits_DES_DES3));//
   // memcpy(SharedMem1.buffer, (void *)IV1_VALUE_64bits_DES_DES3, sizeof(IV1_VALUE_64bits_DES_DES3));//
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 0;//
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("4 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_CipherUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test 5 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[0], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART1));

    //Invoke_Crypto_CipherUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("6 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[1], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART2));

    //Invoke_Crypto_CipherDoFinal
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = 1;//
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherDoFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("7 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[2], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART3));

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_CipherInit_invalid_operation_class()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[3][32] = {0};
    uint8_t decrypt_result[3][32] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_DES_64_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_DES_64_VALUE01, sizeof(TEE_ATTR_DES_64_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }

    operation.started = 1;
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_MD5;//TEE_ALG_AES_ECB_NOPAD;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_ZERO+ SIZE_ZERO;//
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test 2 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //Invoke_Crypto_CipherInit
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 0;//
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("4 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_CipherInit_invalid_value_handle()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[3][32] = {0};
    uint8_t decrypt_result[3][32] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_DES_64_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_DES_64_VALUE01, sizeof(TEE_ATTR_DES_64_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }

    //Invoke_Crypto_CipherInit
   //     memset(SharedMem1.buffer, 0, sizeof(IV1_VALUE_64bits_DES_DES3));//
   // memcpy(SharedMem1.buffer, (void *)IV1_VALUE_64bits_DES_DES3, sizeof(IV1_VALUE_64bits_DES_DES3));//
   operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_INVALID;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 0;//
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test 4 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

cleanup_4:
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_CipherInit_length_too_short()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[3][32] = {0};
    uint8_t decrypt_result[3][32] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_DES_64_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;//TEE_TYPE_AES;
    operation.params[0].value.b =SIZE_AES_256/8;// SIZE_AES_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);//sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("1 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_AES_CBC_NOPAD;//TEE_ALG_AES_ECB_NOPAD;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;//
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("2 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("3 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //Invoke_Crypto_CipherInit
        memset(SharedMem1.buffer, 0, sizeof(IV1_VALUE_64bits_DES_DES3));//
    memcpy(SharedMem1.buffer, (void *)IV1_VALUE_64bits_DES_DES3, sizeof(IV1_VALUE_64bits_DES_DES3));//
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(IV1_VALUE_64bits_DES_DES3);//
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherInit, &operation, &origin);
    if (result != TEE_ERROR_TARGET_DEAD) { //
        TEEC_Error("exception test 4 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("8 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("9 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}
TEEC_Result Invoke_Crypto_CipherInit_no_key_programmed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[3][32] = {0};
    uint8_t decrypt_result[3][32] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_DES_64_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_DES_64_VALUE01, sizeof(TEE_ATTR_DES_64_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_DES3;//TEE_TYPE_AES;
    operation.params[0].value.b =SIZE_DES3_192/8;// SIZE_AES_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_DES3_192_VALUE01);//sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("1 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_DES3_CBC_NOPAD;//TEE_ALG_AES_ECB_NOPAD;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_DES3_192/8 + SIZE_ZERO;//
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("2 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }


    //Invoke_Crypto_CipherInit
  //      memset(SharedMem1.buffer, 0, sizeof(IV1_VALUE_64bits_DES_DES3));//
   // memcpy(SharedMem1.buffer, (void *)IV1_VALUE_64bits_DES_DES3, sizeof(IV1_VALUE_64bits_DES_DES3));//
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 0;//
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("4 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("8 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("9 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_CipherInit_operation_active_already_initialized_Success()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[3][32] = {0};
    uint8_t decrypt_result[3][32] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;//TEE_TYPE_AES;
    operation.params[0].value.b =SIZE_AES_256/8;// SIZE_AES_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);//sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("1 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_AES_ECB_NOPAD;//TEE_ALG_AES_ECB_NOPAD;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;//
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("2 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("3 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //Invoke_Crypto_CipherInit
    //    memset(SharedMem1.buffer, 0, sizeof(IV1_VALUE_64bits_DES_DES3));//
   // memcpy(SharedMem1.buffer, (void *)IV1_VALUE_64bits_DES_DES3, sizeof(IV1_VALUE_64bits_DES_DES3));//
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 0;//
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("4 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_CipherUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("5 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[0], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART1));

	//Invoke_Crypto_CipherInit
      //  memset(SharedMem1.buffer, 0, sizeof(IV1_VALUE_64bits_DES_DES3));//
   // memcpy(SharedMem1.buffer, (void *)IV1_VALUE_64bits_DES_DES3, sizeof(IV1_VALUE_64bits_DES_DES3));//
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 0;//
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("4 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_CipherUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("5 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[0], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART1));


    //Invoke_Crypto_CipherUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("6 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[1], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART2));

    //Invoke_Crypto_CipherDoFinal
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherDoFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("7 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[2], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART3));

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("8 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("9 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_CipherInit_operation_not_active_Success()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[3][32] = {0};
    uint8_t decrypt_result[3][32] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;//TEE_TYPE_AES;
    operation.params[0].value.b =SIZE_AES_256/8;// SIZE_AES_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);//sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("1 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_AES_CBC_NOPAD;//TEE_ALG_AES_ECB_NOPAD;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;//
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("2 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("3 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //Invoke_Crypto_CipherInit
        memset(SharedMem1.buffer, 0, sizeof(IV2_VALUE_128bits_AES));//
    memcpy(SharedMem1.buffer, (void *)IV2_VALUE_128bits_AES, sizeof(IV2_VALUE_128bits_AES));//
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(IV2_VALUE_128bits_AES);//
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("4 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
	    //Invoke_Crypto_CipherInit
        memset(SharedMem1.buffer, 0, sizeof(IV2_VALUE_128bits_AES));//
    memcpy(SharedMem1.buffer, (void *)IV2_VALUE_128bits_AES, sizeof(IV2_VALUE_128bits_AES));//
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(IV2_VALUE_128bits_AES);//
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("4 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_CipherUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("5 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[0], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART1));

    //Invoke_Crypto_CipherUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("6 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[1], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART2));

    //Invoke_Crypto_CipherDoFinal
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherDoFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("7 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[2], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART3));

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("8 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("9 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_CipherUpdate_invalid_operation_class()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[3][32] = {0};
    uint8_t decrypt_result[3][32] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_DES_64_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_DES_64_VALUE01, sizeof(TEE_ATTR_DES_64_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_MD5;//TEE_ALG_AES_ECB_NOPAD;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_ZERO + SIZE_ZERO;//
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test 2 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_CipherUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("5 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[0], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART1));

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_CipherUpdate_invalid_value_handle()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[3][32] = {0};
    uint8_t decrypt_result[3][32] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_DES_64_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_DES_64_VALUE01, sizeof(TEE_ATTR_DES_64_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }

    //Invoke_Crypto_CipherUpdate
    operation.started = 1;
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_INVALID;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test 6 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[1], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART2));

cleanup_4:
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_CipherUpdate_operation_already_finalized()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[3][32] = {0};
    uint8_t decrypt_result[3][32] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_DES3_192_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_DES3_192_VALUE01, sizeof(TEE_ATTR_DES3_192_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_DES3;//TEE_TYPE_AES;
    operation.params[0].value.b =SIZE_DES3_192/8;// SIZE_AES_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_DES3_192_VALUE01);//sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("1 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_DES3_CBC_NOPAD;//TEE_ALG_AES_ECB_NOPAD;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_DES3_192/8 + SIZE_ZERO;//
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("2 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("3 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //Invoke_Crypto_CipherInit
        memset(SharedMem1.buffer, 0, sizeof(IV1_VALUE_64bits_DES_DES3));//
    memcpy(SharedMem1.buffer, (void *)IV1_VALUE_64bits_DES_DES3, sizeof(IV1_VALUE_64bits_DES_DES3));//
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(IV1_VALUE_64bits_DES_DES3);//
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("4 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_CipherUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("5 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[0], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART1));

    //Invoke_Crypto_CipherUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("6 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[1], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART2));

    //Invoke_Crypto_CipherDoFinal
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherDoFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("7 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[2], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART3));

	 //Invoke_Crypto_CipherUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("5 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[0], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART1));

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_CipherUpdate_operation_not_started()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[3][32] = {0};
    uint8_t decrypt_result[3][32] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_DES3_192_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_DES3_192_VALUE01, sizeof(TEE_ATTR_DES3_192_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_DES3;//TEE_TYPE_AES;
    operation.params[0].value.b =SIZE_DES3_192/8;// SIZE_AES_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_DES3_192_VALUE01);//sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test 1 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_DES3_CBC_NOPAD;//TEE_ALG_AES_ECB_NOPAD;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_DES3_192/8 + SIZE_ZERO;//
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("2 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_CipherUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("5 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[0], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART1));

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_CipherUpdate_short_buffer()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[3][32] = {0};
    uint8_t decrypt_result[3][32] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;//TEE_TYPE_AES;
    operation.params[0].value.b =SIZE_AES_256/8;// SIZE_AES_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);//sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("1 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_AES_ECB_NOPAD;//TEE_ALG_AES_ECB_NOPAD;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;//
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("2 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("3 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //Invoke_Crypto_CipherInit
     //   memset(SharedMem1.buffer, 0, sizeof(IV1_VALUE_64bits_DES_DES3));//
   // memcpy(SharedMem1.buffer, (void *)IV1_VALUE_64bits_DES_DES3, sizeof(IV1_VALUE_64bits_DES_DES3));//
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 0;//
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("4 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_CipherUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = 1;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test  invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[0], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART1));

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}


TEEC_Result Invoke_Crypto_MACComputeFinal_TEE_ALG_AES_CBC_MAC_NOPAD_Success()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_MAC;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_MACInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 16;//for test
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_MACUpdate
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_MACUpdate
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_MACComputeFinal
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(AES_MAC_result);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACComputeFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)AES_MAC_result, SharedMem2.buffer, sizeof(AES_MAC_result));

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_MACComputeFinal_TEE_ALG_AES_CMAC_Success()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_AES_CMAC;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_MAC;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_MACInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 16;//for test
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_MACUpdate
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_MACUpdate
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_MACComputeFinal
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(AES_MAC_result);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACComputeFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)AES_MAC_result, SharedMem2.buffer, sizeof(AES_MAC_result));

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}


TEEC_Result Invoke_Crypto_MACComputeFinal_TEE_ALG_HMAC_SHA1_Success()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_HMAC_SHA1_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_HMAC_SHA1_256_VALUE01, sizeof(TEE_ATTR_HMAC_SHA1_256_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_HMAC_SHA1;
    operation.params[0].value.b = SIZE_HMAC_SHA1_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_HMAC_SHA1_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_HMAC_SHA1;
    operation.params[0].value.b = TEE_MODE_MAC;
    operation.params[1].value.a = SIZE_HMAC_SHA1_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_MACInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, IV2_VALUE_128bits_AES, sizeof(IV2_VALUE_128bits_AES));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(IV2_VALUE_128bits_AES);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_MACUpdate
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    memcpy(SharedMem1.buffer+sizeof(DATA_FOR_CRYPTO1_PART1), (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1)+sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    #if 0
    //Invoke_Crypto_MACUpdate
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    #endif
    //Invoke_Crypto_MACCompareFinal
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_INPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(HMAC_result);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACComputeFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)HMAC_result, SharedMem2.buffer, sizeof(HMAC_result));

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;
}

TEEC_Result Invoke_Crypto_MACCompareFinal_TEE_ALG_AES_CBC_MAC_NOPAD_Success()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("1 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_MAC;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("2 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("3 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_MACInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 16;//for test
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("4 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_MACUpdate
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("5 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_MACUpdate
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("6 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_MACCompareFinal
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    memcpy(SharedMem2.buffer, (void *)AES_MAC_result, 16);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(AES_MAC_result);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACCompareFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("7 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("8 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("9 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_MACCompareFinal_TEE_ALG_AES_CMAC_Success()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("1 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_AES_CMAC;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_MAC;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("2 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("3 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_MACInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 16;//for test
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("4 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_MACUpdate
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("5 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_MACUpdate
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("6 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_MACCompareFinal
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    memcpy(SharedMem2.buffer, (void *)AES_MAC_result, 16);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(AES_MAC_result);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACCompareFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("7 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("8 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("9 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_MACCompareFinal_TEE_ALG_HMAC_SHA1_Success()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_HMAC_SHA1_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_HMAC_SHA1_256_VALUE01, sizeof(TEE_ATTR_HMAC_SHA1_256_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_HMAC_SHA1;
    operation.params[0].value.b = SIZE_HMAC_SHA1_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_HMAC_SHA1_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_HMAC_SHA1;
    operation.params[0].value.b = TEE_MODE_MAC;
    operation.params[1].value.a = SIZE_HMAC_SHA1_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_MACInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, IV2_VALUE_128bits_AES, sizeof(IV2_VALUE_128bits_AES));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(IV2_VALUE_128bits_AES);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_MACUpdate
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    memcpy(SharedMem1.buffer+sizeof(DATA_FOR_CRYPTO1_PART1), (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1)+sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    #if 0
    //Invoke_Crypto_MACUpdate
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    #endif
    //Invoke_Crypto_MACCompareFinal
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    memcpy(SharedMem2.buffer, (void *)HMAC_result, sizeof(HMAC_result));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = 20;//SHA1 result size
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACCompareFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_MACComputeFinal_TEE_ALG_HMAC_SHA224_Success()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_HMAC_SHA224_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_HMAC_SHA224_256_VALUE01, sizeof(TEE_ATTR_HMAC_SHA224_256_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_HMAC_SHA224;
    operation.params[0].value.b = SIZE_HMAC_SHA224_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_HMAC_SHA224_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_HMAC_SHA224;
    operation.params[0].value.b = TEE_MODE_MAC;
    operation.params[1].value.a = SIZE_HMAC_SHA224_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_MACInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, IV2_VALUE_128bits_AES, sizeof(IV2_VALUE_128bits_AES));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(IV2_VALUE_128bits_AES);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_MACUpdate
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    memcpy(SharedMem1.buffer+sizeof(DATA_FOR_CRYPTO1_PART1), (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1)+sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    #if 0
    //Invoke_Crypto_MACUpdate
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    #endif
    //Invoke_Crypto_MACCompareFinal
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_INPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(HMAC_result);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACComputeFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)HMAC_result, SharedMem2.buffer, sizeof(HMAC_result));

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;
}

TEEC_Result Invoke_Crypto_MACComputeFinal_TEE_ALG_HMAC_SHA256_Success()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_HMAC_SHA256_512_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_HMAC_SHA256_512_VALUE01, sizeof(TEE_ATTR_HMAC_SHA256_512_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_HMAC_SHA256;
    operation.params[0].value.b = SIZE_HMAC_SHA256_512/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_HMAC_SHA256_512_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_HMAC_SHA256;
    operation.params[0].value.b = TEE_MODE_MAC;
    operation.params[1].value.a = SIZE_HMAC_SHA256_512/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_MACInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, IV2_VALUE_128bits_AES, sizeof(IV2_VALUE_128bits_AES));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(IV2_VALUE_128bits_AES);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_MACUpdate
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    memcpy(SharedMem1.buffer+sizeof(DATA_FOR_CRYPTO1_PART1), (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1)+sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
#if 0
	    //Invoke_Crypto_MACUpdate
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    memcpy(SharedMem1.buffer+sizeof(DATA_FOR_CRYPTO1_PART1), (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1)+sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
#endif
    #if 0
    //Invoke_Crypto_MACUpdate
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    #endif
    //Invoke_Crypto_MACCompareFinal
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_INPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(HMAC_result);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACComputeFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)HMAC_result, SharedMem2.buffer, sizeof(HMAC_result));

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;
}

TEEC_Result Invoke_Crypto_MACComputeFinal_TEE_ALG_HMAC_SHA384_Success()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_HMAC_SHA384_512_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_HMAC_SHA384_512_VALUE01, sizeof(TEE_ATTR_HMAC_SHA384_512_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_HMAC_SHA384;
    operation.params[0].value.b = SIZE_HMAC_SHA384_512/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_HMAC_SHA384_512_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("1 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_HMAC_SHA384;
    operation.params[0].value.b = TEE_MODE_MAC;
    operation.params[1].value.a = SIZE_HMAC_SHA384_512/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("2 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("3 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_MACInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, IV2_VALUE_128bits_AES, sizeof(IV2_VALUE_128bits_AES));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(IV2_VALUE_128bits_AES);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error(" 4 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //Invoke_Crypto_MACCompareFinal
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1, sizeof(DATA_FOR_CRYPTO1));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_INPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(HMAC_result);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACComputeFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("7 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)HMAC_result, SharedMem2.buffer, sizeof(HMAC_result));

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("8 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;
}

TEEC_Result Invoke_Crypto_MACComputeFinal_TEE_ALG_HMAC_SHA512_Success()
{
    TEEC_Context context02;
    TEEC_Session session02;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_HMAC_SHA512_512_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_HMAC_SHA512_512_VALUE01, sizeof(TEE_ATTR_HMAC_SHA512_512_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session02, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_HMAC_SHA512;
    operation.params[0].value.b = SIZE_HMAC_SHA512_512/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_HMAC_SHA512_512_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session02, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("1 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_HMAC_SHA512;
    operation.params[0].value.b = TEE_MODE_MAC;
    operation.params[1].value.a = SIZE_HMAC_SHA512_512/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session02, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("2 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session02, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("3 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_MACInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, IV2_VALUE_128bits_AES, sizeof(IV2_VALUE_128bits_AES));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(IV2_VALUE_128bits_AES);
    result = TEEC_InvokeCommand(&session02, CMD_Crypto_MACInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error(" 4 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
#if 0
    //Invoke_Crypto_MACUpdate
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    memcpy(SharedMem1.buffer+sizeof(DATA_FOR_CRYPTO1_PART1), (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1)+sizeof(DATA_FOR_CRYPTO1_PART1);
    result = TEEC_InvokeCommand(&session02, CMD_Crypto_MACUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("5 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
#endif
/*	    //Invoke_Crypto_MACUpdate
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    memcpy(SharedMem1.buffer+sizeof(DATA_FOR_CRYPTO1_PART2), (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2)+sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("6 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
*/
    //Invoke_Crypto_MACCompareFinal
	//blocksize is 128byte in sha384 and sha512
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1, sizeof(DATA_FOR_CRYPTO1));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_INPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(HMAC_result);
    result = TEEC_InvokeCommand(&session02, CMD_Crypto_MACComputeFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("7 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)HMAC_result, SharedMem2.buffer, sizeof(HMAC_result));

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session02, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("8 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session02, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    //CloseSession
    TEEC_CloseSession(&session02);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;
}

TEEC_Result Invoke_Crypto_MACCompareFinal_TEE_ALG_HMAC_SHA224_Success()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_HMAC_SHA224_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_HMAC_SHA224_256_VALUE01, sizeof(TEE_ATTR_HMAC_SHA224_256_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_HMAC_SHA224;
    operation.params[0].value.b = SIZE_HMAC_SHA224_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_HMAC_SHA224_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_HMAC_SHA224;
    operation.params[0].value.b = TEE_MODE_MAC;
    operation.params[1].value.a = SIZE_HMAC_SHA224_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_MACInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, IV2_VALUE_128bits_AES, sizeof(IV2_VALUE_128bits_AES));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(IV2_VALUE_128bits_AES);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_MACUpdate
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    memcpy(SharedMem1.buffer+sizeof(DATA_FOR_CRYPTO1_PART1), (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1)+sizeof(DATA_FOR_CRYPTO1_PART1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
	/*    //Invoke_Crypto_MACUpdate
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    memcpy(SharedMem1.buffer+sizeof(DATA_FOR_CRYPTO1_PART2), (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2)+sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }*/
    #if 0
    //Invoke_Crypto_MACUpdate
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    #endif
    //Invoke_Crypto_MACCompareFinal
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    memcpy(SharedMem2.buffer, (void *)HMAC_result, sizeof(HMAC_result));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = 28;//SHA1 result size
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACCompareFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_MACCompareFinal_TEE_ALG_HMAC_SHA256_Success()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_HMAC_SHA256_512_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_HMAC_SHA256_512_VALUE01, sizeof(TEE_ATTR_HMAC_SHA256_512_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_HMAC_SHA256;
    operation.params[0].value.b = SIZE_HMAC_SHA256_512/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_HMAC_SHA256_512_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_HMAC_SHA256;
    operation.params[0].value.b = TEE_MODE_MAC;
    operation.params[1].value.a = SIZE_HMAC_SHA256_512/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_MACInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, IV2_VALUE_128bits_AES, sizeof(IV2_VALUE_128bits_AES));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(IV2_VALUE_128bits_AES);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_MACUpdate
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    memcpy(SharedMem1.buffer+sizeof(DATA_FOR_CRYPTO1_PART1), (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1)+sizeof(DATA_FOR_CRYPTO1_PART1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    #if 0
    //Invoke_Crypto_MACUpdate
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    #endif
    //Invoke_Crypto_MACCompareFinal
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    memcpy(SharedMem2.buffer, (void *)HMAC_result, sizeof(HMAC_result));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = 32;//SHA1 result size
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACCompareFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_MACCompareFinal_TEE_ALG_HMAC_SHA384_Success()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_HMAC_SHA384_512_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_HMAC_SHA384_512_VALUE01, sizeof(TEE_ATTR_HMAC_SHA384_512_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_HMAC_SHA384;
    operation.params[0].value.b = SIZE_HMAC_SHA384_512/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_HMAC_SHA384_512_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_HMAC_SHA384;
    operation.params[0].value.b = TEE_MODE_MAC;
    operation.params[1].value.a = SIZE_HMAC_SHA384_512/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_MACInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, IV2_VALUE_128bits_AES, sizeof(IV2_VALUE_128bits_AES));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(IV2_VALUE_128bits_AES);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //Invoke_Crypto_MACCompareFinal
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1, sizeof(DATA_FOR_CRYPTO1));
    memcpy(SharedMem2.buffer, (void *)HMAC_result, sizeof(HMAC_result));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1);
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = 48;//SHA1 result size
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACCompareFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_MACCompareFinal_TEE_ALG_HMAC_SHA512_Success ()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_HMAC_SHA512_512_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_HMAC_SHA512_512_VALUE01, sizeof(TEE_ATTR_HMAC_SHA512_512_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_HMAC_SHA512;
    operation.params[0].value.b = SIZE_HMAC_SHA512_512/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_HMAC_SHA512_512_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_HMAC_SHA512;
    operation.params[0].value.b = TEE_MODE_MAC;
    operation.params[1].value.a = SIZE_HMAC_SHA512_512/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_MACInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, IV2_VALUE_128bits_AES, sizeof(IV2_VALUE_128bits_AES));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(IV2_VALUE_128bits_AES);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
#if 0
    //Invoke_Crypto_MACUpdate
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    memcpy(SharedMem1.buffer+sizeof(DATA_FOR_CRYPTO1_PART1), (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1)+sizeof(DATA_FOR_CRYPTO1_PART1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
#endif

    #if 0
    //Invoke_Crypto_MACUpdate
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    #endif
    //Invoke_Crypto_MACCompareFinal
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1, sizeof(DATA_FOR_CRYPTO1));
    memcpy(SharedMem2.buffer, (void *)HMAC_result, sizeof(HMAC_result));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1);
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = 64;//SHA1 result size
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACCompareFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_MACCompareFinal_invalid_mac ()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_HMAC_SHA512_512_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_HMAC_SHA512_512_VALUE01, sizeof(TEE_ATTR_HMAC_SHA512_512_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_HMAC_SHA512;
    operation.params[0].value.b = SIZE_HMAC_SHA512_512/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_HMAC_SHA512_512_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_HMAC_SHA512;
    operation.params[0].value.b = TEE_MODE_MAC;
    operation.params[1].value.a = SIZE_HMAC_SHA512_512/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_MACInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, IV2_VALUE_128bits_AES, sizeof(IV2_VALUE_128bits_AES));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(IV2_VALUE_128bits_AES);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //Invoke_Crypto_MACCompareFinal
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1, sizeof(DATA_FOR_CRYPTO1));
    memcpy(SharedMem2.buffer, (void *)HMAC_result, sizeof(HMAC_result));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1);
    operation.params[2].memref.parent = &SharedMem1;//
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = 64;//SHA1 result size
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACCompareFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_MACCompareFinal_invalid_operation_class ()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_HMAC_SHA512_512_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_HMAC_SHA512_512_VALUE01, sizeof(TEE_ATTR_HMAC_SHA512_512_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_HMAC_SHA512;
    operation.params[0].value.b = TEE_MODE_MAC;
    operation.params[1].value.a = SIZE_HMAC_SHA512_512/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }

    //Invoke_Crypto_MACCompareFinal
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1, sizeof(DATA_FOR_CRYPTO1));
    memcpy(SharedMem2.buffer, (void *)HMAC_result, sizeof(HMAC_result));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1);
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = 64;//SHA1 result size
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACCompareFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_MACCompareFinal_invalid_value_handle ()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_HMAC_SHA512_512_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_HMAC_SHA512_512_VALUE01, sizeof(TEE_ATTR_HMAC_SHA512_512_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_MACCompareFinal
    operation.started = 1;
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1, sizeof(DATA_FOR_CRYPTO1));
    memcpy(SharedMem2.buffer, (void *)HMAC_result, sizeof(HMAC_result));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1);
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = 64;//SHA1 result size
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACCompareFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_MACCompareFinal_operation_already_finalized ()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t temp[]={
        0xcb, 0x8b, 0xd6, 0x4, 0xab, 0x48, 0x88, 0xea, 0xdd, 0x26, 0x17, 0x6e, 0xc2, 0x1c, 0x47, 0xc4,
        0xa5, 0x3, 0xe9, 0x30, 0x11, 0x23, 0x44, 0x2, 0x26, 0x80, 0x7f, 0xdc, 0x7e, 0xd6, 0x3e, 0xf4,
        0x83, 0xfd, 0x6c, 0xfc, 0xf3, 0x85, 0x2e, 0x7b, 0xa1, 0x21, 0x22, 0x24, 0x61, 0xb7, 0x56, 0x70,
        0xe, 0x98, 0xb5, 0x41, 0xa1, 0xbd, 0x41, 0xf, 0x5, 0xb3, 0xf3, 0x99, 0xd9, 0x1d, 0x23, 0xc5};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_HMAC_SHA512_512_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_HMAC_SHA512_512_VALUE01, sizeof(TEE_ATTR_HMAC_SHA512_512_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_HMAC_SHA512;
    operation.params[0].value.b = SIZE_HMAC_SHA512_512/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_HMAC_SHA512_512_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_HMAC_SHA512;
    operation.params[0].value.b = TEE_MODE_MAC;
    operation.params[1].value.a = SIZE_HMAC_SHA512_512/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_MACInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, IV2_VALUE_128bits_AES, sizeof(IV2_VALUE_128bits_AES));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(IV2_VALUE_128bits_AES);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //Invoke_Crypto_MACCompareFinal
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1, sizeof(DATA_FOR_CRYPTO1));
    memcpy(SharedMem2.buffer, (void *)temp, sizeof(temp));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1);
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = 64;//SHA1 result size
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACCompareFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

	    //Invoke_Crypto_MACCompareFinal
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1, sizeof(DATA_FOR_CRYPTO1));
    memcpy(SharedMem2.buffer, (void *)temp, sizeof(temp));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1);
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = 64;//SHA1 result size
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACCompareFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_MACComputeFinal_invalid_operation_class()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_HMAC_SHA1_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_HMAC_SHA1_256_VALUE01, sizeof(TEE_ATTR_HMAC_SHA1_256_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_HMAC_SHA1;
    operation.params[0].value.b = TEE_MODE_MAC;
    operation.params[1].value.a = SIZE_HMAC_SHA1_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }

    //Invoke_Crypto_MACCompareFinal
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_INPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(HMAC_result);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACComputeFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)HMAC_result, SharedMem2.buffer, sizeof(HMAC_result));

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;
}

TEEC_Result Invoke_Crypto_MACComputeFinal_invalid_value_handle()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_HMAC_SHA1_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_HMAC_SHA1_256_VALUE01, sizeof(TEE_ATTR_HMAC_SHA1_256_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }

    //Invoke_Crypto_MACCompareFinal
    operation.started = 1;
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_INPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(HMAC_result);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACComputeFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)HMAC_result, SharedMem2.buffer, sizeof(HMAC_result));

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;
}

TEEC_Result Invoke_Crypto_MACComputeFinal_operation_already_finalized()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_HMAC_SHA1_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_HMAC_SHA1_256_VALUE01, sizeof(TEE_ATTR_HMAC_SHA1_256_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_HMAC_SHA1;
    operation.params[0].value.b = SIZE_HMAC_SHA1_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_HMAC_SHA1_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_HMAC_SHA1;
    operation.params[0].value.b = TEE_MODE_MAC;
    operation.params[1].value.a = SIZE_HMAC_SHA1_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_MACInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, IV2_VALUE_128bits_AES, sizeof(IV2_VALUE_128bits_AES));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(IV2_VALUE_128bits_AES);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_MACUpdate
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    memcpy(SharedMem1.buffer+sizeof(DATA_FOR_CRYPTO1_PART1), (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1)+sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    #if 0
    //Invoke_Crypto_MACUpdate
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    #endif
    //Invoke_Crypto_MACCompareFinal
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_INPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(HMAC_result);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACComputeFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)HMAC_result, SharedMem2.buffer, sizeof(HMAC_result));

	    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_INPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(HMAC_result);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACComputeFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)HMAC_result, SharedMem2.buffer, sizeof(HMAC_result));

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;
}

TEEC_Result Invoke_Crypto_MACComputeFinal_short_buffer()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_HMAC_SHA224_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_HMAC_SHA224_256_VALUE01, sizeof(TEE_ATTR_HMAC_SHA224_256_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_HMAC_SHA224;
    operation.params[0].value.b = SIZE_HMAC_SHA224_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_HMAC_SHA224_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_HMAC_SHA224;
    operation.params[0].value.b = TEE_MODE_MAC;
    operation.params[1].value.a = SIZE_HMAC_SHA224_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_MACInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, IV2_VALUE_128bits_AES, sizeof(IV2_VALUE_128bits_AES));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(IV2_VALUE_128bits_AES);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_MACUpdate
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    memcpy(SharedMem1.buffer+sizeof(DATA_FOR_CRYPTO1_PART1), (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1)+sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    #if 0
    //Invoke_Crypto_MACUpdate
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    #endif
    //Invoke_Crypto_MACCompareFinal
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_INPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = 1;//sizeof(HMAC_result);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACComputeFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)HMAC_result, SharedMem2.buffer, sizeof(HMAC_result));

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;
}

TEEC_Result Invoke_Crypto_MACInit_init_vector_not_required_length()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("1 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_AES_CMAC;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_MAC;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("2 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("3 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_MACInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 16;//for test
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("4 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_MACInit_invalid_operation_class()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("1 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_AES_GCM;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_MAC;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test  invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("3 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_MACInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 16;//for test
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("4 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("5 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_MACInit_invalid_value_handle()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }

    //Invoke_Crypto_MACInit
    operation.started = 1;
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 16;//for test
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test  invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_MACInit_no_key_programmed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_AES_CBC_MAC_NOPAD;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_MAC;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }

    //Invoke_Crypto_MACInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 0;//for test
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_MACUpdate_invalid_value_handle()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_HMAC_SHA224_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_HMAC_SHA224_256_VALUE01, sizeof(TEE_ATTR_HMAC_SHA224_256_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }

    //Invoke_Crypto_MACUpdate
    operation.started = 1;
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    memcpy(SharedMem1.buffer+sizeof(DATA_FOR_CRYPTO1_PART1), (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1)+sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;
}

TEEC_Result Invoke_Crypto_MACUpdate_operation_already_finalized()
{
    TEEC_Context context02;
    TEEC_Session session02;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_HMAC_SHA512_512_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_HMAC_SHA512_512_VALUE01, sizeof(TEE_ATTR_HMAC_SHA512_512_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session02, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_HMAC_SHA512;
    operation.params[0].value.b = SIZE_HMAC_SHA512_512/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_HMAC_SHA512_512_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session02, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("1 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_HMAC_SHA512;
    operation.params[0].value.b = TEE_MODE_MAC;
    operation.params[1].value.a = SIZE_HMAC_SHA512_512/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session02, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("2 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session02, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("3 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_MACInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, IV2_VALUE_128bits_AES, sizeof(IV2_VALUE_128bits_AES));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(IV2_VALUE_128bits_AES);
    result = TEEC_InvokeCommand(&session02, CMD_Crypto_MACInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error(" 4 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }


    //Invoke_Crypto_MACCompareFinal
	//blocksize is 128byte in sha384 and sha512
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1, sizeof(DATA_FOR_CRYPTO1));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_INPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(HMAC_result);
    result = TEEC_InvokeCommand(&session02, CMD_Crypto_MACComputeFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("7 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)HMAC_result, SharedMem2.buffer, sizeof(HMAC_result));

    //Invoke_Crypto_MACUpdate
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    memcpy(SharedMem1.buffer+sizeof(DATA_FOR_CRYPTO1_PART1), (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1)+sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session02, CMD_Crypto_MACUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    TEEC_InvokeCommand(&session02, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    //CloseSession
    TEEC_CloseSession(&session02);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricDecrypt_TEE_ALG_RSAES_PKCS1_OAEP_MGF1_Success(uint32_t algorithm)
{

    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    #if 0
    uint32_t IN_AttributeID[] = {TEE_ATTR_RSA_MODULUS, 0, 256,
                                 TEE_ATTR_RSA_PUBLIC_EXPONENT, 256, 4,
                                    0, 0, 0,
                                    0, 0, 0,
                                    0, 0, 0};
    #endif
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[512] = {0};
    uint8_t decrypt_result[512] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    //encode IN_AttributeID
    /*SharedMem1 filled with a concatenation of
    (uint_32)$IN_AttributeID_1$|(uint_32)offset of  $IN_Attrib_Value_1$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_1$|
    (uint_32)$IN_AttributeID_2$|(uint_32)offset of  $IN_Attrib_Value_2$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_2$|
    (uint_32)$IN_AttributeID_3$|(uint_32)offset of  $IN_Attrib_Value_3$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_3$|
    ... and so on*/
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_RSA_MODULUS), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+12, retrieveUint32toBuffer(TEE_ATTR_RSA_PUBLIC_EXPONENT), sizeof(uint32_t));
    memcpy(IN_AttributeID+16, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+20, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    /*SharedMem2 filled with a concatenation of
    $IN_Attrib_Value_1$|$IN_Attrib_Value_2$|$IN_Attrib_Value_3$|$IN_Attrib_Value_4$|$IN_Attrib_Value_5$*/
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_RSA_MODULUS_VALUE01, sizeof(TEE_ATTR_RSA_MODULUS_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01), (void *)TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01));
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }

    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_RSA_PUBLIC_KEY;
    operation.params[0].value.b = SIZE_RSA_KEYPAIR_2048/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_InitObjectWithKeys failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //+++++++++++++++++++++encrypt++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_RSA_KEYPAIR_2048/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AllocateOperation failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_SetOperationKey failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_AsymmetricEncrypt
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1, sizeof(DATA_FOR_CRYPTO1));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = 512;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AsymmetricEncrypt, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AsymmetricEncrypt failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)encrypt_result, SharedMem2.buffer, 512);
    //++++++++++++++++++++++++decrypt+++++++++++++++++++++++++++++++
    //Invoke_Crypto_InitObjectWithKeys

    memset(SharedMem1.buffer, 0, BIG_SIZE);
    //encode IN_AttributeID
    /*SharedMem1 filled with a concatenation of
    (uint_32)$IN_AttributeID_1$|(uint_32)offset of  $IN_Attrib_Value_1$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_1$|
    (uint_32)$IN_AttributeID_2$|(uint_32)offset of  $IN_Attrib_Value_2$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_2$|
    (uint_32)$IN_AttributeID_3$|(uint_32)offset of  $IN_Attrib_Value_3$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_3$|
    ... and so on*/
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_RSA_MODULUS), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+12, retrieveUint32toBuffer(TEE_ATTR_RSA_PUBLIC_EXPONENT), sizeof(uint32_t));
    memcpy(IN_AttributeID+16, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+20, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+24, retrieveUint32toBuffer(TEE_ATTR_RSA_PRIVATE_EXPONENT), sizeof(uint32_t));
    memcpy(IN_AttributeID+28, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+32, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    /*SharedMem2 filled with a concatenation of
    $IN_Attrib_Value_1$|$IN_Attrib_Value_2$|$IN_Attrib_Value_3$|$IN_Attrib_Value_4$|$IN_Attrib_Value_5$*/
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_RSA_MODULUS_VALUE01, sizeof(TEE_ATTR_RSA_MODULUS_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01), (void *)TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01), (void *)TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01));

    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_RSA_KEYPAIR;
    operation.params[0].value.b = SIZE_RSA_KEYPAIR_2048/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)+sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_InitObjectWithKeys failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_DECRYPT;
    operation.params[1].value.a = SIZE_RSA_KEYPAIR_2048/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AllocateOperation failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_SetOperationKey failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_AsymmetricDecrypt
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)encrypt_result, sizeof(encrypt_result));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = 512;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AsymmetricDecrypt, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AsymmetricDecrypt failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)decrypt_result, SharedMem2.buffer, 512);

    if(memcmp(DATA_FOR_CRYPTO1, decrypt_result, sizeof(DATA_FOR_CRYPTO1))){
        TEEC_Error("decrypt data is not equal to encrypt\n");
        for(i=0; i<sizeof(DATA_FOR_CRYPTO1); i++){
            TEEC_Error("DATA_FOR_CRYPTO1[%d] = %x, decrypt_Data[%d] = %x\n",
                i, DATA_FOR_CRYPTO1[i], i, *((uint8_t *)decrypt_result+i));
        }
        result = TEEC_ERROR_MAC_INVALID;
    }

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricDecrypt_TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA224_Success_01(uint32_t algorithm)
{

    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    #if 0
    uint32_t IN_AttributeID[] = {TEE_ATTR_RSA_MODULUS, 0, 256,
                                 TEE_ATTR_RSA_PUBLIC_EXPONENT, 256, 4,
                                    0, 0, 0,
                                    0, 0, 0,
                                    0, 0, 0};
    #endif
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[512] = {0};
    uint8_t decrypt_result[512] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    //encode IN_AttributeID
    /*SharedMem1 filled with a concatenation of
    (uint_32)$IN_AttributeID_1$|(uint_32)offset of  $IN_Attrib_Value_1$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_1$|
    (uint_32)$IN_AttributeID_2$|(uint_32)offset of  $IN_Attrib_Value_2$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_2$|
    (uint_32)$IN_AttributeID_3$|(uint_32)offset of  $IN_Attrib_Value_3$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_3$|
    ... and so on*/
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_RSA_MODULUS), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+12, retrieveUint32toBuffer(TEE_ATTR_RSA_PUBLIC_EXPONENT), sizeof(uint32_t));
    memcpy(IN_AttributeID+16, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+20, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+24, retrieveUint32toBuffer(TEE_ATTR_RSA_PRIVATE_EXPONENT), sizeof(uint32_t)); //
    memcpy(IN_AttributeID+28, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));//
    memcpy(IN_AttributeID+32, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01)), sizeof(uint32_t));//
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    /*SharedMem2 filled with a concatenation of
    $IN_Attrib_Value_1$|$IN_Attrib_Value_2$|$IN_Attrib_Value_3$|$IN_Attrib_Value_4$|$IN_Attrib_Value_5$*/
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_RSA_MODULUS_VALUE01, sizeof(TEE_ATTR_RSA_MODULUS_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01), (void *)TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01), (void *)TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01));//
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }

    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a =TEE_TYPE_RSA_KEYPAIR;// TEE_TYPE_RSA_PUBLIC_KEY;
    operation.params[0].value.b = SIZE_RSA_KEYPAIR_2048/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)+sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01);//
    operation.params[3].value.a = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_InitObjectWithKeys failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //+++++++++++++++++++++encrypt++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_RSA_KEYPAIR_2048/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AllocateOperation failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_SetOperationKey failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_AsymmetricEncrypt
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1, sizeof(DATA_FOR_CRYPTO1));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = 512;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AsymmetricEncrypt, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AsymmetricEncrypt failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)encrypt_result, SharedMem2.buffer, 512);
    //++++++++++++++++++++++++decrypt+++++++++++++++++++++++++++++++
    //Invoke_Crypto_InitObjectWithKeys

    memset(SharedMem1.buffer, 0, BIG_SIZE);
    //encode IN_AttributeID
    /*SharedMem1 filled with a concatenation of
    (uint_32)$IN_AttributeID_1$|(uint_32)offset of  $IN_Attrib_Value_1$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_1$|
    (uint_32)$IN_AttributeID_2$|(uint_32)offset of  $IN_Attrib_Value_2$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_2$|
    (uint_32)$IN_AttributeID_3$|(uint_32)offset of  $IN_Attrib_Value_3$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_3$|
    ... and so on*/
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_RSA_MODULUS), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+12, retrieveUint32toBuffer(TEE_ATTR_RSA_PUBLIC_EXPONENT), sizeof(uint32_t));
    memcpy(IN_AttributeID+16, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+20, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+24, retrieveUint32toBuffer(TEE_ATTR_RSA_PRIVATE_EXPONENT), sizeof(uint32_t));
    memcpy(IN_AttributeID+28, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+32, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    /*SharedMem2 filled with a concatenation of
    $IN_Attrib_Value_1$|$IN_Attrib_Value_2$|$IN_Attrib_Value_3$|$IN_Attrib_Value_4$|$IN_Attrib_Value_5$*/
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_RSA_MODULUS_VALUE01, sizeof(TEE_ATTR_RSA_MODULUS_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01), (void *)TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01), (void *)TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01));

    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_RSA_KEYPAIR;
    operation.params[0].value.b = SIZE_RSA_KEYPAIR_2048/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)+sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_InitObjectWithKeys failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_DECRYPT;
    operation.params[1].value.a = SIZE_RSA_KEYPAIR_2048/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AllocateOperation failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_SetOperationKey failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_AsymmetricDecrypt
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)encrypt_result, sizeof(encrypt_result));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = 512;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AsymmetricDecrypt, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AsymmetricDecrypt failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)decrypt_result, SharedMem2.buffer, 512);

    if(memcmp(DATA_FOR_CRYPTO1, decrypt_result, sizeof(DATA_FOR_CRYPTO1))){
        TEEC_Error("decrypt data is not equal to encrypt\n");
        for(i=0; i<sizeof(DATA_FOR_CRYPTO1); i++){
            TEEC_Error("DATA_FOR_CRYPTO1[%d] = %x, decrypt_Data[%d] = %x\n",
                i, DATA_FOR_CRYPTO1[i], i, *((uint8_t *)decrypt_result+i));
        }
        result = TEEC_ERROR_MAC_INVALID;
    }

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricDecrypt_TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA256_Success_01(uint32_t algorithm)
{

    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    #if 0
    uint32_t IN_AttributeID[] = {TEE_ATTR_RSA_MODULUS, 0, 256,
                                 TEE_ATTR_RSA_PUBLIC_EXPONENT, 256, 4,
                                    0, 0, 0,
                                    0, 0, 0,
                                    0, 0, 0};
    #endif
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[512] = {0};
    uint8_t decrypt_result[512] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    //encode IN_AttributeID
    /*SharedMem1 filled with a concatenation of
    (uint_32)$IN_AttributeID_1$|(uint_32)offset of  $IN_Attrib_Value_1$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_1$|
    (uint_32)$IN_AttributeID_2$|(uint_32)offset of  $IN_Attrib_Value_2$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_2$|
    (uint_32)$IN_AttributeID_3$|(uint_32)offset of  $IN_Attrib_Value_3$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_3$|
    ... and so on*/
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_RSA_MODULUS), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+12, retrieveUint32toBuffer(TEE_ATTR_RSA_PUBLIC_EXPONENT), sizeof(uint32_t));
    memcpy(IN_AttributeID+16, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+20, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    /*SharedMem2 filled with a concatenation of
    $IN_Attrib_Value_1$|$IN_Attrib_Value_2$|$IN_Attrib_Value_3$|$IN_Attrib_Value_4$|$IN_Attrib_Value_5$*/
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_RSA_MODULUS_VALUE01, sizeof(TEE_ATTR_RSA_MODULUS_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01), (void *)TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01));
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }

    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_RSA_PUBLIC_KEY;
    operation.params[0].value.b = SIZE_RSA_KEYPAIR_2048/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_InitObjectWithKeys failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //+++++++++++++++++++++encrypt++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_RSA_KEYPAIR_2048/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AllocateOperation failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_SetOperationKey failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_AsymmetricEncrypt
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1, sizeof(DATA_FOR_CRYPTO1));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = 512;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AsymmetricEncrypt, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AsymmetricEncrypt failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)encrypt_result, SharedMem2.buffer, 512);
    //++++++++++++++++++++++++decrypt+++++++++++++++++++++++++++++++
    //Invoke_Crypto_InitObjectWithKeys

    memset(SharedMem1.buffer, 0, BIG_SIZE);
    //encode IN_AttributeID
    /*SharedMem1 filled with a concatenation of
    (uint_32)$IN_AttributeID_1$|(uint_32)offset of  $IN_Attrib_Value_1$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_1$|
    (uint_32)$IN_AttributeID_2$|(uint_32)offset of  $IN_Attrib_Value_2$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_2$|
    (uint_32)$IN_AttributeID_3$|(uint_32)offset of  $IN_Attrib_Value_3$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_3$|
    ... and so on*/
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_RSA_MODULUS), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+12, retrieveUint32toBuffer(TEE_ATTR_RSA_PUBLIC_EXPONENT), sizeof(uint32_t));
    memcpy(IN_AttributeID+16, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+20, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+24, retrieveUint32toBuffer(TEE_ATTR_RSA_PRIVATE_EXPONENT), sizeof(uint32_t));
    memcpy(IN_AttributeID+28, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+32, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    /*SharedMem2 filled with a concatenation of
    $IN_Attrib_Value_1$|$IN_Attrib_Value_2$|$IN_Attrib_Value_3$|$IN_Attrib_Value_4$|$IN_Attrib_Value_5$*/
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_RSA_MODULUS_VALUE01, sizeof(TEE_ATTR_RSA_MODULUS_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01), (void *)TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01), (void *)TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01));

    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_RSA_KEYPAIR;
    operation.params[0].value.b = SIZE_RSA_KEYPAIR_2048/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)+sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_InitObjectWithKeys failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_DECRYPT;
    operation.params[1].value.a = SIZE_RSA_KEYPAIR_2048/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AllocateOperation failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_SetOperationKey failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_AsymmetricDecrypt
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)encrypt_result, sizeof(encrypt_result));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = 512;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AsymmetricDecrypt, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AsymmetricDecrypt failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)decrypt_result, SharedMem2.buffer, 512);

    if(memcmp(DATA_FOR_CRYPTO1, decrypt_result, sizeof(DATA_FOR_CRYPTO1))){
        TEEC_Error("decrypt data is not equal to encrypt\n");
        for(i=0; i<sizeof(DATA_FOR_CRYPTO1); i++){
            TEEC_Error("DATA_FOR_CRYPTO1[%d] = %x, decrypt_Data[%d] = %x\n",
                i, DATA_FOR_CRYPTO1[i], i, *((uint8_t *)decrypt_result+i));
        }
        result = TEEC_ERROR_MAC_INVALID;
    }

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricDecrypt_TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA384_Success_01(uint32_t algorithm)
{

    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    #if 0
    uint32_t IN_AttributeID[] = {TEE_ATTR_RSA_MODULUS, 0, 256,
                                 TEE_ATTR_RSA_PUBLIC_EXPONENT, 256, 4,
                                    0, 0, 0,
                                    0, 0, 0,
                                    0, 0, 0};
    #endif
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[512] = {0};
    uint8_t decrypt_result[512] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    //encode IN_AttributeID
    /*SharedMem1 filled with a concatenation of
    (uint_32)$IN_AttributeID_1$|(uint_32)offset of  $IN_Attrib_Value_1$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_1$|
    (uint_32)$IN_AttributeID_2$|(uint_32)offset of  $IN_Attrib_Value_2$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_2$|
    (uint_32)$IN_AttributeID_3$|(uint_32)offset of  $IN_Attrib_Value_3$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_3$|
    ... and so on*/
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_RSA_MODULUS), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+12, retrieveUint32toBuffer(TEE_ATTR_RSA_PUBLIC_EXPONENT), sizeof(uint32_t));
    memcpy(IN_AttributeID+16, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+20, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+24, retrieveUint32toBuffer(TEE_ATTR_RSA_PRIVATE_EXPONENT), sizeof(uint32_t)); //
    memcpy(IN_AttributeID+28, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));//
    memcpy(IN_AttributeID+32, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01)), sizeof(uint32_t));//
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    /*SharedMem2 filled with a concatenation of
    $IN_Attrib_Value_1$|$IN_Attrib_Value_2$|$IN_Attrib_Value_3$|$IN_Attrib_Value_4$|$IN_Attrib_Value_5$*/
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_RSA_MODULUS_VALUE01, sizeof(TEE_ATTR_RSA_MODULUS_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01), (void *)TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01), (void *)TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01));//
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }

    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a =TEE_TYPE_RSA_KEYPAIR;// TEE_TYPE_RSA_PUBLIC_KEY;
    operation.params[0].value.b = SIZE_RSA_KEYPAIR_2048/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)+sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01);//
    operation.params[3].value.a = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_InitObjectWithKeys failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //+++++++++++++++++++++encrypt++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_RSA_KEYPAIR_2048/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AllocateOperation failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_SetOperationKey failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_AsymmetricEncrypt
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1, sizeof(DATA_FOR_CRYPTO1));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = 512;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AsymmetricEncrypt, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AsymmetricEncrypt failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)encrypt_result, SharedMem2.buffer, 512);
    //++++++++++++++++++++++++decrypt+++++++++++++++++++++++++++++++
    //Invoke_Crypto_InitObjectWithKeys

    memset(SharedMem1.buffer, 0, BIG_SIZE);
    //encode IN_AttributeID
    /*SharedMem1 filled with a concatenation of
    (uint_32)$IN_AttributeID_1$|(uint_32)offset of  $IN_Attrib_Value_1$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_1$|
    (uint_32)$IN_AttributeID_2$|(uint_32)offset of  $IN_Attrib_Value_2$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_2$|
    (uint_32)$IN_AttributeID_3$|(uint_32)offset of  $IN_Attrib_Value_3$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_3$|
    ... and so on*/
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_RSA_MODULUS), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+12, retrieveUint32toBuffer(TEE_ATTR_RSA_PUBLIC_EXPONENT), sizeof(uint32_t));
    memcpy(IN_AttributeID+16, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+20, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+24, retrieveUint32toBuffer(TEE_ATTR_RSA_PRIVATE_EXPONENT), sizeof(uint32_t));
    memcpy(IN_AttributeID+28, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+32, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    /*SharedMem2 filled with a concatenation of
    $IN_Attrib_Value_1$|$IN_Attrib_Value_2$|$IN_Attrib_Value_3$|$IN_Attrib_Value_4$|$IN_Attrib_Value_5$*/
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_RSA_MODULUS_VALUE01, sizeof(TEE_ATTR_RSA_MODULUS_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01), (void *)TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01), (void *)TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01));

    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_RSA_KEYPAIR;
    operation.params[0].value.b = SIZE_RSA_KEYPAIR_2048/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)+sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_InitObjectWithKeys failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_DECRYPT;
    operation.params[1].value.a = SIZE_RSA_KEYPAIR_2048/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AllocateOperation failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_SetOperationKey failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_AsymmetricDecrypt
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)encrypt_result, sizeof(encrypt_result));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = 512;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AsymmetricDecrypt, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AsymmetricDecrypt failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)decrypt_result, SharedMem2.buffer, 512);

    if(memcmp(DATA_FOR_CRYPTO1, decrypt_result, sizeof(DATA_FOR_CRYPTO1))){
        TEEC_Error("decrypt data is not equal to encrypt\n");
        for(i=0; i<sizeof(DATA_FOR_CRYPTO1); i++){
            TEEC_Error("DATA_FOR_CRYPTO1[%d] = %x, decrypt_Data[%d] = %x\n",
                i, DATA_FOR_CRYPTO1[i], i, *((uint8_t *)decrypt_result+i));
        }
        result = TEEC_ERROR_MAC_INVALID;
    }

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricDecrypt_TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA512_Success_01(uint32_t algorithm)
{

    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    #if 0
    uint32_t IN_AttributeID[] = {TEE_ATTR_RSA_MODULUS, 0, 256,
                                 TEE_ATTR_RSA_PUBLIC_EXPONENT, 256, 4,
                                    0, 0, 0,
                                    0, 0, 0,
                                    0, 0, 0};
    #endif
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[512] = {0};
    uint8_t decrypt_result[512] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    //encode IN_AttributeID
    /*SharedMem1 filled with a concatenation of
    (uint_32)$IN_AttributeID_1$|(uint_32)offset of  $IN_Attrib_Value_1$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_1$|
    (uint_32)$IN_AttributeID_2$|(uint_32)offset of  $IN_Attrib_Value_2$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_2$|
    (uint_32)$IN_AttributeID_3$|(uint_32)offset of  $IN_Attrib_Value_3$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_3$|
    ... and so on*/
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_RSA_MODULUS), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+12, retrieveUint32toBuffer(TEE_ATTR_RSA_PUBLIC_EXPONENT), sizeof(uint32_t));
    memcpy(IN_AttributeID+16, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+20, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    /*SharedMem2 filled with a concatenation of
    $IN_Attrib_Value_1$|$IN_Attrib_Value_2$|$IN_Attrib_Value_3$|$IN_Attrib_Value_4$|$IN_Attrib_Value_5$*/
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_RSA_MODULUS_VALUE01, sizeof(TEE_ATTR_RSA_MODULUS_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01), (void *)TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01));
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }

    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_RSA_PUBLIC_KEY;
    operation.params[0].value.b = SIZE_RSA_KEYPAIR_2048/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_InitObjectWithKeys failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //+++++++++++++++++++++encrypt++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_RSA_KEYPAIR_2048/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AllocateOperation failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_SetOperationKey failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_AsymmetricEncrypt
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1, sizeof(DATA_FOR_CRYPTO1));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = 512;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AsymmetricEncrypt, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AsymmetricEncrypt failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)encrypt_result, SharedMem2.buffer, 512);
    //++++++++++++++++++++++++decrypt+++++++++++++++++++++++++++++++
    //Invoke_Crypto_InitObjectWithKeys

    memset(SharedMem1.buffer, 0, BIG_SIZE);
    //encode IN_AttributeID
    /*SharedMem1 filled with a concatenation of
    (uint_32)$IN_AttributeID_1$|(uint_32)offset of  $IN_Attrib_Value_1$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_1$|
    (uint_32)$IN_AttributeID_2$|(uint_32)offset of  $IN_Attrib_Value_2$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_2$|
    (uint_32)$IN_AttributeID_3$|(uint_32)offset of  $IN_Attrib_Value_3$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_3$|
    ... and so on*/
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_RSA_MODULUS), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+12, retrieveUint32toBuffer(TEE_ATTR_RSA_PUBLIC_EXPONENT), sizeof(uint32_t));
    memcpy(IN_AttributeID+16, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+20, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+24, retrieveUint32toBuffer(TEE_ATTR_RSA_PRIVATE_EXPONENT), sizeof(uint32_t));
    memcpy(IN_AttributeID+28, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+32, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    /*SharedMem2 filled with a concatenation of
    $IN_Attrib_Value_1$|$IN_Attrib_Value_2$|$IN_Attrib_Value_3$|$IN_Attrib_Value_4$|$IN_Attrib_Value_5$*/
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_RSA_MODULUS_VALUE01, sizeof(TEE_ATTR_RSA_MODULUS_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01), (void *)TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01), (void *)TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01));

    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_RSA_KEYPAIR;
    operation.params[0].value.b = SIZE_RSA_KEYPAIR_2048/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)+sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_InitObjectWithKeys failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_DECRYPT;
    operation.params[1].value.a = SIZE_RSA_KEYPAIR_2048/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AllocateOperation failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_SetOperationKey failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_AsymmetricDecrypt
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)encrypt_result, sizeof(encrypt_result));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = 512;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AsymmetricDecrypt, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AsymmetricDecrypt failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)decrypt_result, SharedMem2.buffer, 512);

    if(memcmp(DATA_FOR_CRYPTO1, decrypt_result, sizeof(DATA_FOR_CRYPTO1))){
        TEEC_Error("decrypt data is not equal to encrypt\n");
        for(i=0; i<sizeof(DATA_FOR_CRYPTO1); i++){
            TEEC_Error("DATA_FOR_CRYPTO1[%d] = %x, decrypt_Data[%d] = %x\n",
                i, DATA_FOR_CRYPTO1[i], i, *((uint8_t *)decrypt_result+i));
        }
        result = TEEC_ERROR_MAC_INVALID;
    }

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricDecrypt_TEE_ALG_RSA_NOPAD_TEE_MODE_DECRYPT_Success_01(uint32_t algorithm)
{

    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    #if 0
    uint32_t IN_AttributeID[] = {TEE_ATTR_RSA_MODULUS, 0, 256,
                                 TEE_ATTR_RSA_PUBLIC_EXPONENT, 256, 4,
                                    0, 0, 0,
                                    0, 0, 0,
                                    0, 0, 0};
    #endif
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[512] = {0};
    uint8_t decrypt_result[512] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    //encode IN_AttributeID
    /*SharedMem1 filled with a concatenation of
    (uint_32)$IN_AttributeID_1$|(uint_32)offset of  $IN_Attrib_Value_1$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_1$|
    (uint_32)$IN_AttributeID_2$|(uint_32)offset of  $IN_Attrib_Value_2$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_2$|
    (uint_32)$IN_AttributeID_3$|(uint_32)offset of  $IN_Attrib_Value_3$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_3$|
    ... and so on*/
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_RSA_MODULUS), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+12, retrieveUint32toBuffer(TEE_ATTR_RSA_PUBLIC_EXPONENT), sizeof(uint32_t));
    memcpy(IN_AttributeID+16, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+20, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    /*SharedMem2 filled with a concatenation of
    $IN_Attrib_Value_1$|$IN_Attrib_Value_2$|$IN_Attrib_Value_3$|$IN_Attrib_Value_4$|$IN_Attrib_Value_5$*/
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_RSA_MODULUS_VALUE01, sizeof(TEE_ATTR_RSA_MODULUS_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01), (void *)TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01));
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }

    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_RSA_PUBLIC_KEY;
    operation.params[0].value.b = SIZE_RSA_KEYPAIR_2048/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_InitObjectWithKeys failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //+++++++++++++++++++++encrypt++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_RSA_KEYPAIR_2048/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AllocateOperation failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_SetOperationKey failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_AsymmetricEncrypt
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1, sizeof(DATA_FOR_CRYPTO1));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = 512;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AsymmetricEncrypt, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AsymmetricEncrypt failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)encrypt_result, SharedMem2.buffer, 512);
    #if 0
    for(i=0; i<96; i++){
        TEEC_Debug("encrypt_result[%d] = %x\n",
        i, *((uint8_t *)encrypt_result+i));
    }
    #endif
    //++++++++++++++++++++++++decrypt+++++++++++++++++++++++++++++++
    //Invoke_Crypto_InitObjectWithKeys

    memset(SharedMem1.buffer, 0, BIG_SIZE);
    //encode IN_AttributeID
    /*SharedMem1 filled with a concatenation of
    (uint_32)$IN_AttributeID_1$|(uint_32)offset of  $IN_Attrib_Value_1$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_1$|
    (uint_32)$IN_AttributeID_2$|(uint_32)offset of  $IN_Attrib_Value_2$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_2$|
    (uint_32)$IN_AttributeID_3$|(uint_32)offset of  $IN_Attrib_Value_3$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_3$|
    ... and so on*/
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_RSA_MODULUS), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+12, retrieveUint32toBuffer(TEE_ATTR_RSA_PUBLIC_EXPONENT), sizeof(uint32_t));
    memcpy(IN_AttributeID+16, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+20, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+24, retrieveUint32toBuffer(TEE_ATTR_RSA_PRIVATE_EXPONENT), sizeof(uint32_t));
    memcpy(IN_AttributeID+28, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+32, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    /*SharedMem2 filled with a concatenation of
    $IN_Attrib_Value_1$|$IN_Attrib_Value_2$|$IN_Attrib_Value_3$|$IN_Attrib_Value_4$|$IN_Attrib_Value_5$*/
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_RSA_MODULUS_VALUE01, sizeof(TEE_ATTR_RSA_MODULUS_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01), (void *)TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01), (void *)TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01));

    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_RSA_KEYPAIR;
    operation.params[0].value.b = SIZE_RSA_KEYPAIR_2048/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)+sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_InitObjectWithKeys failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_DECRYPT;
    operation.params[1].value.a = SIZE_RSA_KEYPAIR_2048/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AllocateOperation failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_SetOperationKey failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_AsymmetricDecrypt
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)encrypt_result, sizeof(encrypt_result));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = 512;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AsymmetricDecrypt, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AsymmetricDecrypt failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)decrypt_result, SharedMem2.buffer, 512);
    if(algorithm != TEE_ALG_RSA_NOPAD){
        if(memcmp(DATA_FOR_CRYPTO1, decrypt_result, sizeof(DATA_FOR_CRYPTO1))){
            TEEC_Error("decrypt data is not equal to encrypt\n");
            for(i=0; i<sizeof(DATA_FOR_CRYPTO1); i++){
                TEEC_Error("DATA_FOR_CRYPTO1[%d] = %x, decrypt_Data[%d] = %x\n",
                    i, DATA_FOR_CRYPTO1[i], i, *((uint8_t *)decrypt_result+i));
            }
            result = TEEC_ERROR_MAC_INVALID;
        }
    }else{
        if(memcmp(DATA_FOR_CRYPTO1, decrypt_result+(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)-sizeof(DATA_FOR_CRYPTO1)), sizeof(DATA_FOR_CRYPTO1))){
            TEEC_Error("decrypt data is not equal to encrypt\n");
            for(i=0; i<sizeof(DATA_FOR_CRYPTO1); i++){
                TEEC_Error("DATA_FOR_CRYPTO1[%d] = %x, decrypt_Data[%d] = %x\n",
                    i, DATA_FOR_CRYPTO1[i], i, *((uint8_t *)decrypt_result+(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)-sizeof(DATA_FOR_CRYPTO1))+i));
            }
            result = TEEC_ERROR_MAC_INVALID;
        }
    }

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;
}


TEEC_Result Invoke_Crypto_AsymmetricDecrypt_incompatible_mode_01(uint32_t algorithm)
{

    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    #if 0
    uint32_t IN_AttributeID[] = {TEE_ATTR_RSA_MODULUS, 0, 256,
                                 TEE_ATTR_RSA_PUBLIC_EXPONENT, 256, 4,
                                    0, 0, 0,
                                    0, 0, 0,
                                    0, 0, 0};
    #endif
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[512] = {0};
    uint8_t decrypt_result[512] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    //encode IN_AttributeID
    /*SharedMem1 filled with a concatenation of
    (uint_32)$IN_AttributeID_1$|(uint_32)offset of  $IN_Attrib_Value_1$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_1$|
    (uint_32)$IN_AttributeID_2$|(uint_32)offset of  $IN_Attrib_Value_2$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_2$|
    (uint_32)$IN_AttributeID_3$|(uint_32)offset of  $IN_Attrib_Value_3$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_3$|
    ... and so on*/
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_RSA_MODULUS), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+12, retrieveUint32toBuffer(TEE_ATTR_RSA_PUBLIC_EXPONENT), sizeof(uint32_t));
    memcpy(IN_AttributeID+16, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+20, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+24, retrieveUint32toBuffer(TEE_ATTR_RSA_PRIVATE_EXPONENT), sizeof(uint32_t)); //
    memcpy(IN_AttributeID+28, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));//
    memcpy(IN_AttributeID+32, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01)), sizeof(uint32_t));//
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    /*SharedMem2 filled with a concatenation of
    $IN_Attrib_Value_1$|$IN_Attrib_Value_2$|$IN_Attrib_Value_3$|$IN_Attrib_Value_4$|$IN_Attrib_Value_5$*/
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_RSA_MODULUS_VALUE01, sizeof(TEE_ATTR_RSA_MODULUS_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01), (void *)TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01), (void *)TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01));//
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }

    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a =TEE_TYPE_RSA_KEYPAIR;// TEE_TYPE_RSA_PUBLIC_KEY;
    operation.params[0].value.b = SIZE_RSA_KEYPAIR_2048/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)+sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01);//
    operation.params[3].value.a = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("1 invoke CMD_Crypto_InitObjectWithKeys failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //+++++++++++++++++++++encrypt++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_RSA_KEYPAIR_2048/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("2 invoke CMD_Crypto_AllocateOperation failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("3 invoke CMD_Crypto_SetOperationKey failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_AsymmetricEncrypt
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1, sizeof(DATA_FOR_CRYPTO1));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = 512;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AsymmetricEncrypt, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("4 invoke CMD_Crypto_AsymmetricEncrypt failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)encrypt_result, SharedMem2.buffer, 512);
    //++++++++++++++++++++++++decrypt+++++++++++++++++++++++++++++++
    //Invoke_Crypto_InitObjectWithKeys

    memset(SharedMem1.buffer, 0, BIG_SIZE);
    //encode IN_AttributeID
    /*SharedMem1 filled with a concatenation of
    (uint_32)$IN_AttributeID_1$|(uint_32)offset of  $IN_Attrib_Value_1$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_1$|
    (uint_32)$IN_AttributeID_2$|(uint_32)offset of  $IN_Attrib_Value_2$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_2$|
    (uint_32)$IN_AttributeID_3$|(uint_32)offset of  $IN_Attrib_Value_3$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_3$|
    ... and so on*/
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_RSA_MODULUS), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+12, retrieveUint32toBuffer(TEE_ATTR_RSA_PUBLIC_EXPONENT), sizeof(uint32_t));
    memcpy(IN_AttributeID+16, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+20, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+24, retrieveUint32toBuffer(TEE_ATTR_RSA_PRIVATE_EXPONENT), sizeof(uint32_t));
    memcpy(IN_AttributeID+28, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+32, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    /*SharedMem2 filled with a concatenation of
    $IN_Attrib_Value_1$|$IN_Attrib_Value_2$|$IN_Attrib_Value_3$|$IN_Attrib_Value_4$|$IN_Attrib_Value_5$*/
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_RSA_MODULUS_VALUE01, sizeof(TEE_ATTR_RSA_MODULUS_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01), (void *)TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01), (void *)TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01));

    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_RSA_KEYPAIR;
    operation.params[0].value.b = SIZE_RSA_KEYPAIR_2048/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)+sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("5 invoke CMD_Crypto_InitObjectWithKeys failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_RSA_KEYPAIR_2048/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("6 invoke CMD_Crypto_AllocateOperation failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("7 invoke CMD_Crypto_SetOperationKey failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_AsymmetricDecrypt
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)encrypt_result, sizeof(encrypt_result));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = 512;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AsymmetricDecrypt, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("8 invoke CMD_Crypto_AsymmetricDecrypt failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)decrypt_result, SharedMem2.buffer, 512);

    if(memcmp(DATA_FOR_CRYPTO1, decrypt_result, sizeof(DATA_FOR_CRYPTO1))){
        TEEC_Error("decrypt data is not equal to encrypt\n");
        for(i=0; i<sizeof(DATA_FOR_CRYPTO1); i++){
            TEEC_Error("DATA_FOR_CRYPTO1[%d] = %x, decrypt_Data[%d] = %x\n",
                i, DATA_FOR_CRYPTO1[i], i, *((uint8_t *)decrypt_result+i));
        }
        result = TEEC_ERROR_MAC_INVALID;
    }

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricDecrypt_invalid_operation_class_01(uint32_t algorithm)
{

    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    #if 0
    uint32_t IN_AttributeID[] = {TEE_ATTR_RSA_MODULUS, 0, 256,
                                 TEE_ATTR_RSA_PUBLIC_EXPONENT, 256, 4,
                                    0, 0, 0,
                                    0, 0, 0,
                                    0, 0, 0};
    #endif
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[512] = {0};
    uint8_t decrypt_result[512] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    //encode IN_AttributeID
    /*SharedMem1 filled with a concatenation of
    (uint_32)$IN_AttributeID_1$|(uint_32)offset of  $IN_Attrib_Value_1$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_1$|
    (uint_32)$IN_AttributeID_2$|(uint_32)offset of  $IN_Attrib_Value_2$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_2$|
    (uint_32)$IN_AttributeID_3$|(uint_32)offset of  $IN_Attrib_Value_3$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_3$|
    ... and so on*/
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_RSA_MODULUS), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+12, retrieveUint32toBuffer(TEE_ATTR_RSA_PUBLIC_EXPONENT), sizeof(uint32_t));
    memcpy(IN_AttributeID+16, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+20, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+24, retrieveUint32toBuffer(TEE_ATTR_RSA_PRIVATE_EXPONENT), sizeof(uint32_t)); //
    memcpy(IN_AttributeID+28, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));//
    memcpy(IN_AttributeID+32, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01)), sizeof(uint32_t));//
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    /*SharedMem2 filled with a concatenation of
    $IN_Attrib_Value_1$|$IN_Attrib_Value_2$|$IN_Attrib_Value_3$|$IN_Attrib_Value_4$|$IN_Attrib_Value_5$*/
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_RSA_MODULUS_VALUE01, sizeof(TEE_ATTR_RSA_MODULUS_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01), (void *)TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01), (void *)TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01));//
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }

    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a =TEE_TYPE_RSA_KEYPAIR;// TEE_TYPE_RSA_PUBLIC_KEY;
    operation.params[0].value.b = SIZE_RSA_KEYPAIR_2048/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)+sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01);//
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("1 invoke CMD_Crypto_InitObjectWithKeys failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //+++++++++++++++++++++encrypt++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_RSA_KEYPAIR_2048/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("2 invoke CMD_Crypto_AllocateOperation failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("3 invoke CMD_Crypto_SetOperationKey failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_AsymmetricEncrypt
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1, sizeof(DATA_FOR_CRYPTO1));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = 512;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AsymmetricEncrypt, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("4 invoke CMD_Crypto_AsymmetricEncrypt failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)encrypt_result, SharedMem2.buffer, 512);
    //++++++++++++++++++++++++decrypt+++++++++++++++++++++++++++++++

    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_MD5;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_ZERO+ SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test  invoke CMD_Crypto_AllocateOperation failed, codes=0x%x, origin=0x%x\n", result, origin);
    } //TEE_ERROR_TARGET_DEADTEE_ERROR_BAD_PARAMETERS

    //Invoke_Crypto_AsymmetricDecrypt
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)encrypt_result, sizeof(encrypt_result));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = 512;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AsymmetricDecrypt, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke CMD_Crypto_AsymmetricDecrypt failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)decrypt_result, SharedMem2.buffer, 512);

    if(memcmp(DATA_FOR_CRYPTO1, decrypt_result, sizeof(DATA_FOR_CRYPTO1))){
        TEEC_Error("decrypt data is not equal to encrypt\n");
        for(i=0; i<sizeof(DATA_FOR_CRYPTO1); i++){
            TEEC_Error("DATA_FOR_CRYPTO1[%d] = %x, decrypt_Data[%d] = %x\n",
                i, DATA_FOR_CRYPTO1[i], i, *((uint8_t *)decrypt_result+i));
        }
        result = TEEC_ERROR_MAC_INVALID;
    }

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;
}


TEEC_Result Invoke_Crypto_AsymmetricDecrypt_invalid_value_handle_01(uint32_t algorithm)
{

    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    #if 0
    uint32_t IN_AttributeID[] = {TEE_ATTR_RSA_MODULUS, 0, 256,
                                 TEE_ATTR_RSA_PUBLIC_EXPONENT, 256, 4,
                                    0, 0, 0,
                                    0, 0, 0,
                                    0, 0, 0};
    #endif
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[512] = {0};
    uint8_t decrypt_result[512] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    //encode IN_AttributeID
    /*SharedMem1 filled with a concatenation of
    (uint_32)$IN_AttributeID_1$|(uint_32)offset of  $IN_Attrib_Value_1$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_1$|
    (uint_32)$IN_AttributeID_2$|(uint_32)offset of  $IN_Attrib_Value_2$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_2$|
    (uint_32)$IN_AttributeID_3$|(uint_32)offset of  $IN_Attrib_Value_3$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_3$|
    ... and so on*/
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_RSA_MODULUS), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+12, retrieveUint32toBuffer(TEE_ATTR_RSA_PUBLIC_EXPONENT), sizeof(uint32_t));
    memcpy(IN_AttributeID+16, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+20, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));
   memcpy(IN_AttributeID+24, retrieveUint32toBuffer(TEE_ATTR_RSA_PRIVATE_EXPONENT), sizeof(uint32_t)); //
    memcpy(IN_AttributeID+28, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));//
    memcpy(IN_AttributeID+32, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01)), sizeof(uint32_t));//
   memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    /*SharedMem2 filled with a concatenation of
    $IN_Attrib_Value_1$|$IN_Attrib_Value_2$|$IN_Attrib_Value_3$|$IN_Attrib_Value_4$|$IN_Attrib_Value_5$*/
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_RSA_MODULUS_VALUE01, sizeof(TEE_ATTR_RSA_MODULUS_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01), (void *)TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01), (void *)TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01));//

	//OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }

    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_RSA_KEYPAIR;
    operation.params[0].value.b = SIZE_RSA_KEYPAIR_2048/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
      operation.params[2].memref.size = sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)+sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01);//
 operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_InitObjectWithKeys failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //+++++++++++++++++++++encrypt++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_RSA_KEYPAIR_2048/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AllocateOperation failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_SetOperationKey failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_AsymmetricEncrypt
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1, sizeof(DATA_FOR_CRYPTO1));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = 512;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AsymmetricEncrypt, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AsymmetricEncrypt failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)encrypt_result, SharedMem2.buffer, 512);
    //++++++++++++++++++++++++decrypt+++++++++++++++++++++++++++++++

    //Invoke_Crypto_AsymmetricDecrypt
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)encrypt_result, sizeof(encrypt_result));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_INVALID;//OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = 512;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AsymmetricDecrypt, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke CMD_Crypto_AsymmetricDecrypt failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)decrypt_result, SharedMem2.buffer, 512);

    if(memcmp(DATA_FOR_CRYPTO1, decrypt_result, sizeof(DATA_FOR_CRYPTO1))){
        TEEC_Error("decrypt data is not equal to encrypt\n");
        for(i=0; i<sizeof(DATA_FOR_CRYPTO1); i++){
            TEEC_Error("DATA_FOR_CRYPTO1[%d] = %x, decrypt_Data[%d] = %x\n",
                i, DATA_FOR_CRYPTO1[i], i, *((uint8_t *)decrypt_result+i));
        }
        result = TEEC_ERROR_MAC_INVALID;
    }

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;
}


TEEC_Result Invoke_Crypto_AsymmetricDecrypt_no_key_programmed_01(uint32_t algorithm)
{

    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    #if 0
    uint32_t IN_AttributeID[] = {TEE_ATTR_RSA_MODULUS, 0, 256,
                                 TEE_ATTR_RSA_PUBLIC_EXPONENT, 256, 4,
                                    0, 0, 0,
                                    0, 0, 0,
                                    0, 0, 0};
    #endif
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[512] = {0};
    uint8_t decrypt_result[512] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    //encode IN_AttributeID
    /*SharedMem1 filled with a concatenation of
    (uint_32)$IN_AttributeID_1$|(uint_32)offset of  $IN_Attrib_Value_1$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_1$|
    (uint_32)$IN_AttributeID_2$|(uint_32)offset of  $IN_Attrib_Value_2$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_2$|
    (uint_32)$IN_AttributeID_3$|(uint_32)offset of  $IN_Attrib_Value_3$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_3$|
    ... and so on*/
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_RSA_MODULUS), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+12, retrieveUint32toBuffer(TEE_ATTR_RSA_PUBLIC_EXPONENT), sizeof(uint32_t));
    memcpy(IN_AttributeID+16, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+20, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    /*SharedMem2 filled with a concatenation of
    $IN_Attrib_Value_1$|$IN_Attrib_Value_2$|$IN_Attrib_Value_3$|$IN_Attrib_Value_4$|$IN_Attrib_Value_5$*/
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_RSA_MODULUS_VALUE01, sizeof(TEE_ATTR_RSA_MODULUS_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01), (void *)TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01));
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }

    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_RSA_PUBLIC_KEY;
    operation.params[0].value.b = SIZE_RSA_KEYPAIR_2048/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_InitObjectWithKeys failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //+++++++++++++++++++++encrypt++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_RSA_KEYPAIR_2048/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AllocateOperation failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_SetOperationKey failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_AsymmetricEncrypt
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1, sizeof(DATA_FOR_CRYPTO1));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = 512;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AsymmetricEncrypt, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AsymmetricEncrypt failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)encrypt_result, SharedMem2.buffer, 512);
    //++++++++++++++++++++++++decrypt+++++++++++++++++++++++++++++++
    //Invoke_Crypto_InitObjectWithKeys

    memset(SharedMem1.buffer, 0, BIG_SIZE);
    //encode IN_AttributeID
    /*SharedMem1 filled with a concatenation of
    (uint_32)$IN_AttributeID_1$|(uint_32)offset of  $IN_Attrib_Value_1$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_1$|
    (uint_32)$IN_AttributeID_2$|(uint_32)offset of  $IN_Attrib_Value_2$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_2$|
    (uint_32)$IN_AttributeID_3$|(uint_32)offset of  $IN_Attrib_Value_3$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_3$|
    ... and so on*/
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_RSA_MODULUS), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+12, retrieveUint32toBuffer(TEE_ATTR_RSA_PUBLIC_EXPONENT), sizeof(uint32_t));
    memcpy(IN_AttributeID+16, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+20, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+24, retrieveUint32toBuffer(TEE_ATTR_RSA_PRIVATE_EXPONENT), sizeof(uint32_t));
    memcpy(IN_AttributeID+28, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+32, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    /*SharedMem2 filled with a concatenation of
    $IN_Attrib_Value_1$|$IN_Attrib_Value_2$|$IN_Attrib_Value_3$|$IN_Attrib_Value_4$|$IN_Attrib_Value_5$*/
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_RSA_MODULUS_VALUE01, sizeof(TEE_ATTR_RSA_MODULUS_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01), (void *)TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01), (void *)TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01));

    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_RSA_KEYPAIR;
    operation.params[0].value.b = SIZE_RSA_KEYPAIR_2048/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)+sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_InitObjectWithKeys failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_DECRYPT;
    operation.params[1].value.a = SIZE_RSA_KEYPAIR_2048/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AllocateOperation failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AsymmetricDecrypt
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)encrypt_result, sizeof(encrypt_result));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = 512;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AsymmetricDecrypt, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke CMD_Crypto_AsymmetricDecrypt failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    } //TEE_ERROR_TARGET_DEADTEE_ERROR_NO_DATA = 0xFFFF000B
    memcpy((void *)decrypt_result, SharedMem2.buffer, 512);

    if(memcmp(DATA_FOR_CRYPTO1, decrypt_result, sizeof(DATA_FOR_CRYPTO1))){
        TEEC_Error("decrypt data is not equal to encrypt\n");
        for(i=0; i<sizeof(DATA_FOR_CRYPTO1); i++){
            TEEC_Error("DATA_FOR_CRYPTO1[%d] = %x, decrypt_Data[%d] = %x\n",
                i, DATA_FOR_CRYPTO1[i], i, *((uint8_t *)decrypt_result+i));
        }
        result = TEEC_ERROR_MAC_INVALID;
    }

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;
}


TEEC_Result Invoke_Crypto_AsymmetricDecrypt_short_buffer_01(uint32_t algorithm)
{

    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    #if 0
    uint32_t IN_AttributeID[] = {TEE_ATTR_RSA_MODULUS, 0, 256,
                                 TEE_ATTR_RSA_PUBLIC_EXPONENT, 256, 4,
                                    0, 0, 0,
                                    0, 0, 0,
                                    0, 0, 0};
    #endif
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[512] = {0};
    uint8_t decrypt_result[512] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    //encode IN_AttributeID
    /*SharedMem1 filled with a concatenation of
    (uint_32)$IN_AttributeID_1$|(uint_32)offset of  $IN_Attrib_Value_1$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_1$|
    (uint_32)$IN_AttributeID_2$|(uint_32)offset of  $IN_Attrib_Value_2$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_2$|
    (uint_32)$IN_AttributeID_3$|(uint_32)offset of  $IN_Attrib_Value_3$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_3$|
    ... and so on*/
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_RSA_MODULUS), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+12, retrieveUint32toBuffer(TEE_ATTR_RSA_PUBLIC_EXPONENT), sizeof(uint32_t));
    memcpy(IN_AttributeID+16, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+20, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));
memcpy(IN_AttributeID+24, retrieveUint32toBuffer(TEE_ATTR_RSA_PRIVATE_EXPONENT), sizeof(uint32_t)); //
    memcpy(IN_AttributeID+28, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));//
    memcpy(IN_AttributeID+32, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01)), sizeof(uint32_t));//

	memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    /*SharedMem2 filled with a concatenation of
    $IN_Attrib_Value_1$|$IN_Attrib_Value_2$|$IN_Attrib_Value_3$|$IN_Attrib_Value_4$|$IN_Attrib_Value_5$*/
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_RSA_MODULUS_VALUE01, sizeof(TEE_ATTR_RSA_MODULUS_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01), (void *)TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01));
  memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01), (void *)TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01));//

	//OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }

    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_RSA_KEYPAIR;
    operation.params[0].value.b = SIZE_RSA_KEYPAIR_2048/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
      operation.params[2].memref.size = sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)+sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01);//
  operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_InitObjectWithKeys failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //+++++++++++++++++++++encrypt++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_RSA_KEYPAIR_2048/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AllocateOperation failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_SetOperationKey failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_AsymmetricEncrypt
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1, sizeof(DATA_FOR_CRYPTO1));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = 512;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AsymmetricEncrypt, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AsymmetricEncrypt failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)encrypt_result, SharedMem2.buffer, 512);
    //++++++++++++++++++++++++decrypt+++++++++++++++++++++++++++++++
    //Invoke_Crypto_InitObjectWithKeys

    memset(SharedMem1.buffer, 0, BIG_SIZE);
    //encode IN_AttributeID
    /*SharedMem1 filled with a concatenation of
    (uint_32)$IN_AttributeID_1$|(uint_32)offset of  $IN_Attrib_Value_1$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_1$|
    (uint_32)$IN_AttributeID_2$|(uint_32)offset of  $IN_Attrib_Value_2$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_2$|
    (uint_32)$IN_AttributeID_3$|(uint_32)offset of  $IN_Attrib_Value_3$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_3$|
    ... and so on*/
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_RSA_MODULUS), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+12, retrieveUint32toBuffer(TEE_ATTR_RSA_PUBLIC_EXPONENT), sizeof(uint32_t));
    memcpy(IN_AttributeID+16, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+20, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+24, retrieveUint32toBuffer(TEE_ATTR_RSA_PRIVATE_EXPONENT), sizeof(uint32_t));
    memcpy(IN_AttributeID+28, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+32, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    /*SharedMem2 filled with a concatenation of
    $IN_Attrib_Value_1$|$IN_Attrib_Value_2$|$IN_Attrib_Value_3$|$IN_Attrib_Value_4$|$IN_Attrib_Value_5$*/
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_RSA_MODULUS_VALUE01, sizeof(TEE_ATTR_RSA_MODULUS_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01), (void *)TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01), (void *)TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01));

    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_RSA_KEYPAIR;
    operation.params[0].value.b = SIZE_RSA_KEYPAIR_2048/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)+sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_InitObjectWithKeys failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_DECRYPT;
    operation.params[1].value.a = SIZE_RSA_KEYPAIR_2048/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AllocateOperation failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_SetOperationKey failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_AsymmetricDecrypt
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)encrypt_result, sizeof(encrypt_result));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = 1;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AsymmetricDecrypt, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AsymmetricDecrypt failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)decrypt_result, SharedMem2.buffer, 512);

    if(memcmp(DATA_FOR_CRYPTO1, decrypt_result, sizeof(DATA_FOR_CRYPTO1))){
        TEEC_Error("decrypt data is not equal to encrypt\n");
        for(i=0; i<sizeof(DATA_FOR_CRYPTO1); i++){
            TEEC_Error("DATA_FOR_CRYPTO1[%d] = %x, decrypt_Data[%d] = %x\n",
                i, DATA_FOR_CRYPTO1[i], i, *((uint8_t *)decrypt_result+i));
        }
        result = TEEC_ERROR_MAC_INVALID;
    }

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;
}


TEEC_Result Invoke_Crypto_AsymmetricEncrypt_incompatible_mode_01(uint32_t algorithm)
{

    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    #if 0
    uint32_t IN_AttributeID[] = {TEE_ATTR_RSA_MODULUS, 0, 256,
                                 TEE_ATTR_RSA_PUBLIC_EXPONENT, 256, 4,
                                    0, 0, 0,
                                    0, 0, 0,
                                    0, 0, 0};
    #endif
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[512] = {0};
    uint8_t decrypt_result[512] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    //encode IN_AttributeID
    /*SharedMem1 filled with a concatenation of
    (uint_32)$IN_AttributeID_1$|(uint_32)offset of  $IN_Attrib_Value_1$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_1$|
    (uint_32)$IN_AttributeID_2$|(uint_32)offset of  $IN_Attrib_Value_2$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_2$|
    (uint_32)$IN_AttributeID_3$|(uint_32)offset of  $IN_Attrib_Value_3$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_3$|
    ... and so on*/
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_RSA_MODULUS), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+12, retrieveUint32toBuffer(TEE_ATTR_RSA_PUBLIC_EXPONENT), sizeof(uint32_t));
    memcpy(IN_AttributeID+16, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+20, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));
memcpy(IN_AttributeID+24, retrieveUint32toBuffer(TEE_ATTR_RSA_PRIVATE_EXPONENT), sizeof(uint32_t)); //
    memcpy(IN_AttributeID+28, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));//
    memcpy(IN_AttributeID+32, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01)), sizeof(uint32_t));//

	memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    /*SharedMem2 filled with a concatenation of
    $IN_Attrib_Value_1$|$IN_Attrib_Value_2$|$IN_Attrib_Value_3$|$IN_Attrib_Value_4$|$IN_Attrib_Value_5$*/
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_RSA_MODULUS_VALUE01, sizeof(TEE_ATTR_RSA_MODULUS_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01), (void *)TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01));
memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01), (void *)TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01));//

	//OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }

    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_RSA_KEYPAIR;
    operation.params[0].value.b = SIZE_RSA_KEYPAIR_2048/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
   operation.params[2].memref.size = sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)+sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01);//
     operation.params[3].value.a = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_InitObjectWithKeys failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //+++++++++++++++++++++encrypt++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_DECRYPT;
    operation.params[1].value.a = SIZE_RSA_KEYPAIR_2048/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AllocateOperation failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_SetOperationKey failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_AsymmetricEncrypt
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1, sizeof(DATA_FOR_CRYPTO1));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = 512;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AsymmetricEncrypt, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke CMD_Crypto_AsymmetricEncrypt failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)encrypt_result, SharedMem2.buffer, 512);
    //++++++++++++++++++++++++decrypt+++++++++++++++++++++++++++++++


cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;
}


TEEC_Result Invoke_Crypto_AsymmetricEncrypt_invalid_operation_class_01(uint32_t algorithm)
{

    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    #if 0
    uint32_t IN_AttributeID[] = {TEE_ATTR_RSA_MODULUS, 0, 256,
                                 TEE_ATTR_RSA_PUBLIC_EXPONENT, 256, 4,
                                    0, 0, 0,
                                    0, 0, 0,
                                    0, 0, 0};
    #endif
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[512] = {0};
    uint8_t decrypt_result[512] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    //encode IN_AttributeID
    /*SharedMem1 filled with a concatenation of
    (uint_32)$IN_AttributeID_1$|(uint_32)offset of  $IN_Attrib_Value_1$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_1$|
    (uint_32)$IN_AttributeID_2$|(uint_32)offset of  $IN_Attrib_Value_2$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_2$|
    (uint_32)$IN_AttributeID_3$|(uint_32)offset of  $IN_Attrib_Value_3$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_3$|
    ... and so on*/
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_RSA_MODULUS), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+12, retrieveUint32toBuffer(TEE_ATTR_RSA_PUBLIC_EXPONENT), sizeof(uint32_t));
    memcpy(IN_AttributeID+16, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+20, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    /*SharedMem2 filled with a concatenation of
    $IN_Attrib_Value_1$|$IN_Attrib_Value_2$|$IN_Attrib_Value_3$|$IN_Attrib_Value_4$|$IN_Attrib_Value_5$*/
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_RSA_MODULUS_VALUE01, sizeof(TEE_ATTR_RSA_MODULUS_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01), (void *)TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01));
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }


    //+++++++++++++++++++++encrypt++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_ZERO + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test  invoke CMD_Crypto_AllocateOperation failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }//TEE_ERROR_TARGET_DEADTEE_ERROR_NOT_IMPLEMENTED = 0xFFFF0009

    //Invoke_Crypto_AsymmetricEncrypt
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1, sizeof(DATA_FOR_CRYPTO1));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = 512;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AsymmetricEncrypt, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("2 invoke CMD_Crypto_AsymmetricEncrypt failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)encrypt_result, SharedMem2.buffer, 512);


cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;
}


TEEC_Result Invoke_Crypto_AsymmetricEncrypt_invalid_value_handle_01(uint32_t algorithm)
{

    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    #if 0
    uint32_t IN_AttributeID[] = {TEE_ATTR_RSA_MODULUS, 0, 256,
                                 TEE_ATTR_RSA_PUBLIC_EXPONENT, 256, 4,
                                    0, 0, 0,
                                    0, 0, 0,
                                    0, 0, 0};
    #endif
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[512] = {0};
    uint8_t decrypt_result[512] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    //encode IN_AttributeID
    /*SharedMem1 filled with a concatenation of
    (uint_32)$IN_AttributeID_1$|(uint_32)offset of  $IN_Attrib_Value_1$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_1$|
    (uint_32)$IN_AttributeID_2$|(uint_32)offset of  $IN_Attrib_Value_2$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_2$|
    (uint_32)$IN_AttributeID_3$|(uint_32)offset of  $IN_Attrib_Value_3$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_3$|
    ... and so on*/
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_RSA_MODULUS), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+12, retrieveUint32toBuffer(TEE_ATTR_RSA_PUBLIC_EXPONENT), sizeof(uint32_t));
    memcpy(IN_AttributeID+16, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+20, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    /*SharedMem2 filled with a concatenation of
    $IN_Attrib_Value_1$|$IN_Attrib_Value_2$|$IN_Attrib_Value_3$|$IN_Attrib_Value_4$|$IN_Attrib_Value_5$*/
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_RSA_MODULUS_VALUE01, sizeof(TEE_ATTR_RSA_MODULUS_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01), (void *)TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01));
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }

    //Invoke_Crypto_AsymmetricEncrypt
    operation.started = 1;
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1, sizeof(DATA_FOR_CRYPTO1));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_INVALID;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = 512;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AsymmetricEncrypt, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke CMD_Crypto_AsymmetricEncrypt failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }//TEE_ERROR_TARGET_DEADTEE_ERROR_NOT_IMPLEMENTED = 0xFFFF0009
    memcpy((void *)encrypt_result, SharedMem2.buffer, 512);

cleanup_4:
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;
}


TEEC_Result Invoke_Crypto_AsymmetricEncrypt_no_key_programmed_01(uint32_t algorithm)
{

    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    #if 0
    uint32_t IN_AttributeID[] = {TEE_ATTR_RSA_MODULUS, 0, 256,
                                 TEE_ATTR_RSA_PUBLIC_EXPONENT, 256, 4,
                                    0, 0, 0,
                                    0, 0, 0,
                                    0, 0, 0};
    #endif
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[512] = {0};
    uint8_t decrypt_result[512] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    //encode IN_AttributeID
    /*SharedMem1 filled with a concatenation of
    (uint_32)$IN_AttributeID_1$|(uint_32)offset of  $IN_Attrib_Value_1$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_1$|
    (uint_32)$IN_AttributeID_2$|(uint_32)offset of  $IN_Attrib_Value_2$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_2$|
    (uint_32)$IN_AttributeID_3$|(uint_32)offset of  $IN_Attrib_Value_3$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_3$|
    ... and so on*/
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_RSA_MODULUS), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+12, retrieveUint32toBuffer(TEE_ATTR_RSA_PUBLIC_EXPONENT), sizeof(uint32_t));
    memcpy(IN_AttributeID+16, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+20, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    /*SharedMem2 filled with a concatenation of
    $IN_Attrib_Value_1$|$IN_Attrib_Value_2$|$IN_Attrib_Value_3$|$IN_Attrib_Value_4$|$IN_Attrib_Value_5$*/
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_RSA_MODULUS_VALUE01, sizeof(TEE_ATTR_RSA_MODULUS_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01), (void *)TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01));
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }

    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_RSA_PUBLIC_KEY;
    operation.params[0].value.b = SIZE_RSA_KEYPAIR_2048/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("1 invoke CMD_Crypto_InitObjectWithKeys failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //+++++++++++++++++++++encrypt++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_RSA_KEYPAIR_2048/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("2 invoke CMD_Crypto_AllocateOperation failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //Invoke_Crypto_AsymmetricEncrypt
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1, sizeof(DATA_FOR_CRYPTO1));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = 512;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AsymmetricEncrypt, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test  invoke CMD_Crypto_AsymmetricEncrypt failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    } //TEE_ERROR_TARGET_DEADTEE_ERROR_NO_DATA = 0xFFFF000B
    memcpy((void *)encrypt_result, SharedMem2.buffer, 512);

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;
}


TEEC_Result Invoke_Crypto_AsymmetricEncrypt_short_buffer_01(uint32_t algorithm)
{

    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    #if 0
    uint32_t IN_AttributeID[] = {TEE_ATTR_RSA_MODULUS, 0, 256,
                                 TEE_ATTR_RSA_PUBLIC_EXPONENT, 256, 4,
                                    0, 0, 0,
                                    0, 0, 0,
                                    0, 0, 0};
    #endif
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[512] = {0};
    uint8_t decrypt_result[512] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    //encode IN_AttributeID
    /*SharedMem1 filled with a concatenation of
    (uint_32)$IN_AttributeID_1$|(uint_32)offset of  $IN_Attrib_Value_1$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_1$|
    (uint_32)$IN_AttributeID_2$|(uint_32)offset of  $IN_Attrib_Value_2$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_2$|
    (uint_32)$IN_AttributeID_3$|(uint_32)offset of  $IN_Attrib_Value_3$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_3$|
    ... and so on*/
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_RSA_MODULUS), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+12, retrieveUint32toBuffer(TEE_ATTR_RSA_PUBLIC_EXPONENT), sizeof(uint32_t));
    memcpy(IN_AttributeID+16, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+20, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));
 memcpy(IN_AttributeID+24, retrieveUint32toBuffer(TEE_ATTR_RSA_PRIVATE_EXPONENT), sizeof(uint32_t)); //
    memcpy(IN_AttributeID+28, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));//
    memcpy(IN_AttributeID+32, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01)), sizeof(uint32_t));//

	memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    /*SharedMem2 filled with a concatenation of
    $IN_Attrib_Value_1$|$IN_Attrib_Value_2$|$IN_Attrib_Value_3$|$IN_Attrib_Value_4$|$IN_Attrib_Value_5$*/
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_RSA_MODULUS_VALUE01, sizeof(TEE_ATTR_RSA_MODULUS_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01), (void *)TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01));
 memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01), (void *)TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01));//

	//OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }

    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_RSA_KEYPAIR;
    operation.params[0].value.b = SIZE_RSA_KEYPAIR_2048/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
     operation.params[2].memref.size = sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)+sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01);//
    operation.params[3].value.a = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_InitObjectWithKeys failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //+++++++++++++++++++++encrypt++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_RSA_KEYPAIR_2048/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AllocateOperation failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_SetOperationKey failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_AsymmetricEncrypt
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1, sizeof(DATA_FOR_CRYPTO1));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = 1;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AsymmetricEncrypt, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AsymmetricEncrypt failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)encrypt_result, SharedMem2.buffer, 512);

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;
}


TEEC_Result Invoke_Crypto_AsymmetricSignDigest_TEE_ALG_RSASSA_PKCS1(uint32_t algorithm, uint32_t hash_algorithm)
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint32_t hash_len;
    uint8_t *hash_result = NULL;
    switch(hash_algorithm)
    {
        case TEE_ALG_SHA1:
        {
            hash_len = 20;
            break;
        }
        case TEE_ALG_SHA224:
        {
            hash_len = 28;
            break;
        }
        case TEE_ALG_SHA256:
        {
            hash_len = 32;
            break;
        }
        case TEE_ALG_SHA384:
        {
            hash_len = 48;
            break;
        }
        case TEE_ALG_SHA512:
        {
            hash_len = 64;
            break;
        }
        default:
        {
            break;
        }
    }
    hash_result = (uint8_t *)malloc(hash_len);
    memset(hash_result, 0, hash_len);
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = hash_algorithm;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_ZERO + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AllocateOperation failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_DigestUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    memcpy(SharedMem1.buffer+sizeof(DATA_FOR_CRYPTO1_PART1), (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1)+sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_DigestUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_DigestUpdate1 failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    #if 0
    //Invoke_Crypto_DigestUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_DigestUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_DigestUpdate2 failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    #endif
    //Invoke_Crypto_DigestDoFinal
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_DigestDoFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_DigestDoFinal failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //compare hash result
    #if 0
    if(memcmp(hash_result, SharedMem2.buffer, hash_len)){
        TEEC_Error("digest result is wrong!!\n");
        for(i=0; i<hash_len; i++){
            TEEC_Error("hash_result[%d] = %x, digest[%d] = %x\n",
                i, hash_result[i], i, *((uint8_t *)SharedMem2.buffer+i));
        }
        result = TEEC_ERROR_MAC_INVALID;
    }
    #endif
    memcpy(hash_result, SharedMem2.buffer, hash_len);

    //Invoke_Crypto_InitObjectWithKeys
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    //encode IN_AttributeID
    /*SharedMem1 filled with a concatenation of
    (uint_32)$IN_AttributeID_1$|(uint_32)offset of  $IN_Attrib_Value_1$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_1$|
    (uint_32)$IN_AttributeID_2$|(uint_32)offset of  $IN_Attrib_Value_2$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_2$|
    (uint_32)$IN_AttributeID_3$|(uint_32)offset of  $IN_Attrib_Value_3$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_3$|
    ... and so on*/
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_RSA_MODULUS), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+12, retrieveUint32toBuffer(TEE_ATTR_RSA_PUBLIC_EXPONENT), sizeof(uint32_t));
    memcpy(IN_AttributeID+16, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+20, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+24, retrieveUint32toBuffer(TEE_ATTR_RSA_PRIVATE_EXPONENT), sizeof(uint32_t));
    memcpy(IN_AttributeID+28, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+32, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    /*SharedMem2 filled with a concatenation of
    $IN_Attrib_Value_1$|$IN_Attrib_Value_2$|$IN_Attrib_Value_3$|$IN_Attrib_Value_4$|$IN_Attrib_Value_5$*/
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_RSA_MODULUS_VALUE01, sizeof(TEE_ATTR_RSA_MODULUS_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01), (void *)TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01), (void *)TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01));

    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_RSA_KEYPAIR;
    operation.params[0].value.b = SIZE_RSA_KEYPAIR_2048/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)+sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_InitObjectWithKeys failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_SIGN;
    operation.params[1].value.a = SIZE_RSA_KEYPAIR_2048/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AllocateOperation failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_SetOperationKey failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_AsymmetricSignDigest
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)hash_result, hash_len);
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = hash_len;
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = 512;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AsymmetricSignDigest, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AsymmetricSignDigest failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(sign, SharedMem2.buffer, operation.params[3].memref.size);
cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_FreeAllKeysAndOperations1 failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_FreeAllKeysAndOperations2 failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    if(hash_result)
        free(hash_result);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}


TEEC_Result Invoke_Crypto_AsymmetricVerifyDigest_TEE_ALG_RSASSA_PKCS1(uint32_t algorithm, uint32_t hash_algorithm)
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint32_t hash_len;
    uint8_t *hash_result = NULL;
    switch(hash_algorithm)
    {
        case TEE_ALG_SHA1:
        {
            hash_len = 20;
            break;
        }
        case TEE_ALG_SHA224:
        {
            hash_len = 28;
            break;
        }
        case TEE_ALG_SHA256:
        {
            hash_len = 32;
            break;
        }
        case TEE_ALG_SHA384:
        {
            hash_len = 48;
            break;
        }
        case TEE_ALG_SHA512:
        {
            hash_len = 64;
            break;
        }
        default:
        {
            break;
        }
    }
    hash_result = (uint8_t *)malloc(hash_len);
    memset(hash_result, 0, hash_len);

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = hash_algorithm;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_ZERO + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_DigestUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    memcpy(SharedMem1.buffer+sizeof(DATA_FOR_CRYPTO1_PART1), (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1)+sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_DigestUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    #if 0
    //Invoke_Crypto_DigestUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_DigestUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    #endif
    //Invoke_Crypto_DigestDoFinal
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_DigestDoFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //compare hash result
#if 0
    if(memcmp(hash_result, SharedMem2.buffer, hash_len)){
        TEEC_Error("digest result is wrong!!\n");
        for(i=0; i<hash_len; i++){
            TEEC_Error("hash_result[%d] = %x, digest[%d] = %x\n",
                i, hash_result[i], i, *((uint8_t *)SharedMem2.buffer+i));
        }
        result = TEEC_ERROR_MAC_INVALID;
    }
#endif
    memcpy(hash_result, SharedMem2.buffer, hash_len);

    //Invoke_Crypto_InitObjectWithKeys
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    //encode IN_AttributeID
    /*SharedMem1 filled with a concatenation of
    (uint_32)$IN_AttributeID_1$|(uint_32)offset of  $IN_Attrib_Value_1$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_1$|
    (uint_32)$IN_AttributeID_2$|(uint_32)offset of  $IN_Attrib_Value_2$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_2$|
    (uint_32)$IN_AttributeID_3$|(uint_32)offset of  $IN_Attrib_Value_3$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_3$|
    ... and so on*/
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_RSA_MODULUS), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+12, retrieveUint32toBuffer(TEE_ATTR_RSA_PUBLIC_EXPONENT), sizeof(uint32_t));
    memcpy(IN_AttributeID+16, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+20, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    /*SharedMem2 filled with a concatenation of
    $IN_Attrib_Value_1$|$IN_Attrib_Value_2$|$IN_Attrib_Value_3$|$IN_Attrib_Value_4$|$IN_Attrib_Value_5$*/
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_RSA_MODULUS_VALUE01, sizeof(TEE_ATTR_RSA_MODULUS_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01), (void *)TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01));

    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_RSA_PUBLIC_KEY;
    operation.params[0].value.b = SIZE_RSA_KEYPAIR_2048/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)+sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_VERIFY;
    operation.params[1].value.a = SIZE_RSA_KEYPAIR_2048/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_AsymmetricVerifyDigest
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)hash_result, hash_len);
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, sign, 256);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_INPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = hash_len;
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = 256;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AsymmetricVerifyDigest, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    if(hash_result)
        free(hash_result);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;
}



TEEC_Result Invoke_Crypto_AsymmetricSignDigest_TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384_Success_01(uint32_t algorithm, uint32_t hash_algorithm)
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint32_t hash_len;
    uint8_t *hash_result = NULL;
    switch(hash_algorithm)
    {
        case TEE_ALG_SHA1:
        {
            hash_len = 20;
            break;
        }
        case TEE_ALG_SHA224:
        {
            hash_len = 28;
            break;
        }
        case TEE_ALG_SHA256:
        {
            hash_len = 32;
            break;
        }
        case TEE_ALG_SHA384:
        {
            hash_len = 48;
            break;
        }
        case TEE_ALG_SHA512:
        {
            hash_len = 64;
            break;
        }
        default:
        {
            break;
        }
    }
    hash_result = (uint8_t *)malloc(hash_len);
    memset(hash_result, 0, hash_len);
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = hash_algorithm;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_ZERO + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AllocateOperation failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //Invoke_Crypto_DigestDoFinal
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1, sizeof(DATA_FOR_CRYPTO1));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_DigestDoFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_DigestDoFinal failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //compare hash result
    #if 0
    if(memcmp(hash_result, SharedMem2.buffer, hash_len)){
        TEEC_Error("digest result is wrong!!\n");
        for(i=0; i<hash_len; i++){
            TEEC_Error("hash_result[%d] = %x, digest[%d] = %x\n",
                i, hash_result[i], i, *((uint8_t *)SharedMem2.buffer+i));
        }
        result = TEEC_ERROR_MAC_INVALID;
    }
    #endif
    memcpy(hash_result, SharedMem2.buffer, hash_len);

    //Invoke_Crypto_InitObjectWithKeys
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    //encode IN_AttributeID
    /*SharedMem1 filled with a concatenation of
    (uint_32)$IN_AttributeID_1$|(uint_32)offset of  $IN_Attrib_Value_1$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_1$|
    (uint_32)$IN_AttributeID_2$|(uint_32)offset of  $IN_Attrib_Value_2$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_2$|
    (uint_32)$IN_AttributeID_3$|(uint_32)offset of  $IN_Attrib_Value_3$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_3$|
    ... and so on*/
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_RSA_MODULUS), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+12, retrieveUint32toBuffer(TEE_ATTR_RSA_PUBLIC_EXPONENT), sizeof(uint32_t));
    memcpy(IN_AttributeID+16, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+20, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+24, retrieveUint32toBuffer(TEE_ATTR_RSA_PRIVATE_EXPONENT), sizeof(uint32_t));
    memcpy(IN_AttributeID+28, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+32, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    /*SharedMem2 filled with a concatenation of
    $IN_Attrib_Value_1$|$IN_Attrib_Value_2$|$IN_Attrib_Value_3$|$IN_Attrib_Value_4$|$IN_Attrib_Value_5$*/
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_RSA_MODULUS_VALUE01, sizeof(TEE_ATTR_RSA_MODULUS_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01), (void *)TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01), (void *)TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01));

    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_RSA_KEYPAIR;
    operation.params[0].value.b = SIZE_RSA_KEYPAIR_2048/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)+sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_InitObjectWithKeys failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_SIGN;
    operation.params[1].value.a = SIZE_RSA_KEYPAIR_2048/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AllocateOperation failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_SetOperationKey failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_AsymmetricSignDigest
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)hash_result, hash_len);
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = hash_len;
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = 512;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AsymmetricSignDigest, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AsymmetricSignDigest failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(sign, SharedMem2.buffer, operation.params[3].memref.size);
cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_FreeAllKeysAndOperations1 failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_FreeAllKeysAndOperations2 failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    if(hash_result)
        free(hash_result);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}



TEEC_Result Invoke_Crypto_AsymmetricVerifyDigest_TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384_Success_01(uint32_t algorithm, uint32_t hash_algorithm)
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint32_t hash_len;
    uint8_t *hash_result = NULL;
    switch(hash_algorithm)
    {
        case TEE_ALG_SHA1:
        {
            hash_len = 20;
            break;
        }
        case TEE_ALG_SHA224:
        {
            hash_len = 28;
            break;
        }
        case TEE_ALG_SHA256:
        {
            hash_len = 32;
            break;
        }
        case TEE_ALG_SHA384:
        {
            hash_len = 48;
            break;
        }
        case TEE_ALG_SHA512:
        {
            hash_len = 64;
            break;
        }
        default:
        {
            break;
        }
    }
    hash_result = (uint8_t *)malloc(hash_len);
    memset(hash_result, 0, hash_len);

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = hash_algorithm;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_ZERO + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //Invoke_Crypto_DigestDoFinal
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1, sizeof(DATA_FOR_CRYPTO1));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_DigestDoFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //compare hash result
#if 0
    if(memcmp(hash_result, SharedMem2.buffer, hash_len)){
        TEEC_Error("digest result is wrong!!\n");
        for(i=0; i<hash_len; i++){
            TEEC_Error("hash_result[%d] = %x, digest[%d] = %x\n",
                i, hash_result[i], i, *((uint8_t *)SharedMem2.buffer+i));
        }
        result = TEEC_ERROR_MAC_INVALID;
    }
#endif
    memcpy(hash_result, SharedMem2.buffer, hash_len);

    //Invoke_Crypto_InitObjectWithKeys
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    //encode IN_AttributeID
    /*SharedMem1 filled with a concatenation of
    (uint_32)$IN_AttributeID_1$|(uint_32)offset of  $IN_Attrib_Value_1$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_1$|
    (uint_32)$IN_AttributeID_2$|(uint_32)offset of  $IN_Attrib_Value_2$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_2$|
    (uint_32)$IN_AttributeID_3$|(uint_32)offset of  $IN_Attrib_Value_3$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_3$|
    ... and so on*/
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_RSA_MODULUS), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+12, retrieveUint32toBuffer(TEE_ATTR_RSA_PUBLIC_EXPONENT), sizeof(uint32_t));
    memcpy(IN_AttributeID+16, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+20, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    /*SharedMem2 filled with a concatenation of
    $IN_Attrib_Value_1$|$IN_Attrib_Value_2$|$IN_Attrib_Value_3$|$IN_Attrib_Value_4$|$IN_Attrib_Value_5$*/
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_RSA_MODULUS_VALUE01, sizeof(TEE_ATTR_RSA_MODULUS_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01), (void *)TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01));

    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_RSA_PUBLIC_KEY;
    operation.params[0].value.b = SIZE_RSA_KEYPAIR_2048/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)+sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_VERIFY;
    operation.params[1].value.a = SIZE_RSA_KEYPAIR_2048/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_AsymmetricVerifyDigest
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)hash_result, hash_len);
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, sign, 256);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_INPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = hash_len;
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = 256;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AsymmetricVerifyDigest, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    if(hash_result)
        free(hash_result);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;
}



TEEC_Result Invoke_Crypto_AsymmetricSignDigest_incompatible_mode_01(uint32_t algorithm, uint32_t hash_algorithm)
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint32_t hash_len;
    uint8_t *hash_result = NULL;
    switch(hash_algorithm)
    {
        case TEE_ALG_SHA1:
        {
            hash_len = 20;
            break;
        }
        case TEE_ALG_SHA224:
        {
            hash_len = 28;
            break;
        }
        case TEE_ALG_SHA256:
        {
            hash_len = 32;
            break;
        }
        case TEE_ALG_SHA384:
        {
            hash_len = 48;
            break;
        }
        case TEE_ALG_SHA512:
        {
            hash_len = 64;
            break;
        }
        default:
        {
            break;
        }
    }
    hash_result = (uint8_t *)malloc(hash_len);
    memset(hash_result, 0, hash_len);
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = hash_algorithm;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_ZERO + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AllocateOperation failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_DigestUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    memcpy(SharedMem1.buffer+sizeof(DATA_FOR_CRYPTO1_PART1), (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1)+sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_DigestUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_DigestUpdate1 failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    #if 0
    //Invoke_Crypto_DigestUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_DigestUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_DigestUpdate2 failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    #endif
    //Invoke_Crypto_DigestDoFinal
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_DigestDoFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_DigestDoFinal failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //compare hash result
    #if 0
    if(memcmp(hash_result, SharedMem2.buffer, hash_len)){
        TEEC_Error("digest result is wrong!!\n");
        for(i=0; i<hash_len; i++){
            TEEC_Error("hash_result[%d] = %x, digest[%d] = %x\n",
                i, hash_result[i], i, *((uint8_t *)SharedMem2.buffer+i));
        }
        result = TEEC_ERROR_MAC_INVALID;
    }
    #endif
    memcpy(hash_result, SharedMem2.buffer, hash_len);

    //Invoke_Crypto_InitObjectWithKeys
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    //encode IN_AttributeID
    /*SharedMem1 filled with a concatenation of
    (uint_32)$IN_AttributeID_1$|(uint_32)offset of  $IN_Attrib_Value_1$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_1$|
    (uint_32)$IN_AttributeID_2$|(uint_32)offset of  $IN_Attrib_Value_2$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_2$|
    (uint_32)$IN_AttributeID_3$|(uint_32)offset of  $IN_Attrib_Value_3$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_3$|
    ... and so on*/
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_RSA_MODULUS), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+12, retrieveUint32toBuffer(TEE_ATTR_RSA_PUBLIC_EXPONENT), sizeof(uint32_t));
    memcpy(IN_AttributeID+16, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+20, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+24, retrieveUint32toBuffer(TEE_ATTR_RSA_PRIVATE_EXPONENT), sizeof(uint32_t));
    memcpy(IN_AttributeID+28, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+32, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    /*SharedMem2 filled with a concatenation of
    $IN_Attrib_Value_1$|$IN_Attrib_Value_2$|$IN_Attrib_Value_3$|$IN_Attrib_Value_4$|$IN_Attrib_Value_5$*/
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_RSA_MODULUS_VALUE01, sizeof(TEE_ATTR_RSA_MODULUS_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01), (void *)TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01), (void *)TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01));

    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_RSA_KEYPAIR;
    operation.params[0].value.b = SIZE_RSA_KEYPAIR_2048/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)+sizeof(TEE_ATTR_RSA_PRIVATE_EXPONENT_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_InitObjectWithKeys failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_VERIFY;//TEE_MODE_SIGN;
    operation.params[1].value.a = SIZE_RSA_KEYPAIR_2048/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AllocateOperation failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_SetOperationKey failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_AsymmetricSignDigest
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)hash_result, hash_len);
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = hash_len;
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = 512;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AsymmetricSignDigest, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AsymmetricSignDigest failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(sign, SharedMem2.buffer, operation.params[3].memref.size);
cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    if(hash_result)
        free(hash_result);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}




TEEC_Result Invoke_Crypto_AsymmetricSignDigest_invalid_operation_class_01(uint32_t algorithm, uint32_t hash_algorithm)
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint32_t hash_len;
    uint8_t *hash_result = NULL;
    switch(hash_algorithm)
    {
        case TEE_ALG_SHA1:
        {
            hash_len = 20;
            break;
        }
        case TEE_ALG_SHA224:
        {
            hash_len = 28;
            break;
        }
        case TEE_ALG_SHA256:
        {
            hash_len = 32;
            break;
        }
        case TEE_ALG_SHA384:
        {
            hash_len = 48;
            break;
        }
        case TEE_ALG_SHA512:
        {
            hash_len = 64;
            break;
        }
        default:
        {
            break;
        }
    }
    hash_result = (uint8_t *)malloc(hash_len);
    memset(hash_result, 0, hash_len);
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = hash_algorithm;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_ZERO + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AllocateOperation failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_DigestUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    memcpy(SharedMem1.buffer+sizeof(DATA_FOR_CRYPTO1_PART1), (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1)+sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_DigestUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_DigestUpdate1 failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    #if 0
    //Invoke_Crypto_DigestUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_DigestUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_DigestUpdate2 failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    #endif
    //Invoke_Crypto_DigestDoFinal
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_DigestDoFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_DigestDoFinal failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //compare hash result
    #if 0
    if(memcmp(hash_result, SharedMem2.buffer, hash_len)){
        TEEC_Error("digest result is wrong!!\n");
        for(i=0; i<hash_len; i++){
            TEEC_Error("hash_result[%d] = %x, digest[%d] = %x\n",
                i, hash_result[i], i, *((uint8_t *)SharedMem2.buffer+i));
        }
        result = TEEC_ERROR_MAC_INVALID;
    }
    #endif
    memcpy(hash_result, SharedMem2.buffer, hash_len);

    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_DIGEST;//TEE_MODE_SIGN;
    operation.params[1].value.a = SIZE_ZERO + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AllocateOperation failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //Invoke_Crypto_AsymmetricSignDigest
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)hash_result, hash_len);
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = hash_len;
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = 512;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AsymmetricSignDigest, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AsymmetricSignDigest failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(sign, SharedMem2.buffer, operation.params[3].memref.size);
cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    if(hash_result)
        free(hash_result);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}



TEEC_Result Invoke_Crypto_AsymmetricSignDigest_invalid_value_handle_01(uint32_t algorithm, uint32_t hash_algorithm)
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint32_t hash_len;
    uint8_t *hash_result = NULL;
    switch(hash_algorithm)
    {
        case TEE_ALG_SHA1:
        {
            hash_len = 20;
            break;
        }
        case TEE_ALG_SHA224:
        {
            hash_len = 28;
            break;
        }
        case TEE_ALG_SHA256:
        {
            hash_len = 32;
            break;
        }
        case TEE_ALG_SHA384:
        {
            hash_len = 48;
            break;
        }
        case TEE_ALG_SHA512:
        {
            hash_len = 64;
            break;
        }
        default:
        {
            break;
        }
    }
    hash_result = (uint8_t *)malloc(hash_len);
    memset(hash_result, 0, hash_len);
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = hash_algorithm;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_ZERO + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AllocateOperation failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_DigestUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    memcpy(SharedMem1.buffer+sizeof(DATA_FOR_CRYPTO1_PART1), (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1)+sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_DigestUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_DigestUpdate1 failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    #if 0
    //Invoke_Crypto_DigestUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_DigestUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_DigestUpdate2 failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    #endif
    //Invoke_Crypto_DigestDoFinal
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_DigestDoFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_DigestDoFinal failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //compare hash result
    #if 0
    if(memcmp(hash_result, SharedMem2.buffer, hash_len)){
        TEEC_Error("digest result is wrong!!\n");
        for(i=0; i<hash_len; i++){
            TEEC_Error("hash_result[%d] = %x, digest[%d] = %x\n",
                i, hash_result[i], i, *((uint8_t *)SharedMem2.buffer+i));
        }
        result = TEEC_ERROR_MAC_INVALID;
    }
    #endif
    memcpy(hash_result, SharedMem2.buffer, hash_len);

    //Invoke_Crypto_AsymmetricSignDigest
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)hash_result, hash_len);
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_INVALID;//OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = hash_len;
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = 512;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AsymmetricSignDigest, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AsymmetricSignDigest failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(sign, SharedMem2.buffer, operation.params[3].memref.size);
cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    if(hash_result)
        free(hash_result);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}



TEEC_Result Invoke_Crypto_AsymmetricSignDigest_no_key_programmed_01(uint32_t algorithm, uint32_t hash_algorithm)
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint32_t hash_len;
    uint8_t *hash_result = NULL;
    switch(hash_algorithm)
    {
        case TEE_ALG_SHA1:
        {
            hash_len = 20;
            break;
        }
        case TEE_ALG_SHA224:
        {
            hash_len = 28;
            break;
        }
        case TEE_ALG_SHA256:
        {
            hash_len = 32;
            break;
        }
        case TEE_ALG_SHA384:
        {
            hash_len = 48;
            break;
        }
        case TEE_ALG_SHA512:
        {
            hash_len = 64;
            break;
        }
        default:
        {
            break;
        }
    }
    hash_result = (uint8_t *)malloc(hash_len);
    memset(hash_result, 0, hash_len);
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = hash_algorithm;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_ZERO + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AllocateOperation failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_DigestUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    memcpy(SharedMem1.buffer+sizeof(DATA_FOR_CRYPTO1_PART1), (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1)+sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_DigestUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_DigestUpdate1 failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    #if 0
    //Invoke_Crypto_DigestUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_DigestUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_DigestUpdate2 failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    #endif
    //Invoke_Crypto_DigestDoFinal
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_DigestDoFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_DigestDoFinal failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //compare hash result
    #if 0
    if(memcmp(hash_result, SharedMem2.buffer, hash_len)){
        TEEC_Error("digest result is wrong!!\n");
        for(i=0; i<hash_len; i++){
            TEEC_Error("hash_result[%d] = %x, digest[%d] = %x\n",
                i, hash_result[i], i, *((uint8_t *)SharedMem2.buffer+i));
        }
        result = TEEC_ERROR_MAC_INVALID;
    }
    #endif
    memcpy(hash_result, SharedMem2.buffer, hash_len);

    //Invoke_Crypto_InitObjectWithKeys
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    //encode IN_AttributeID
    /*SharedMem1 filled with a concatenation of
    (uint_32)$IN_AttributeID_1$|(uint_32)offset of  $IN_Attrib_Value_1$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_1$|
    (uint_32)$IN_AttributeID_2$|(uint_32)offset of  $IN_Attrib_Value_2$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_2$|
    (uint_32)$IN_AttributeID_3$|(uint_32)offset of  $IN_Attrib_Value_3$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_3$|
    ... and so on*/
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_DSA_PRIME), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_PRIME_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+12, retrieveUint32toBuffer(TEE_ATTR_DSA_SUBPRIME), sizeof(uint32_t));
    memcpy(IN_AttributeID+16, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_PRIME_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+20, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+24, retrieveUint32toBuffer(TEE_ATTR_DSA_BASE), sizeof(uint32_t));
    memcpy(IN_AttributeID+28, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_PRIME_VALUE01)+sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+32, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_BASE_VALUE01)), sizeof(uint32_t));

    memcpy(IN_AttributeID+36, retrieveUint32toBuffer(TEE_ATTR_DSA_PRIVATE_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+40, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_PRIME_VALUE01)+sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01)+sizeof(TEE_ATTR_DSA_BASE_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+44, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_PRIVATE_VALUE_VALUE01)), sizeof(uint32_t));

    memcpy(IN_AttributeID+48, retrieveUint32toBuffer(TEE_ATTR_DSA_PUBLIC_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+52, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_PRIME_VALUE01)+sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01)+sizeof(TEE_ATTR_DSA_BASE_VALUE01)+sizeof(TEE_ATTR_DSA_PRIVATE_VALUE_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+56, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_PUBLIC_VALUE_VALUE01)), sizeof(uint32_t));

	memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    /*SharedMem2 filled with a concatenation of
    $IN_Attrib_Value_1$|$IN_Attrib_Value_2$|$IN_Attrib_Value_3$|$IN_Attrib_Value_4$|$IN_Attrib_Value_5$*/
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_DSA_PRIME_VALUE01, sizeof(TEE_ATTR_DSA_PRIME_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_DSA_PRIME_VALUE01), (void *)TEE_ATTR_DSA_SUBPRIME_VALUE01, sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_DSA_PRIME_VALUE01)+sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01), (void *)TEE_ATTR_DSA_BASE_VALUE01, sizeof(TEE_ATTR_DSA_BASE_VALUE01));

    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_DSA_PRIME_VALUE01)+sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01)+sizeof(TEE_ATTR_DSA_BASE_VALUE01), (void *)TEE_ATTR_DSA_PRIVATE_VALUE_VALUE01, sizeof(TEE_ATTR_DSA_PRIVATE_VALUE_VALUE01));
     memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_DSA_PRIME_VALUE01)+sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01)+sizeof(TEE_ATTR_DSA_BASE_VALUE01)+sizeof(TEE_ATTR_DSA_PRIVATE_VALUE_VALUE01), (void *)TEE_ATTR_DSA_PUBLIC_VALUE_VALUE01, sizeof(TEE_ATTR_DSA_PUBLIC_VALUE_VALUE01));

    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_DSA_KEYPAIR;//TEE_TYPE_RSA_KEYPAIR;
    operation.params[0].value.b = SIZE_DSA_KEYPAIR_768/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_DSA_PRIME_VALUE01)+sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01)+sizeof(TEE_ATTR_DSA_BASE_VALUE01)+sizeof(TEE_ATTR_DSA_PRIVATE_VALUE_VALUE01)+sizeof(TEE_ATTR_DSA_PUBLIC_VALUE_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_InitObjectWithKeys failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_SIGN;
    operation.params[1].value.a = SIZE_DSA_KEYPAIR_768/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AllocateOperation failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //Invoke_Crypto_AsymmetricSignDigest
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)hash_result, hash_len);
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = hash_len;
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = 512;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AsymmetricSignDigest, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AsymmetricSignDigest failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(sign, SharedMem2.buffer, operation.params[3].memref.size);
cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_FreeAllKeysAndOperations1 failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_FreeAllKeysAndOperations2 failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    if(hash_result)
        free(hash_result);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}



TEEC_Result Invoke_Crypto_AsymmetricSignDigest_short_buffer_01(uint32_t algorithm, uint32_t hash_algorithm)
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint32_t hash_len;
    uint8_t *hash_result = NULL;
    switch(hash_algorithm)
    {
        case TEE_ALG_SHA1:
        {
            hash_len = 20;
            break;
        }
        case TEE_ALG_SHA224:
        {
            hash_len = 28;
            break;
        }
        case TEE_ALG_SHA256:
        {
            hash_len = 32;
            break;
        }
        case TEE_ALG_SHA384:
        {
            hash_len = 48;
            break;
        }
        case TEE_ALG_SHA512:
        {
            hash_len = 64;
            break;
        }
        default:
        {
            break;
        }
    }
    hash_result = (uint8_t *)malloc(hash_len);
    memset(hash_result, 0, hash_len);
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = hash_algorithm;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_ZERO + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AllocateOperation failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_DigestUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    memcpy(SharedMem1.buffer+sizeof(DATA_FOR_CRYPTO1_PART1), (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1)+sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_DigestUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_DigestUpdate1 failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    #if 0
    //Invoke_Crypto_DigestUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_DigestUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_DigestUpdate2 failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    #endif
    //Invoke_Crypto_DigestDoFinal
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_DigestDoFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_DigestDoFinal failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //compare hash result
    #if 0
    if(memcmp(hash_result, SharedMem2.buffer, hash_len)){
        TEEC_Error("digest result is wrong!!\n");
        for(i=0; i<hash_len; i++){
            TEEC_Error("hash_result[%d] = %x, digest[%d] = %x\n",
                i, hash_result[i], i, *((uint8_t *)SharedMem2.buffer+i));
        }
        result = TEEC_ERROR_MAC_INVALID;
    }
    #endif
    memcpy(hash_result, SharedMem2.buffer, hash_len);

      //Invoke_Crypto_InitObjectWithKeys
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    //encode IN_AttributeID
    /*SharedMem1 filled with a concatenation of
    (uint_32)$IN_AttributeID_1$|(uint_32)offset of  $IN_Attrib_Value_1$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_1$|
    (uint_32)$IN_AttributeID_2$|(uint_32)offset of  $IN_Attrib_Value_2$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_2$|
    (uint_32)$IN_AttributeID_3$|(uint_32)offset of  $IN_Attrib_Value_3$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_3$|
    ... and so on*/
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_DSA_PRIME), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_PRIME_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+12, retrieveUint32toBuffer(TEE_ATTR_DSA_SUBPRIME), sizeof(uint32_t));
    memcpy(IN_AttributeID+16, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_PRIME_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+20, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+24, retrieveUint32toBuffer(TEE_ATTR_DSA_BASE), sizeof(uint32_t));
    memcpy(IN_AttributeID+28, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_PRIME_VALUE01)+sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+32, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_BASE_VALUE01)), sizeof(uint32_t));

    memcpy(IN_AttributeID+36, retrieveUint32toBuffer(TEE_ATTR_DSA_PRIVATE_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+40, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_PRIME_VALUE01)+sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01)+sizeof(TEE_ATTR_DSA_BASE_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+44, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_PRIVATE_VALUE_VALUE01)), sizeof(uint32_t));

    memcpy(IN_AttributeID+48, retrieveUint32toBuffer(TEE_ATTR_DSA_PUBLIC_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+52, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_PRIME_VALUE01)+sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01)+sizeof(TEE_ATTR_DSA_BASE_VALUE01)+sizeof(TEE_ATTR_DSA_PRIVATE_VALUE_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+56, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_PUBLIC_VALUE_VALUE01)), sizeof(uint32_t));

	memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    /*SharedMem2 filled with a concatenation of
    $IN_Attrib_Value_1$|$IN_Attrib_Value_2$|$IN_Attrib_Value_3$|$IN_Attrib_Value_4$|$IN_Attrib_Value_5$*/
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_DSA_PRIME_VALUE01, sizeof(TEE_ATTR_DSA_PRIME_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_DSA_PRIME_VALUE01), (void *)TEE_ATTR_DSA_SUBPRIME_VALUE01, sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_DSA_PRIME_VALUE01)+sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01), (void *)TEE_ATTR_DSA_BASE_VALUE01, sizeof(TEE_ATTR_DSA_BASE_VALUE01));

    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_DSA_PRIME_VALUE01)+sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01)+sizeof(TEE_ATTR_DSA_BASE_VALUE01), (void *)TEE_ATTR_DSA_PRIVATE_VALUE_VALUE01, sizeof(TEE_ATTR_DSA_PRIVATE_VALUE_VALUE01));
     memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_DSA_PRIME_VALUE01)+sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01)+sizeof(TEE_ATTR_DSA_BASE_VALUE01)+sizeof(TEE_ATTR_DSA_PRIVATE_VALUE_VALUE01), (void *)TEE_ATTR_DSA_PUBLIC_VALUE_VALUE01, sizeof(TEE_ATTR_DSA_PUBLIC_VALUE_VALUE01));

    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_DSA_KEYPAIR;//TEE_TYPE_RSA_KEYPAIR;
    operation.params[0].value.b = SIZE_DSA_KEYPAIR_768/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_DSA_PRIME_VALUE01)+sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01)+sizeof(TEE_ATTR_DSA_BASE_VALUE01)+sizeof(TEE_ATTR_DSA_PRIVATE_VALUE_VALUE01)+sizeof(TEE_ATTR_DSA_PUBLIC_VALUE_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_InitObjectWithKeys failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_SIGN;
    operation.params[1].value.a = SIZE_DSA_KEYPAIR_768/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AllocateOperation failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_SetOperationKey failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_AsymmetricSignDigest
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)hash_result, hash_len);
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = hash_len;
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = 1;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AsymmetricSignDigest, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_AsymmetricSignDigest failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(sign, SharedMem2.buffer, operation.params[3].memref.size);
cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_FreeAllKeysAndOperations1 failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_FreeAllKeysAndOperations2 failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    if(hash_result)
        free(hash_result);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}



TEEC_Result Invoke_Crypto_AsymmetricVerifyDigest_incompatible_mode_01(uint32_t algorithm, uint32_t hash_algorithm)
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint32_t hash_len;
    uint8_t *hash_result = NULL;
    switch(hash_algorithm)
    {
        case TEE_ALG_SHA1:
        {
            hash_len = 20;
            break;
        }
        case TEE_ALG_SHA224:
        {
            hash_len = 28;
            break;
        }
        case TEE_ALG_SHA256:
        {
            hash_len = 32;
            break;
        }
        case TEE_ALG_SHA384:
        {
            hash_len = 48;
            break;
        }
        case TEE_ALG_SHA512:
        {
            hash_len = 64;
            break;
        }
        default:
        {
            break;
        }
    }
    hash_result = (uint8_t *)malloc(hash_len);
    memset(hash_result, 0, hash_len);

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = hash_algorithm;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_ZERO + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_DigestUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    memcpy(SharedMem1.buffer+sizeof(DATA_FOR_CRYPTO1_PART1), (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1)+sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_DigestUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    #if 0
    //Invoke_Crypto_DigestUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_DigestUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    #endif
    //Invoke_Crypto_DigestDoFinal
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_DigestDoFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //compare hash result
#if 0
    if(memcmp(hash_result, SharedMem2.buffer, hash_len)){
        TEEC_Error("digest result is wrong!!\n");
        for(i=0; i<hash_len; i++){
            TEEC_Error("hash_result[%d] = %x, digest[%d] = %x\n",
                i, hash_result[i], i, *((uint8_t *)SharedMem2.buffer+i));
        }
        result = TEEC_ERROR_MAC_INVALID;
    }
#endif
    memcpy(hash_result, SharedMem2.buffer, hash_len);

   //Invoke_Crypto_InitObjectWithKeys
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    //encode IN_AttributeID
    /*SharedMem1 filled with a concatenation of
    (uint_32)$IN_AttributeID_1$|(uint_32)offset of  $IN_Attrib_Value_1$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_1$|
    (uint_32)$IN_AttributeID_2$|(uint_32)offset of  $IN_Attrib_Value_2$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_2$|
    (uint_32)$IN_AttributeID_3$|(uint_32)offset of  $IN_Attrib_Value_3$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_3$|
    ... and so on*/
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_DSA_PRIME), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_PRIME_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+12, retrieveUint32toBuffer(TEE_ATTR_DSA_SUBPRIME), sizeof(uint32_t));
    memcpy(IN_AttributeID+16, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_PRIME_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+20, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+24, retrieveUint32toBuffer(TEE_ATTR_DSA_BASE), sizeof(uint32_t));
    memcpy(IN_AttributeID+28, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_PRIME_VALUE01)+sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+32, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_BASE_VALUE01)), sizeof(uint32_t));

    memcpy(IN_AttributeID+36, retrieveUint32toBuffer(TEE_ATTR_DSA_PRIVATE_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+40, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_PRIME_VALUE01)+sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01)+sizeof(TEE_ATTR_DSA_BASE_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+44, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_PRIVATE_VALUE_VALUE01)), sizeof(uint32_t));

    memcpy(IN_AttributeID+48, retrieveUint32toBuffer(TEE_ATTR_DSA_PUBLIC_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+52, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_PRIME_VALUE01)+sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01)+sizeof(TEE_ATTR_DSA_BASE_VALUE01)+sizeof(TEE_ATTR_DSA_PRIVATE_VALUE_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+56, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_PUBLIC_VALUE_VALUE01)), sizeof(uint32_t));

	memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    /*SharedMem2 filled with a concatenation of
    $IN_Attrib_Value_1$|$IN_Attrib_Value_2$|$IN_Attrib_Value_3$|$IN_Attrib_Value_4$|$IN_Attrib_Value_5$*/
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_DSA_PRIME_VALUE01, sizeof(TEE_ATTR_DSA_PRIME_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_DSA_PRIME_VALUE01), (void *)TEE_ATTR_DSA_SUBPRIME_VALUE01, sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_DSA_PRIME_VALUE01)+sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01), (void *)TEE_ATTR_DSA_BASE_VALUE01, sizeof(TEE_ATTR_DSA_BASE_VALUE01));

    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_DSA_PRIME_VALUE01)+sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01)+sizeof(TEE_ATTR_DSA_BASE_VALUE01), (void *)TEE_ATTR_DSA_PRIVATE_VALUE_VALUE01, sizeof(TEE_ATTR_DSA_PRIVATE_VALUE_VALUE01));
     memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_DSA_PRIME_VALUE01)+sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01)+sizeof(TEE_ATTR_DSA_BASE_VALUE01)+sizeof(TEE_ATTR_DSA_PRIVATE_VALUE_VALUE01), (void *)TEE_ATTR_DSA_PUBLIC_VALUE_VALUE01, sizeof(TEE_ATTR_DSA_PUBLIC_VALUE_VALUE01));

    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_DSA_KEYPAIR;//TEE_TYPE_RSA_KEYPAIR;
    operation.params[0].value.b = SIZE_DSA_KEYPAIR_768/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_DSA_PRIME_VALUE01)+sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01)+sizeof(TEE_ATTR_DSA_BASE_VALUE01)+sizeof(TEE_ATTR_DSA_PRIVATE_VALUE_VALUE01)+sizeof(TEE_ATTR_DSA_PUBLIC_VALUE_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_InitObjectWithKeys failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_SIGN;//TEE_MODE_VERIFY;
    operation.params[1].value.a = SIZE_DSA_KEYPAIR_768/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_AsymmetricVerifyDigest
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)hash_result, hash_len);
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, sign, 256);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_INPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = hash_len;
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = 256;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AsymmetricVerifyDigest, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    if(hash_result)
        free(hash_result);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;
}



TEEC_Result Invoke_Crypto_AsymmetricVerifyDigest_invalid_operation_class_01(uint32_t algorithm, uint32_t hash_algorithm)
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint32_t hash_len;
    uint8_t *hash_result = NULL;
    switch(hash_algorithm)
    {
        case TEE_ALG_SHA1:
        {
            hash_len = 20;
            break;
        }
        case TEE_ALG_SHA224:
        {
            hash_len = 28;
            break;
        }
        case TEE_ALG_SHA256:
        {
            hash_len = 32;
            break;
        }
        case TEE_ALG_SHA384:
        {
            hash_len = 48;
            break;
        }
        case TEE_ALG_SHA512:
        {
            hash_len = 64;
            break;
        }
        default:
        {
            break;
        }
    }
    hash_result = (uint8_t *)malloc(hash_len);
    memset(hash_result, 0, hash_len);

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = hash_algorithm;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_ZERO + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_DigestUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    memcpy(SharedMem1.buffer+sizeof(DATA_FOR_CRYPTO1_PART1), (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1)+sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_DigestUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    #if 0
    //Invoke_Crypto_DigestUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_DigestUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    #endif
    //Invoke_Crypto_DigestDoFinal
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_DigestDoFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //compare hash result
#if 0
    if(memcmp(hash_result, SharedMem2.buffer, hash_len)){
        TEEC_Error("digest result is wrong!!\n");
        for(i=0; i<hash_len; i++){
            TEEC_Error("hash_result[%d] = %x, digest[%d] = %x\n",
                i, hash_result[i], i, *((uint8_t *)SharedMem2.buffer+i));
        }
        result = TEEC_ERROR_MAC_INVALID;
    }
#endif
    memcpy(hash_result, SharedMem2.buffer, hash_len);


    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_ZERO+ SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //Invoke_Crypto_AsymmetricVerifyDigest
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)hash_result, hash_len);
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, sign, 256);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_INPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = hash_len;
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = 256;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AsymmetricVerifyDigest, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    if(hash_result)
        free(hash_result);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;
}



TEEC_Result Invoke_Crypto_AsymmetricVerifyDigest_invalid_signature_01(uint32_t algorithm, uint32_t hash_algorithm)
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint32_t hash_len;
    uint8_t *hash_result = NULL;
    switch(hash_algorithm)
    {
        case TEE_ALG_SHA1:
        {
            hash_len = 20;
            break;
        }
        case TEE_ALG_SHA224:
        {
            hash_len = 28;
            break;
        }
        case TEE_ALG_SHA256:
        {
            hash_len = 32;
            break;
        }
        case TEE_ALG_SHA384:
        {
            hash_len = 48;
            break;
        }
        case TEE_ALG_SHA512:
        {
            hash_len = 64;
            break;
        }
        default:
        {
            break;
        }
    }
    hash_result = (uint8_t *)malloc(hash_len);
    memset(hash_result, 0, hash_len);

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = hash_algorithm;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_ZERO + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_DigestUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    memcpy(SharedMem1.buffer+sizeof(DATA_FOR_CRYPTO1_PART1), (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1)+sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_DigestUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    #if 0
    //Invoke_Crypto_DigestUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_DigestUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    #endif
    //Invoke_Crypto_DigestDoFinal
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_DigestDoFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //compare hash result
#if 0
    if(memcmp(hash_result, SharedMem2.buffer, hash_len)){
        TEEC_Error("digest result is wrong!!\n");
        for(i=0; i<hash_len; i++){
            TEEC_Error("hash_result[%d] = %x, digest[%d] = %x\n",
                i, hash_result[i], i, *((uint8_t *)SharedMem2.buffer+i));
        }
        result = TEEC_ERROR_MAC_INVALID;
    }
#endif
    memcpy(hash_result, SharedMem2.buffer, hash_len);

    //Invoke_Crypto_InitObjectWithKeys
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    //encode IN_AttributeID
    /*SharedMem1 filled with a concatenation of
    (uint_32)$IN_AttributeID_1$|(uint_32)offset of  $IN_Attrib_Value_1$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_1$|
    (uint_32)$IN_AttributeID_2$|(uint_32)offset of  $IN_Attrib_Value_2$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_2$|
    (uint_32)$IN_AttributeID_3$|(uint_32)offset of  $IN_Attrib_Value_3$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_3$|
    ... and so on*/
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_DSA_PRIME), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_PRIME_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+12, retrieveUint32toBuffer(TEE_ATTR_DSA_SUBPRIME), sizeof(uint32_t));
    memcpy(IN_AttributeID+16, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_PRIME_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+20, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+24, retrieveUint32toBuffer(TEE_ATTR_DSA_BASE), sizeof(uint32_t));
    memcpy(IN_AttributeID+28, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_PRIME_VALUE01)+sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+32, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_BASE_VALUE01)), sizeof(uint32_t));

    memcpy(IN_AttributeID+36, retrieveUint32toBuffer(TEE_ATTR_DSA_PRIVATE_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+40, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_PRIME_VALUE01)+sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01)+sizeof(TEE_ATTR_DSA_BASE_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+44, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_PRIVATE_VALUE_VALUE01)), sizeof(uint32_t));

    memcpy(IN_AttributeID+48, retrieveUint32toBuffer(TEE_ATTR_DSA_PUBLIC_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+52, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_PRIME_VALUE01)+sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01)+sizeof(TEE_ATTR_DSA_BASE_VALUE01)+sizeof(TEE_ATTR_DSA_PRIVATE_VALUE_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+56, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_PUBLIC_VALUE_VALUE01)), sizeof(uint32_t));

	memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    /*SharedMem2 filled with a concatenation of
    $IN_Attrib_Value_1$|$IN_Attrib_Value_2$|$IN_Attrib_Value_3$|$IN_Attrib_Value_4$|$IN_Attrib_Value_5$*/
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_DSA_PRIME_VALUE01, sizeof(TEE_ATTR_DSA_PRIME_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_DSA_PRIME_VALUE01), (void *)TEE_ATTR_DSA_SUBPRIME_VALUE01, sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_DSA_PRIME_VALUE01)+sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01), (void *)TEE_ATTR_DSA_BASE_VALUE01, sizeof(TEE_ATTR_DSA_BASE_VALUE01));

    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_DSA_PRIME_VALUE01)+sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01)+sizeof(TEE_ATTR_DSA_BASE_VALUE01), (void *)TEE_ATTR_DSA_PRIVATE_VALUE_VALUE01, sizeof(TEE_ATTR_DSA_PRIVATE_VALUE_VALUE01));
     memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_DSA_PRIME_VALUE01)+sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01)+sizeof(TEE_ATTR_DSA_BASE_VALUE01)+sizeof(TEE_ATTR_DSA_PRIVATE_VALUE_VALUE01), (void *)TEE_ATTR_DSA_PUBLIC_VALUE_VALUE01, sizeof(TEE_ATTR_DSA_PUBLIC_VALUE_VALUE01));

    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_DSA_KEYPAIR;//TEE_TYPE_RSA_KEYPAIR;
    operation.params[0].value.b = SIZE_DSA_KEYPAIR_768/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_DSA_PRIME_VALUE01)+sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01)+sizeof(TEE_ATTR_DSA_BASE_VALUE01)+sizeof(TEE_ATTR_DSA_PRIVATE_VALUE_VALUE01)+sizeof(TEE_ATTR_DSA_PUBLIC_VALUE_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_InitObjectWithKeys failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_VERIFY;
    operation.params[1].value.a = SIZE_DSA_KEYPAIR_768/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_AsymmetricVerifyDigest
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)hash_result, hash_len);
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, sign, 256);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_INPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = hash_len;
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = 256;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AsymmetricVerifyDigest, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    if(hash_result)
        free(hash_result);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;
}



TEEC_Result Invoke_Crypto_AsymmetricVerifyDigest_invalid_value_handle_01(uint32_t algorithm, uint32_t hash_algorithm)
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint32_t hash_len;
    uint8_t *hash_result = NULL;
    switch(hash_algorithm)
    {
        case TEE_ALG_SHA1:
        {
            hash_len = 20;
            break;
        }
        case TEE_ALG_SHA224:
        {
            hash_len = 28;
            break;
        }
        case TEE_ALG_SHA256:
        {
            hash_len = 32;
            break;
        }
        case TEE_ALG_SHA384:
        {
            hash_len = 48;
            break;
        }
        case TEE_ALG_SHA512:
        {
            hash_len = 64;
            break;
        }
        default:
        {
            break;
        }
    }
    hash_result = (uint8_t *)malloc(hash_len);
    memset(hash_result, 0, hash_len);

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }

    //Invoke_Crypto_AsymmetricVerifyDigest
    operation.started = 1;
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)hash_result, hash_len);
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, sign, 256);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_INPUT);
    operation.params[0].value.a = OPERATION_HANDLE_INVALID;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = hash_len;
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = 256;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AsymmetricVerifyDigest, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
cleanup_4:
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    if(hash_result)
        free(hash_result);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;
}




TEEC_Result Invoke_Crypto_AsymmetricVerifyDigest_no_key_programmed_01(uint32_t algorithm, uint32_t hash_algorithm)
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint32_t hash_len;
    uint8_t *hash_result = NULL;
    switch(hash_algorithm)
    {
        case TEE_ALG_SHA1:
        {
            hash_len = 20;
            break;
        }
        case TEE_ALG_SHA224:
        {
            hash_len = 28;
            break;
        }
        case TEE_ALG_SHA256:
        {
            hash_len = 32;
            break;
        }
        case TEE_ALG_SHA384:
        {
            hash_len = 48;
            break;
        }
        case TEE_ALG_SHA512:
        {
            hash_len = 64;
            break;
        }
        default:
        {
            break;
        }
    }
    hash_result = (uint8_t *)malloc(hash_len);
    memset(hash_result, 0, hash_len);

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = hash_algorithm;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_ZERO + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_DigestUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    memcpy(SharedMem1.buffer+sizeof(DATA_FOR_CRYPTO1_PART1), (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1)+sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_DigestUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    #if 0
    //Invoke_Crypto_DigestUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_DigestUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    #endif
    //Invoke_Crypto_DigestDoFinal
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_DigestDoFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //compare hash result
#if 0
    if(memcmp(hash_result, SharedMem2.buffer, hash_len)){
        TEEC_Error("digest result is wrong!!\n");
        for(i=0; i<hash_len; i++){
            TEEC_Error("hash_result[%d] = %x, digest[%d] = %x\n",
                i, hash_result[i], i, *((uint8_t *)SharedMem2.buffer+i));
        }
        result = TEEC_ERROR_MAC_INVALID;
    }
#endif
    memcpy(hash_result, SharedMem2.buffer, hash_len);

   //Invoke_Crypto_InitObjectWithKeys
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    //encode IN_AttributeID
    /*SharedMem1 filled with a concatenation of
    (uint_32)$IN_AttributeID_1$|(uint_32)offset of  $IN_Attrib_Value_1$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_1$|
    (uint_32)$IN_AttributeID_2$|(uint_32)offset of  $IN_Attrib_Value_2$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_2$|
    (uint_32)$IN_AttributeID_3$|(uint_32)offset of  $IN_Attrib_Value_3$ in SharedMem2|(uint_32)length of $IN_Attrib_Value_3$|
    ... and so on*/
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_DSA_PRIME), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_PRIME_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+12, retrieveUint32toBuffer(TEE_ATTR_DSA_SUBPRIME), sizeof(uint32_t));
    memcpy(IN_AttributeID+16, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_PRIME_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+20, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+24, retrieveUint32toBuffer(TEE_ATTR_DSA_BASE), sizeof(uint32_t));
    memcpy(IN_AttributeID+28, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_PRIME_VALUE01)+sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+32, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_BASE_VALUE01)), sizeof(uint32_t));

    memcpy(IN_AttributeID+36, retrieveUint32toBuffer(TEE_ATTR_DSA_PRIVATE_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+40, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_PRIME_VALUE01)+sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01)+sizeof(TEE_ATTR_DSA_BASE_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+44, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_PRIVATE_VALUE_VALUE01)), sizeof(uint32_t));

    memcpy(IN_AttributeID+48, retrieveUint32toBuffer(TEE_ATTR_DSA_PUBLIC_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+52, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_PRIME_VALUE01)+sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01)+sizeof(TEE_ATTR_DSA_BASE_VALUE01)+sizeof(TEE_ATTR_DSA_PRIVATE_VALUE_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+56, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_PUBLIC_VALUE_VALUE01)), sizeof(uint32_t));

	memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    /*SharedMem2 filled with a concatenation of
    $IN_Attrib_Value_1$|$IN_Attrib_Value_2$|$IN_Attrib_Value_3$|$IN_Attrib_Value_4$|$IN_Attrib_Value_5$*/
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_DSA_PRIME_VALUE01, sizeof(TEE_ATTR_DSA_PRIME_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_DSA_PRIME_VALUE01), (void *)TEE_ATTR_DSA_SUBPRIME_VALUE01, sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_DSA_PRIME_VALUE01)+sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01), (void *)TEE_ATTR_DSA_BASE_VALUE01, sizeof(TEE_ATTR_DSA_BASE_VALUE01));

    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_DSA_PRIME_VALUE01)+sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01)+sizeof(TEE_ATTR_DSA_BASE_VALUE01), (void *)TEE_ATTR_DSA_PRIVATE_VALUE_VALUE01, sizeof(TEE_ATTR_DSA_PRIVATE_VALUE_VALUE01));
     memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_DSA_PRIME_VALUE01)+sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01)+sizeof(TEE_ATTR_DSA_BASE_VALUE01)+sizeof(TEE_ATTR_DSA_PRIVATE_VALUE_VALUE01), (void *)TEE_ATTR_DSA_PUBLIC_VALUE_VALUE01, sizeof(TEE_ATTR_DSA_PUBLIC_VALUE_VALUE01));

    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_DSA_KEYPAIR;//TEE_TYPE_RSA_KEYPAIR;
    operation.params[0].value.b = SIZE_DSA_KEYPAIR_768/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_DSA_PRIME_VALUE01)+sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01)+sizeof(TEE_ATTR_DSA_BASE_VALUE01)+sizeof(TEE_ATTR_DSA_PRIVATE_VALUE_VALUE01)+sizeof(TEE_ATTR_DSA_PUBLIC_VALUE_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke CMD_Crypto_InitObjectWithKeys failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_VERIFY;
    operation.params[1].value.a = SIZE_DSA_KEYPAIR_768/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //Invoke_Crypto_AsymmetricVerifyDigest
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)hash_result, hash_len);
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, sign, 256);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_INPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = hash_len;
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = 256;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AsymmetricVerifyDigest, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    if(hash_result)
        free(hash_result);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;
}


TEEC_Result Invoke_Crypto_AllocateOperation_TEE_ALG_AES_CBC_MAC_NOPAD_mode_not_allowed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_AES_CBC_MAC_NOPAD;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_VERIFY;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}



TEEC_Result Invoke_Crypto_AllocateOperation_TEE_ALG_AES_CBC_MAC_PKCS5_mode_not_allowed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_AES_CBC_MAC_PKCS5;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}


TEEC_Result Invoke_Crypto_AllocateOperation_TEE_ALG_AES_CBC_NOPAD_mode_not_allowed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //context02.ta_path = "/system/tee/534d4152-5443-534c-5443-525950544f31.sec";

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_AES_CBC_NOPAD;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_VERIFY;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}



TEEC_Result Invoke_Crypto_AllocateOperation_TEE_ALG_AES_CCM_mode_not_allowed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_AES_CCM;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}


TEEC_Result Invoke_Crypto_AllocateOperation_TEE_ALG_AES_CMAC_mode_not_allowed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_AES_CMAC;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_AllocateOperation_TEE_ALG_AES_CTR_mode_not_allowed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_AES_CTR;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_VERIFY;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_AllocateOperation_TEE_ALG_AES_CTS_mode_not_allowed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_AES_CTS;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_AllocateOperation_TEE_ALG_AES_ECB_NOPAD_mode_not_allowed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_AES_ECB_NOPAD;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_MAC;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_AllocateOperation_TEE_ALG_AES_GCM_mode_not_allowed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_AES_GCM;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_AllocateOperation_TEE_ALG_AES_XTS_mode_not_allowed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_AES_XTS;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_AllocateOperation_TEE_ALG_DES3_CBC_MAC_NOPAD_mode_not_allowed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_DES3_CBC_MAC_NOPAD;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_AllocateOperation_TEE_ALG_DES3_CBC_MAC_PKCS5_mode_not_allowed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_DES3_CBC_MAC_PKCS5;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_AllocateOperation_TEE_ALG_DES3_CBC_NOPAD_mode_not_allowed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_DES3_CBC_NOPAD;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}


TEEC_Result Invoke_Crypto_AllocateOperation_TEE_ALG_DES3_ECB_NOPAD_mode_not_allowed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_DES3_ECB_NOPAD;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}



TEEC_Result Invoke_Crypto_AllocateOperation_TEE_ALG_DES_CBC_MAC_NOPAD_mode_not_allowed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_DES_CBC_MAC_NOPAD;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_VERIFY;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}



TEEC_Result Invoke_Crypto_AllocateOperation_TEE_ALG_DES_CBC_MAC_PKCS5_mode_not_allowed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_DES_CBC_MAC_PKCS5;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}



TEEC_Result Invoke_Crypto_AllocateOperation_TEE_ALG_DES_CBC_NOPAD_mode_not_allowed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_DES_CBC_NOPAD;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}


TEEC_Result Invoke_Crypto_AllocateOperation_TEE_ALG_DES_ECB_NOPAD_mode_not_allowed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_DES_ECB_NOPAD;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}


TEEC_Result Invoke_Crypto_AllocateOperation_TEE_ALG_DH_DERIVE_SHARED_SECRET_mode_not_allowed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_DH_DERIVE_SHARED_SECRET;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}


TEEC_Result Invoke_Crypto_AllocateOperation_TEE_ALG_HMAC_MD5_mode_not_allowed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_HMAC_MD5;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_AllocateOperation_TEE_ALG_DSA_SHA1_mode_not_allowed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_DSA_SHA1;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_MAC;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}


TEEC_Result Invoke_Crypto_AllocateOperation_TEE_ALG_HMAC_SHA1_mode_not_allowed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_HMAC_SHA1;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}



TEEC_Result Invoke_Crypto_AllocateOperation_TEE_ALG_HMAC_SHA224_mode_not_allowed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_HMAC_SHA224;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_VERIFY;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}



TEEC_Result Invoke_Crypto_AllocateOperation_TEE_ALG_HMAC_SHA256_mode_not_allowed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_HMAC_SHA256;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_VERIFY;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}



TEEC_Result Invoke_Crypto_AllocateOperation_TEE_ALG_HMAC_SHA384_mode_not_allowed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_HMAC_SHA384;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_VERIFY;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}



TEEC_Result Invoke_Crypto_AllocateOperation_TEE_ALG_HMAC_SHA512_mode_not_allowed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_HMAC_SHA512;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_VERIFY;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}


TEEC_Result Invoke_Crypto_AllocateOperation_TEE_ALG_MD5_mode_not_allowed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_MD5;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_DECRYPT;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}


TEEC_Result Invoke_Crypto_AllocateOperation_TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA1_mode_not_allowed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA1;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_VERIFY;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}


TEEC_Result Invoke_Crypto_AllocateOperation_TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA224_mode_not_allowed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA224;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_VERIFY;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}


TEEC_Result Invoke_Crypto_AllocateOperation_TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA256_mode_not_allowed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA256;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}



TEEC_Result Invoke_Crypto_AllocateOperation_TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA384_mode_not_allowed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA384;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_VERIFY;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}


TEEC_Result Invoke_Crypto_AllocateOperation_TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA512_mode_not_allowed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA512;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}



TEEC_Result Invoke_Crypto_AllocateOperation_TEE_ALG_RSAES_PKCS1_V1_5_mode_not_allowed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_RSAES_PKCS1_V1_5;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}



TEEC_Result Invoke_Crypto_AllocateOperation_TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1_mode_not_allowed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}



TEEC_Result Invoke_Crypto_AllocateOperation_TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224_mode_not_allowed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}
TEEC_Result Invoke_Crypto_AllocateOperation_TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256_mode_not_allowed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}
TEEC_Result Invoke_Crypto_AllocateOperation_TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384_mode_not_allowed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}
TEEC_Result Invoke_Crypto_AllocateOperation_TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512_mode_not_allowed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_MAC;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}
TEEC_Result Invoke_Crypto_AllocateOperation_TEE_ALG_RSASSA_PKCS1_V1_5_MD5_mode_not_allowed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_RSASSA_PKCS1_V1_5_MD5;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}
TEEC_Result Invoke_Crypto_AllocateOperation_TEE_ALG_RSASSA_PKCS1_V1_5_SHA1_mode_not_allowed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_RSASSA_PKCS1_V1_5_SHA1;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}
TEEC_Result Invoke_Crypto_AllocateOperation_TEE_ALG_RSASSA_PKCS1_V1_5_SHA224_mode_not_allowed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_RSASSA_PKCS1_V1_5_SHA224;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}
TEEC_Result Invoke_Crypto_AllocateOperation_TEE_ALG_RSASSA_PKCS1_V1_5_SHA256_mode_not_allowed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_RSASSA_PKCS1_V1_5_SHA256;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}
TEEC_Result Invoke_Crypto_AllocateOperation_TEE_ALG_RSASSA_PKCS1_V1_5_SHA384_mode_not_allowed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_RSASSA_PKCS1_V1_5_SHA384;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}
TEEC_Result Invoke_Crypto_AllocateOperation_TEE_ALG_RSASSA_PKCS1_V1_5_SHA512_mode_not_allowed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_RSASSA_PKCS1_V1_5_SHA512;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_MAC;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}
TEEC_Result Invoke_Crypto_AllocateOperation_TEE_ALG_RSA_NOPAD_mode_not_allowed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_RSA_NOPAD;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}
TEEC_Result Invoke_Crypto_AllocateOperation_TEE_ALG_SHA1_mode_not_allowed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_SHA1;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_DECRYPT;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}
TEEC_Result Invoke_Crypto_AllocateOperation_TEE_ALG_SHA224_mode_not_allowed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_SHA224;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_DECRYPT;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}
TEEC_Result Invoke_Crypto_AllocateOperation_TEE_ALG_SHA256_mode_not_allowed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_SHA256;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_MAC;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}
TEEC_Result Invoke_Crypto_AllocateOperation_TEE_ALG_SHA384_mode_not_allowed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_SHA384;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_DECRYPT;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}
TEEC_Result Invoke_Crypto_AllocateOperation_TEE_ALG_SHA512_mode_not_allowed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_SHA512;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_DECRYPT;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}
TEEC_Result Invoke_Crypto_AllocateOperation_not_enough_memory()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    //Invoke_Crypto_AllocateOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_HMAC_SHA256;//TEE_ALG_AES_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_MAC;
    operation.params[1].value.a = KEY_SIZE_TOO_LARGE + WRONG_SIZE;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("exception test invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_2;
    }

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}


TEEC_Result Invoke_Crypto_AEDecryptFinal_short_buffer_01(uint32_t tagLen, uint32_t mac_case,
            uint32_t algorithm, uint32_t short_buffer, uint32_t encrypt_decrypt, uint32_t AEupdate)
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    TEEC_SharedMemory SharedMem3;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_Data[3][32] = {0};
    uint8_t decrypt_Data[3][32] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));


    SharedMem3.buffer = NULL;
    SharedMem3.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    SharedMem3.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem3);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem3.buffer, 0, sizeof(DATA_FOR_CRYPTO1_PART1));
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    operation.started = 1;
    //Invoke_Crypto_InitObjectWithKeys
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    #if 0
    TEEC_Debug("%x, %x, %x\n", *(uint32_t *)SharedMem1.buffer, *(uint32_t *)(SharedMem1.buffer+4),
        *(uint32_t *)(SharedMem1.buffer+8));
    #endif
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //+++++++++++++++++++++encrypt++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_AES_256 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)NONCE2_VALUE_AES_GCM, sizeof(NONCE2_VALUE_AES_GCM));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = tagLen/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(NONCE2_VALUE_AES_GCM);
    operation.params[2].value.a = AAD1_LENGTH;
    operation.params[2].value.b = LENGTH_DATA_FOR_CRYPTO1;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //Invoke_Crypto_AEUpdateAAD
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)AAD1_VALUE, sizeof(AAD1_VALUE));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(AAD1_VALUE);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdateAAD, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEUpdate_for_encryption
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
  //  if(AEupdate == 1 && short_buffer == OUTPUT_BUFFER_TOO_SHORT)
  //      operation.params[3].memref.size = 1;
  //  else
        operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)encrypt_Data[0], SharedMem2.buffer, 32);
    #if 0
    for(i=0; i<32; i++){
        TEEC_Debug("encrypt_Data[0][%d] = %x\n", i, *((uint8_t *)SharedMem2.buffer+i));
    }
    #endif
    //Invoke_Crypto_AEUpdate_for_encryption
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    memcpy((void *)encrypt_Data[1], SharedMem2.buffer, 32);
    #if 0
    for(i=0; i<32; i++){
        TEEC_Debug("encrypt_Data[1][%d] = %x\n", i, encrypt_Data[1][i]);
    }
    #endif

    //Invoke_Crypto_AEEncryptFinal
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_OUTPUT,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[2].memref.parent = &SharedMem3;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
   // if(short_buffer == OUTPUT_BUFFER_TOO_SHORT && encrypt_decrypt == TEE_MODE_ENCRYPT)
   //     operation.params[3].memref.size = 1;
  //  else
        operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEEncryptFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)encrypt_Data[2], SharedMem2.buffer, 32);
    #if 0
    for(i=0; i<32; i++){
        TEEC_Debug("encrypt_Data[2][%d] = %x\n", i, encrypt_Data[2][i]);
    }
    #endif

    //++++++++++++++++++++++++decrypt+++++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_DECRYPT;
    operation.params[1].value.a = SIZE_AES_256 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)NONCE2_VALUE_AES_GCM, sizeof(NONCE2_VALUE_AES_GCM));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = tagLen/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(NONCE2_VALUE_AES_GCM);
    operation.params[2].value.a = AAD1_LENGTH;
    operation.params[2].value.b = LENGTH_DATA_FOR_CRYPTO1;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEUpdateAAD
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)AAD1_VALUE, sizeof(AAD1_VALUE));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(AAD1_VALUE);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdateAAD, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEUpdate_for_decryption
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)encrypt_Data[0], sizeof(encrypt_Data[0]));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(encrypt_Data[0]);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(encrypt_Data[0]);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    memcpy((void *)decrypt_Data[0], SharedMem2.buffer, 32);

    //Invoke_Crypto_AEUpdate_for_decryption
    memcpy(SharedMem1.buffer, (void *)encrypt_Data[1], sizeof(encrypt_Data[1]));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(encrypt_Data[1]);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(encrypt_Data[1]);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    memcpy((void *)decrypt_Data[1], SharedMem2.buffer, 32);

    //Invoke_Crypto_AEDecryptFinal
    if(mac_case == INVALID_MAC){
        *(char *)(SharedMem3.buffer) = 0xff;
    }
    memcpy(SharedMem1.buffer, (void *)encrypt_Data[2], sizeof(encrypt_Data[2]));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(encrypt_Data[2]);
    operation.params[2].memref.parent = &SharedMem3;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(encrypt_Data[2]);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
  //  if(short_buffer == OUTPUT_BUFFER_TOO_SHORT && encrypt_decrypt == TEE_MODE_DECRYPT)
        operation.params[3].memref.size = 1;
  //  else
  //      operation.params[3].memref.size = sizeof(encrypt_Data[2]);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEDecryptFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)decrypt_Data[2], SharedMem2.buffer, 32);

    if(memcmp(DATA_FOR_CRYPTO1, decrypt_Data, sizeof(decrypt_Data))){
        TEEC_Error("decrypt data is not equal to encrypt\n");
        #if 1
        for(i=0; i<sizeof(DATA_FOR_CRYPTO1); i++){
            TEEC_Error("DATA_FOR_CRYPTO1[%d] = %x, decrypt_Data[%d] = %x\n",
                i, DATA_FOR_CRYPTO1[i], i, *((uint8_t *)decrypt_Data+i));
        }
        #endif
        result = TEEC_ERROR_MAC_INVALID;
    }
cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    if(SharedMem3.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem3);

cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}


TEEC_Result Invoke_Crypto_AEEncryptFinal_invalid_operation_class_01(uint32_t tagLen, uint32_t mac_case,
            uint32_t algorithm, uint32_t short_buffer, uint32_t encrypt_decrypt, uint32_t AEupdate)
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    TEEC_SharedMemory SharedMem3;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_Data[3][32] = {0};
    uint8_t decrypt_Data[3][32] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));


    SharedMem3.buffer = NULL;
    SharedMem3.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    SharedMem3.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem3);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem3.buffer, 0, sizeof(DATA_FOR_CRYPTO1_PART1));
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    operation.started = 1;

    //+++++++++++++++++++++encrypt++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_ZERO + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEEncryptFinal
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_OUTPUT,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    operation.params[2].memref.parent = &SharedMem3;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    if(short_buffer == OUTPUT_BUFFER_TOO_SHORT && encrypt_decrypt == TEE_MODE_ENCRYPT)
        operation.params[3].memref.size = 1;
    else
        operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEEncryptFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)encrypt_Data[2], SharedMem2.buffer, 32);

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    if(SharedMem3.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem3);

cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}


TEEC_Result Invoke_Crypto_AEEncryptFinal_invalid_value_handle_01(uint32_t tagLen, uint32_t mac_case,
            uint32_t algorithm, uint32_t short_buffer, uint32_t encrypt_decrypt, uint32_t AEupdate)
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    TEEC_SharedMemory SharedMem3;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_Data[3][32] = {0};
    uint8_t decrypt_Data[3][32] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));


    SharedMem3.buffer = NULL;
    SharedMem3.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    SharedMem3.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem3);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem3.buffer, 0, sizeof(DATA_FOR_CRYPTO1_PART1));
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    operation.started = 1;


    //Invoke_Crypto_AEEncryptFinal
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_OUTPUT,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_INVALID;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    operation.params[2].memref.parent = &SharedMem3;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    if(short_buffer == OUTPUT_BUFFER_TOO_SHORT && encrypt_decrypt == TEE_MODE_ENCRYPT)
        operation.params[3].memref.size = 1;
    else
        operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEEncryptFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)encrypt_Data[2], SharedMem2.buffer, 32);

cleanup_4:
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    if(SharedMem3.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem3);

cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}


TEEC_Result Invoke_Crypto_AEEncryptFinal_operation_not_started_01(uint32_t tagLen, uint32_t mac_case,
            uint32_t algorithm, uint32_t short_buffer, uint32_t encrypt_decrypt, uint32_t AEupdate)
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    TEEC_SharedMemory SharedMem3;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_Data[3][32] = {0};
    uint8_t decrypt_Data[3][32] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));


    SharedMem3.buffer = NULL;
    SharedMem3.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    SharedMem3.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem3);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem3.buffer, 0, sizeof(DATA_FOR_CRYPTO1_PART1));
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    operation.started = 1;
    //Invoke_Crypto_InitObjectWithKeys
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    #if 0
    TEEC_Debug("%x, %x, %x\n", *(uint32_t *)SharedMem1.buffer, *(uint32_t *)(SharedMem1.buffer+4),
        *(uint32_t *)(SharedMem1.buffer+8));
    #endif
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //+++++++++++++++++++++encrypt++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_AES_256 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }


    //Invoke_Crypto_AEEncryptFinal
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_OUTPUT,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    operation.params[2].memref.parent = &SharedMem3;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    if(short_buffer == OUTPUT_BUFFER_TOO_SHORT && encrypt_decrypt == TEE_MODE_ENCRYPT)
        operation.params[3].memref.size = 1;
    else
        operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEEncryptFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)encrypt_Data[2], SharedMem2.buffer, 32);
    #if 0
    for(i=0; i<32; i++){
        TEEC_Debug("encrypt_Data[2][%d] = %x\n", i, encrypt_Data[2][i]);
    }
    #endif

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    if(SharedMem3.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem3);

cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}


TEEC_Result Invoke_Crypto_AEEncryptFinal_short_buffer_01(uint32_t tagLen, uint32_t mac_case,
            uint32_t algorithm, uint32_t short_buffer, uint32_t encrypt_decrypt, uint32_t AEupdate)
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    TEEC_SharedMemory SharedMem3;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_Data[3][32] = {0};
    uint8_t decrypt_Data[3][32] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));


    SharedMem3.buffer = NULL;
    SharedMem3.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    SharedMem3.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem3);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem3.buffer, 0, sizeof(DATA_FOR_CRYPTO1_PART1));
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    operation.started = 1;
    //Invoke_Crypto_InitObjectWithKeys
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    #if 0
    TEEC_Debug("%x, %x, %x\n", *(uint32_t *)SharedMem1.buffer, *(uint32_t *)(SharedMem1.buffer+4),
        *(uint32_t *)(SharedMem1.buffer+8));
    #endif
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //+++++++++++++++++++++encrypt++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_AES_256 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)NONCE2_VALUE_AES_GCM, sizeof(NONCE2_VALUE_AES_GCM));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = tagLen/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(NONCE2_VALUE_AES_GCM);
    operation.params[2].value.a = AAD1_LENGTH;
    operation.params[2].value.b = LENGTH_DATA_FOR_CRYPTO1;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //Invoke_Crypto_AEUpdateAAD
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)AAD1_VALUE, sizeof(AAD1_VALUE));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(AAD1_VALUE);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdateAAD, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEUpdate_for_encryption
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)encrypt_Data[0], SharedMem2.buffer, 32);
    #if 0
    for(i=0; i<32; i++){
        TEEC_Debug("encrypt_Data[0][%d] = %x\n", i, *((uint8_t *)SharedMem2.buffer+i));
    }
    #endif
    //Invoke_Crypto_AEUpdate_for_encryption
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    memcpy((void *)encrypt_Data[1], SharedMem2.buffer, 32);
    #if 0
    for(i=0; i<32; i++){
        TEEC_Debug("encrypt_Data[1][%d] = %x\n", i, encrypt_Data[1][i]);
    }
    #endif

    //Invoke_Crypto_AEEncryptFinal
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_OUTPUT,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[2].memref.parent = &SharedMem3;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = 1;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEEncryptFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)encrypt_Data[2], SharedMem2.buffer, 32);
    #if 0
    for(i=0; i<32; i++){
        TEEC_Debug("encrypt_Data[2][%d] = %x\n", i, encrypt_Data[2][i]);
    }
    #endif


cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    if(SharedMem3.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem3);

cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_AEInit_AES_104_bits_TEE_ALG_AES_CCM_tag_length_not_supported_01(uint32_t tagLen, uint32_t mac_case,
            uint32_t algorithm, uint32_t short_buffer, uint32_t encrypt_decrypt, uint32_t AEupdate)
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    TEEC_SharedMemory SharedMem3;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_Data[3][32] = {0};
    uint8_t decrypt_Data[3][32] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));


    SharedMem3.buffer = NULL;
    SharedMem3.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    SharedMem3.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem3);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem3.buffer, 0, sizeof(DATA_FOR_CRYPTO1_PART1));
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    operation.started = 1;
    //Invoke_Crypto_InitObjectWithKeys
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    #if 0
    TEEC_Debug("%x, %x, %x\n", *(uint32_t *)SharedMem1.buffer, *(uint32_t *)(SharedMem1.buffer+4),
        *(uint32_t *)(SharedMem1.buffer+8));
    #endif
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //+++++++++++++++++++++encrypt++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_DECRYPT;
    operation.params[1].value.a = SIZE_AES_256 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)NONCE2_VALUE_AES_GCM, sizeof(NONCE2_VALUE_AES_GCM));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = tagLen/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(NONCE2_VALUE_AES_GCM);
    operation.params[2].value.a = AAD1_LENGTH;
    operation.params[2].value.b = LENGTH_DATA_FOR_CRYPTO1;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }


cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    if(SharedMem3.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem3);

cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}


TEEC_Result Invoke_Crypto_AEInit_AES_120_bits_TEE_ALG_AES_CCM_tag_length_not_supported_01(uint32_t tagLen, uint32_t mac_case,
            uint32_t algorithm, uint32_t short_buffer, uint32_t encrypt_decrypt, uint32_t AEupdate)
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    TEEC_SharedMemory SharedMem3;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_Data[3][32] = {0};
    uint8_t decrypt_Data[3][32] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));


    SharedMem3.buffer = NULL;
    SharedMem3.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    SharedMem3.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem3);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem3.buffer, 0, sizeof(DATA_FOR_CRYPTO1_PART1));
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    operation.started = 1;
    //Invoke_Crypto_InitObjectWithKeys
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    #if 0
    TEEC_Debug("%x, %x, %x\n", *(uint32_t *)SharedMem1.buffer, *(uint32_t *)(SharedMem1.buffer+4),
        *(uint32_t *)(SharedMem1.buffer+8));
    #endif
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //+++++++++++++++++++++encrypt++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_DECRYPT;
    operation.params[1].value.a = SIZE_AES_256 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)NONCE1_VALUE_AES_CCM, sizeof(NONCE1_VALUE_AES_CCM));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = tagLen/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(NONCE1_VALUE_AES_CCM);
    operation.params[2].value.a = AAD1_LENGTH;
    operation.params[2].value.b = LENGTH_DATA_FOR_CRYPTO1;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }


cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    if(SharedMem3.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem3);

cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}


TEEC_Result Invoke_Crypto_AEInit_AES_32_bits_TEE_ALG_AES_GCM_tag_length_not_supported_01(uint32_t tagLen, uint32_t mac_case,
            uint32_t algorithm, uint32_t short_buffer, uint32_t encrypt_decrypt, uint32_t AEupdate)
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    TEEC_SharedMemory SharedMem3;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_Data[3][32] = {0};
    uint8_t decrypt_Data[3][32] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));


    SharedMem3.buffer = NULL;
    SharedMem3.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    SharedMem3.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem3);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem3.buffer, 0, sizeof(DATA_FOR_CRYPTO1_PART1));
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    operation.started = 1;
    //Invoke_Crypto_InitObjectWithKeys
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    #if 0
    TEEC_Debug("%x, %x, %x\n", *(uint32_t *)SharedMem1.buffer, *(uint32_t *)(SharedMem1.buffer+4),
        *(uint32_t *)(SharedMem1.buffer+8));
    #endif
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //+++++++++++++++++++++encrypt++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_AES_256 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)NONCE2_VALUE_AES_GCM, sizeof(NONCE2_VALUE_AES_GCM));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = tagLen/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(NONCE2_VALUE_AES_GCM);
    operation.params[2].value.a = AAD1_LENGTH;
    operation.params[2].value.b = LENGTH_DATA_FOR_CRYPTO1;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }


cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    if(SharedMem3.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem3);

cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}



TEEC_Result Invoke_Crypto_AEInit_AES_48_bits_TEE_ALG_AES_GCM_tag_length_not_supported_01(uint32_t tagLen, uint32_t mac_case,
            uint32_t algorithm, uint32_t short_buffer, uint32_t encrypt_decrypt, uint32_t AEupdate)
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    TEEC_SharedMemory SharedMem3;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_Data[3][32] = {0};
    uint8_t decrypt_Data[3][32] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));


    SharedMem3.buffer = NULL;
    SharedMem3.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    SharedMem3.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem3);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem3.buffer, 0, sizeof(DATA_FOR_CRYPTO1_PART1));
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    operation.started = 1;
    //Invoke_Crypto_InitObjectWithKeys
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    #if 0
    TEEC_Debug("%x, %x, %x\n", *(uint32_t *)SharedMem1.buffer, *(uint32_t *)(SharedMem1.buffer+4),
        *(uint32_t *)(SharedMem1.buffer+8));
    #endif
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //+++++++++++++++++++++encrypt++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_AES_256 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)NONCE1_VALUE_AES_CCM, sizeof(NONCE1_VALUE_AES_CCM));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = tagLen/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(NONCE1_VALUE_AES_CCM);
    operation.params[2].value.a = AAD1_LENGTH;
    operation.params[2].value.b = LENGTH_DATA_FOR_CRYPTO1;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }


cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    if(SharedMem3.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem3);

cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}




TEEC_Result Invoke_Crypto_AEInit_AES_64_bits_TEE_ALG_AES_GCM_tag_length_not_supported_01(uint32_t tagLen, uint32_t mac_case,
            uint32_t algorithm, uint32_t short_buffer, uint32_t encrypt_decrypt, uint32_t AEupdate)
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    TEEC_SharedMemory SharedMem3;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_Data[3][32] = {0};
    uint8_t decrypt_Data[3][32] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));


    SharedMem3.buffer = NULL;
    SharedMem3.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    SharedMem3.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem3);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem3.buffer, 0, sizeof(DATA_FOR_CRYPTO1_PART1));
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    operation.started = 1;
    //Invoke_Crypto_InitObjectWithKeys
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    #if 0
    TEEC_Debug("%x, %x, %x\n", *(uint32_t *)SharedMem1.buffer, *(uint32_t *)(SharedMem1.buffer+4),
        *(uint32_t *)(SharedMem1.buffer+8));
    #endif
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //+++++++++++++++++++++encrypt++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_AES_256 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)NONCE2_VALUE_AES_GCM, sizeof(NONCE2_VALUE_AES_GCM));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = tagLen/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(NONCE2_VALUE_AES_GCM);
    operation.params[2].value.a = AAD1_LENGTH;
    operation.params[2].value.b = LENGTH_DATA_FOR_CRYPTO1;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }


cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    if(SharedMem3.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem3);

cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_AEInit_incompatible_nonce_length_01(uint32_t tagLen, uint32_t mac_case,
            uint32_t algorithm, uint32_t short_buffer, uint32_t encrypt_decrypt, uint32_t AEupdate)
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    TEEC_SharedMemory SharedMem3;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_Data[3][32] = {0};
    uint8_t decrypt_Data[3][32] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));


    SharedMem3.buffer = NULL;
    SharedMem3.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    SharedMem3.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem3);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem3.buffer, 0, sizeof(DATA_FOR_CRYPTO1_PART1));
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    operation.started = 1;
    //Invoke_Crypto_InitObjectWithKeys
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    #if 0
    TEEC_Debug("%x, %x, %x\n", *(uint32_t *)SharedMem1.buffer, *(uint32_t *)(SharedMem1.buffer+4),
        *(uint32_t *)(SharedMem1.buffer+8));
    #endif
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //+++++++++++++++++++++encrypt++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_AES_256 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)IV2_VALUE_128bits_AES, sizeof(IV2_VALUE_128bits_AES));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = tagLen/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(IV2_VALUE_128bits_AES);
    operation.params[2].value.a = AAD1_LENGTH;
    operation.params[2].value.b = LENGTH_DATA_FOR_CRYPTO1;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }


cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    if(SharedMem3.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem3);

cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}


TEEC_Result Invoke_Crypto_AEInit_invalid_operation_class_01(uint32_t tagLen, uint32_t mac_case,
            uint32_t algorithm, uint32_t short_buffer, uint32_t encrypt_decrypt, uint32_t AEupdate)
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    TEEC_SharedMemory SharedMem3;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_Data[3][32] = {0};
    uint8_t decrypt_Data[3][32] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));


    SharedMem3.buffer = NULL;
    SharedMem3.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    SharedMem3.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem3);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem3.buffer, 0, sizeof(DATA_FOR_CRYPTO1_PART1));
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    operation.started = 1;
    //Invoke_Crypto_InitObjectWithKeys
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    #if 0
    TEEC_Debug("%x, %x, %x\n", *(uint32_t *)SharedMem1.buffer, *(uint32_t *)(SharedMem1.buffer+4),
        *(uint32_t *)(SharedMem1.buffer+8));
    #endif
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //+++++++++++++++++++++encrypt++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_AES_256 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)NONCE2_VALUE_AES_GCM , sizeof(NONCE2_VALUE_AES_GCM));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = tagLen/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(NONCE2_VALUE_AES_GCM);
    operation.params[2].value.a = AAD1_LENGTH;
    operation.params[2].value.b = LENGTH_DATA_FOR_CRYPTO1;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }


cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    if(SharedMem3.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem3);

cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}



TEEC_Result Invoke_Crypto_AEInit_invalid_value_handle_01(uint32_t tagLen, uint32_t mac_case,
            uint32_t algorithm, uint32_t short_buffer, uint32_t encrypt_decrypt, uint32_t AEupdate)
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    TEEC_SharedMemory SharedMem3;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_Data[3][32] = {0};
    uint8_t decrypt_Data[3][32] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));


    SharedMem3.buffer = NULL;
    SharedMem3.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    SharedMem3.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem3);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem3.buffer, 0, sizeof(DATA_FOR_CRYPTO1_PART1));
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    operation.started = 1;

    //Invoke_Crypto_AEInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)NONCE2_VALUE_AES_GCM , sizeof(NONCE2_VALUE_AES_GCM));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_INVALID;
    operation.params[0].value.b = tagLen/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(NONCE2_VALUE_AES_GCM);
    operation.params[2].value.a = AAD1_LENGTH;
    operation.params[2].value.b = LENGTH_DATA_FOR_CRYPTO1;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }


cleanup_4:
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    if(SharedMem3.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem3);

cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_AEInit_no_key_programmed_01(uint32_t tagLen, uint32_t mac_case,
            uint32_t algorithm, uint32_t short_buffer, uint32_t encrypt_decrypt, uint32_t AEupdate)
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    TEEC_SharedMemory SharedMem3;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_Data[3][32] = {0};
    uint8_t decrypt_Data[3][32] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));


    SharedMem3.buffer = NULL;
    SharedMem3.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    SharedMem3.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem3);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem3.buffer, 0, sizeof(DATA_FOR_CRYPTO1_PART1));
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    operation.started = 1;
    //Invoke_Crypto_InitObjectWithKeys
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    #if 0
    TEEC_Debug("%x, %x, %x\n", *(uint32_t *)SharedMem1.buffer, *(uint32_t *)(SharedMem1.buffer+4),
        *(uint32_t *)(SharedMem1.buffer+8));
    #endif
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //+++++++++++++++++++++encrypt++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_AES_256 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }


    //Invoke_Crypto_AEInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)NONCE2_VALUE_AES_GCM, sizeof(NONCE2_VALUE_AES_GCM));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = tagLen/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(NONCE2_VALUE_AES_GCM);
    operation.params[2].value.a = AAD1_LENGTH;
    operation.params[2].value.b = LENGTH_DATA_FOR_CRYPTO1;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    if(SharedMem3.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem3);

cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_AEUpdateAAD_AAD_length_reached_01(uint32_t tagLen, uint32_t mac_case,
            uint32_t algorithm, uint32_t short_buffer, uint32_t encrypt_decrypt, uint32_t AEupdate)
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    TEEC_SharedMemory SharedMem3;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_Data[3][32] = {0};
    uint8_t decrypt_Data[3][32] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));


    SharedMem3.buffer = NULL;
    SharedMem3.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    SharedMem3.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem3);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem3.buffer, 0, sizeof(DATA_FOR_CRYPTO1_PART1));
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    operation.started = 1;
    //Invoke_Crypto_InitObjectWithKeys
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    #if 0
    TEEC_Debug("%x, %x, %x\n", *(uint32_t *)SharedMem1.buffer, *(uint32_t *)(SharedMem1.buffer+4),
        *(uint32_t *)(SharedMem1.buffer+8));
    #endif
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //+++++++++++++++++++++encrypt++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_AES_256 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)NONCE1_VALUE_AES_CCM, sizeof(NONCE1_VALUE_AES_CCM));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = tagLen/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(NONCE1_VALUE_AES_CCM);
    operation.params[2].value.a = AAD1_LENGTH;
    operation.params[2].value.b = LENGTH_DATA_FOR_CRYPTO1;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //Invoke_Crypto_AEUpdateAAD
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)AAD1_VALUE, sizeof(AAD1_VALUE));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(AAD1_VALUE);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdateAAD, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEUpdateAAD
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)AAD1_VALUE, sizeof(AAD1_VALUE));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(AAD1_VALUE);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdateAAD, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    if(SharedMem3.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem3);

cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}


TEEC_Result Invoke_Crypto_AEUpdateAAD_invalid_operation_class_01(uint32_t tagLen, uint32_t mac_case,
            uint32_t algorithm, uint32_t short_buffer, uint32_t encrypt_decrypt, uint32_t AEupdate)
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    TEEC_SharedMemory SharedMem3;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_Data[3][32] = {0};
    uint8_t decrypt_Data[3][32] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));


    SharedMem3.buffer = NULL;
    SharedMem3.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    SharedMem3.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem3);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem3.buffer, 0, sizeof(DATA_FOR_CRYPTO1_PART1));
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    operation.started = 1;

    //+++++++++++++++++++++encrypt++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_ZERO + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }


    //Invoke_Crypto_AEUpdateAAD
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)AAD1_VALUE, sizeof(AAD1_VALUE));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(AAD1_VALUE);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdateAAD, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }


cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    if(SharedMem3.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem3);

cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}



TEEC_Result Invoke_Crypto_AEUpdateAAD_invalid_value_handle_01(uint32_t tagLen, uint32_t mac_case,
            uint32_t algorithm, uint32_t short_buffer, uint32_t encrypt_decrypt, uint32_t AEupdate)
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    TEEC_SharedMemory SharedMem3;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_Data[3][32] = {0};
    uint8_t decrypt_Data[3][32] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));


    SharedMem3.buffer = NULL;
    SharedMem3.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    SharedMem3.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem3);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem3.buffer, 0, sizeof(DATA_FOR_CRYPTO1_PART1));
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    operation.started = 1;


    //Invoke_Crypto_AEUpdateAAD
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)AAD1_VALUE, sizeof(AAD1_VALUE));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_INVALID;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(AAD1_VALUE);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdateAAD, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }


cleanup_4:
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    if(SharedMem3.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem3);

cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}


TEEC_Result Invoke_Crypto_AEUpdateAAD_operation_not_started_01(uint32_t tagLen, uint32_t mac_case,
            uint32_t algorithm, uint32_t short_buffer, uint32_t encrypt_decrypt, uint32_t AEupdate)
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    TEEC_SharedMemory SharedMem3;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_Data[3][32] = {0};
    uint8_t decrypt_Data[3][32] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));


    SharedMem3.buffer = NULL;
    SharedMem3.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    SharedMem3.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem3);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem3.buffer, 0, sizeof(DATA_FOR_CRYPTO1_PART1));
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    operation.started = 1;
    //Invoke_Crypto_InitObjectWithKeys
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    #if 0
    TEEC_Debug("%x, %x, %x\n", *(uint32_t *)SharedMem1.buffer, *(uint32_t *)(SharedMem1.buffer+4),
        *(uint32_t *)(SharedMem1.buffer+8));
    #endif
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //+++++++++++++++++++++encrypt++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_AES_256 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }


    //Invoke_Crypto_AEUpdateAAD
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)AAD1_VALUE, sizeof(AAD1_VALUE));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(AAD1_VALUE);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdateAAD, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }


cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    if(SharedMem3.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem3);

cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}


TEEC_Result Invoke_Crypto_AEUpdate_AAD_length_not_provided_01(uint32_t tagLen, uint32_t mac_case,
            uint32_t algorithm, uint32_t short_buffer, uint32_t encrypt_decrypt, uint32_t AEupdate)
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    TEEC_SharedMemory SharedMem3;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_Data[3][32] = {0};
    uint8_t decrypt_Data[3][32] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));


    SharedMem3.buffer = NULL;
    SharedMem3.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    SharedMem3.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem3);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem3.buffer, 0, sizeof(DATA_FOR_CRYPTO1_PART1));
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    operation.started = 1;
    //Invoke_Crypto_InitObjectWithKeys
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    #if 0
    TEEC_Debug("%x, %x, %x\n", *(uint32_t *)SharedMem1.buffer, *(uint32_t *)(SharedMem1.buffer+4),
        *(uint32_t *)(SharedMem1.buffer+8));
    #endif
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //+++++++++++++++++++++encrypt++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_AES_256 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)NONCE1_VALUE_AES_CCM, sizeof(NONCE1_VALUE_AES_CCM));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = tagLen/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(NONCE1_VALUE_AES_CCM);
    operation.params[2].value.a = AAD1_LENGTH;
    operation.params[2].value.b = LENGTH_DATA_FOR_CRYPTO1;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }


    //Invoke_Crypto_AEUpdate_for_encryption
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    if(AEupdate == 1 && short_buffer == OUTPUT_BUFFER_TOO_SHORT)
        operation.params[3].memref.size = 1;
    else
        operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)encrypt_Data[0], SharedMem2.buffer, 32);


cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    if(SharedMem3.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem3);

cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}



TEEC_Result Invoke_Crypto_AEUpdate_invalid_operation_class_01(uint32_t tagLen, uint32_t mac_case,
            uint32_t algorithm, uint32_t short_buffer, uint32_t encrypt_decrypt, uint32_t AEupdate)
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    TEEC_SharedMemory SharedMem3;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_Data[3][32] = {0};
    uint8_t decrypt_Data[3][32] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));


    SharedMem3.buffer = NULL;
    SharedMem3.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    SharedMem3.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem3);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem3.buffer, 0, sizeof(DATA_FOR_CRYPTO1_PART1));
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    operation.started = 1;

    //+++++++++++++++++++++encrypt++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = algorithm;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_ZERO + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }


    //Invoke_Crypto_AEUpdate_for_encryption
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    if(AEupdate == 1 && short_buffer == OUTPUT_BUFFER_TOO_SHORT)
        operation.params[3].memref.size = 1;
    else
        operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)encrypt_Data[0], SharedMem2.buffer, 32);


cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    if(SharedMem3.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem3);

cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_AEUpdate_invalid_value_handle_01(uint32_t tagLen, uint32_t mac_case,
            uint32_t algorithm, uint32_t short_buffer, uint32_t encrypt_decrypt, uint32_t AEupdate)
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    TEEC_SharedMemory SharedMem3;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_Data[3][32] = {0};
    uint8_t decrypt_Data[3][32] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));


    SharedMem3.buffer = NULL;
    SharedMem3.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    SharedMem3.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem3);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem3.buffer, 0, sizeof(DATA_FOR_CRYPTO1_PART1));
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }

    operation.started = 1;


    //Invoke_Crypto_AEUpdate_for_encryption
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_INVALID;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    if(AEupdate == 1 && short_buffer == OUTPUT_BUFFER_TOO_SHORT)
        operation.params[3].memref.size = 1;
    else
        operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy((void *)encrypt_Data[0], SharedMem2.buffer, 32);


cleanup_4:
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    if(SharedMem3.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem3);

cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}


TEEC_Result Invoke_Crypto_AEUpdate_payload_length_reached()///need check
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint32_t IN_AttributeID[] = {TEE_ATTR_SECRET_VALUE, 0, 256,
                                    0, 0, 0,
                                    0, 0, 0,
                                    0, 0, 0,
                                    0, 0, 0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }
    operation.started = 1;
    //Invoke_Crypto_InitObjectWithKeys
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //+++++++++++++++++++++encrypt++++++++++++++++++++++++++++
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_AES_CCM;
    operation.params[0].value.b = TEE_MODE_DECRYPT;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_AEInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)NONCE1_VALUE_AES_CCM, sizeof(NONCE1_VALUE_AES_CCM));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = AES_128_bits;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(NONCE1_VALUE_AES_CCM);
    operation.params[2].value.a = AAD1_LENGTH;
    operation.params[2].value.b = LENGTH_DATA_FOR_CRYPTO1;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEUpdateAAD
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)AAD1_VALUE, sizeof(AAD1_VALUE));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(AAD1_VALUE);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdateAAD, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEUpdate_for_encryption
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEUpdate_for_encryption
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEUpdate_for_encryption
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

    //Invoke_Crypto_AEUpdate_for_encryption
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AEUpdate, &operation, &origin);
    if (result == TEE_ERROR_TARGET_DEAD) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        result = TEEC_SUCCESS;
    }

    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}


TEEC_Result Invoke_Crypto_ResetOperation_Success()
{
    TEEC_Result result;
    TEEC_Context context02;
    TEEC_Session session01;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_HMAC_SHA256_512_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_HMAC_SHA256_512_VALUE01, sizeof(TEE_ATTR_HMAC_SHA256_512_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }

    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_HMAC_SHA256;
    operation.params[0].value.b = SIZE_HMAC_SHA256_512/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_HMAC_SHA256_512_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }

    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_HMAC_SHA256;
    operation.params[0].value.b = TEE_MODE_MAC;
    operation.params[1].value.a = SIZE_HMAC_SHA256_512/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }

    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //Invoke_Crypto_MACInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, IV2_VALUE_128bits_AES, sizeof(IV2_VALUE_128bits_AES));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(IV2_VALUE_128bits_AES);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //Invoke_Crypto_MACUpdate
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1, sizeof(DATA_FOR_CRYPTO1));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //CMD_Crypto_ResetOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_ResetOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //Invoke_Crypto_GetOperationInfo
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INOUT,
        TEEC_VALUE_OUTPUT,
        TEEC_VALUE_OUTPUT,
        TEEC_VALUE_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_GetOperationInfo, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //check output param is right or not
    if(operation.params[0].value.a == TEE_ALG_HMAC_SHA256 &&
        operation.params[0].value.b == TEE_OPERATION_MAC &&
        operation.params[1].value.a == TEE_MODE_MAC &&
        operation.params[1].value.b == SIZE_ZERO &&
        operation.params[2].value.a == SIZE_HMAC_SHA256_512/8 &&
        operation.params[2].value.b == SIZE_HMAC_SHA256_512/8 &&
        operation.params[3].value.a == TEE_USAGE_MAC &&
        operation.params[3].value.b == 0x00040000){
        TEEC_Debug("Invoke_Crypto_GetOperationInfo success\n");
    }else{
        TEEC_Error("Invoke_Crypto_GetOperationInfo failed\n");
        TEEC_Error("OUT_algorithm=%x, OUT_operationClass=%x\n", operation.params[0].value.a, operation.params[0].value.b);
        TEEC_Error("OUT_mode=%x, OUT_digestLength=%x\n", operation.params[1].value.a, operation.params[1].value.b);
        TEEC_Error("OUT_maxKeySize_object1=%x, OUT_keySize=%x\n", operation.params[2].value.a, operation.params[2].value.b);
        TEEC_Error("OUT_requiredKeyUsage=%x, OUT_handleState=%x\n", operation.params[3].value.a, operation.params[3].value.b);
    }

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;
}

TEEC_Result Invoke_Crypto_ResetOperation_invalid_value_handle()
{
    TEEC_Result result;
    TEEC_Context context02;
    TEEC_Session session01;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_HMAC_SHA256_512_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_HMAC_SHA256_512_VALUE01, sizeof(TEE_ATTR_HMAC_SHA256_512_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }

    //CMD_Crypto_ResetOperation
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_INVALID;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_ResetOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

cleanup_4:
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;
}


TEEC_Result Invoke_Crypto_SetOperationKey2_Success()
{
    TEEC_Result result;
    TEEC_Context context02;
    TEEC_Session session01;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }

    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_AES_XTS;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_AES_256/8;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    operation.params[1].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey2, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_AES_XTS;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_AES_256/8;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_CipherInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, IV2_VALUE_128bits_AES, sizeof(IV2_VALUE_128bits_AES));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(IV2_VALUE_128bits_AES);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_CipherUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //Invoke_Crypto_CipherUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //Invoke_Crypto_CipherDoFinal
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherDoFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}



TEEC_Result Invoke_Crypto_SetOperationKey2_invalid_value_handle_operation()
{
    TEEC_Result result;
    TEEC_Context context02;
    TEEC_Session session01;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }

	memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_DH_PRIME), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_DH_PRIME_VALUE01)), sizeof(uint32_t));
	memcpy(IN_AttributeID+12, retrieveUint32toBuffer(TEE_ATTR_DH_BASE), sizeof(uint32_t));
    memcpy(IN_AttributeID+16, retrieveUint32toBuffer(sizeof(TEE_ATTR_DH_PRIME_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+20, retrieveUint32toBuffer(sizeof(TEE_ATTR_DH_BASE_VALUE01)), sizeof(uint32_t));
   memcpy(IN_AttributeID+24, retrieveUint32toBuffer(TEE_ATTR_DH_PUBLIC_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+28, retrieveUint32toBuffer(sizeof(TEE_ATTR_DH_PRIME_VALUE01)+sizeof(TEE_ATTR_DH_BASE_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+32, retrieveUint32toBuffer(sizeof(TEE_ATTR_DH_PUBLIC_VALUE_VALUE01)), sizeof(uint32_t));
     memcpy(IN_AttributeID+36, retrieveUint32toBuffer(TEE_ATTR_DH_PRIVATE_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+40, retrieveUint32toBuffer(sizeof(TEE_ATTR_DH_PRIME_VALUE01)+sizeof(TEE_ATTR_DH_BASE_VALUE01)+sizeof(TEE_ATTR_DH_PUBLIC_VALUE_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+44, retrieveUint32toBuffer(sizeof(TEE_ATTR_DH_PRIVATE_VALUE_VALUE01)), sizeof(uint32_t));

    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

	memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_DH_PRIME_VALUE01, sizeof(TEE_ATTR_DH_PRIME_VALUE01));
	memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_DH_PRIME_VALUE01), (void *)TEE_ATTR_DH_BASE_VALUE01, sizeof(TEE_ATTR_DH_BASE_VALUE01));
   memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_DH_PRIME_VALUE01)+sizeof(TEE_ATTR_DH_BASE_VALUE01), (void *)TEE_ATTR_DH_PUBLIC_VALUE_VALUE01, sizeof(TEE_ATTR_DH_PUBLIC_VALUE_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_DH_PRIME_VALUE01)+sizeof(TEE_ATTR_DH_BASE_VALUE01)+sizeof(TEE_ATTR_DH_PUBLIC_VALUE_VALUE01), (void *)TEE_ATTR_DH_PRIVATE_VALUE_VALUE01, sizeof(TEE_ATTR_DH_PRIVATE_VALUE_VALUE01));

    //Invoke_Crypto_InitObjectWithKeys
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_DH_KEYPAIR;//TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_DH_KEYPAIR_1024/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_DH_PRIME_VALUE01)+sizeof(TEE_ATTR_DH_BASE_VALUE01)+sizeof(TEE_ATTR_DH_PUBLIC_VALUE_VALUE01)+sizeof(TEE_ATTR_DH_PRIVATE_VALUE_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }

    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_INVALID;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    operation.params[1].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey2, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

cleanup_4:
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_SetOperationKey2_key1_handle_not_valid()
{
    TEEC_Result result;
    TEEC_Context context02;
    TEEC_Session session01;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }

    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_AES_XTS;
    operation.params[0].value.b = TEE_MODE_DECRYPT;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_AES_256/8;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_INVALID;
    operation.params[1].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey2, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}


TEEC_Result Invoke_Crypto_SetOperationKey2_key2_handle_not_valid()
{
    TEEC_Result result;
    TEEC_Context context02;
    TEEC_Session session01;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }

    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_AES_XTS;
    operation.params[0].value.b = TEE_MODE_DECRYPT;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_AES_256/8;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    operation.params[1].value.a = OBJECT_HANDLE_INVALID;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey2, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}


TEEC_Result Invoke_Crypto_SetOperationKey2_operation_expects_no_key()
{
    TEEC_Result result;
    TEEC_Context context02;
    TEEC_Session session01;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }

    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_MD5;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_ZERO + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    operation.params[1].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey2, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}


TEEC_Result Invoke_Crypto_SetOperationKey2_operation_expects_one_key()
{
    TEEC_Result result;
    TEEC_Context context02;
    TEEC_Session session01;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_RSA_MODULUS), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
memcpy(IN_AttributeID+12, retrieveUint32toBuffer(TEE_ATTR_RSA_PUBLIC_EXPONENT), sizeof(uint32_t));
    memcpy(IN_AttributeID+16, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+20, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));
	memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_RSA_MODULUS_VALUE01, sizeof(TEE_ATTR_RSA_MODULUS_VALUE01));
	memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01), (void *)TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01));
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_RSA_PUBLIC_KEY;
    operation.params[0].value.b = SIZE_RSA_KEYPAIR_2048/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }

	memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_DSA_PRIME), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_PRIME_VALUE01)), sizeof(uint32_t));
	memcpy(IN_AttributeID+12, retrieveUint32toBuffer(TEE_ATTR_DSA_SUBPRIME), sizeof(uint32_t));
    memcpy(IN_AttributeID+16, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_PRIME_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+20, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01)), sizeof(uint32_t));
   memcpy(IN_AttributeID+24, retrieveUint32toBuffer(TEE_ATTR_DSA_BASE), sizeof(uint32_t));
    memcpy(IN_AttributeID+28, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_PRIME_VALUE01)+sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+32, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_BASE_VALUE01)), sizeof(uint32_t));
     memcpy(IN_AttributeID+36, retrieveUint32toBuffer(TEE_ATTR_DSA_PRIVATE_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+40, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_PRIME_VALUE01)+sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01)+sizeof(TEE_ATTR_DSA_BASE_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+44, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_PRIVATE_VALUE_VALUE01)), sizeof(uint32_t));
   memcpy(IN_AttributeID+48, retrieveUint32toBuffer(TEE_ATTR_DSA_PUBLIC_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+52, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_PRIME_VALUE01)+sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01)+sizeof(TEE_ATTR_DSA_BASE_VALUE01)+sizeof(TEE_ATTR_DSA_PRIVATE_VALUE_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+56, retrieveUint32toBuffer(sizeof(TEE_ATTR_DSA_PUBLIC_VALUE_VALUE01)), sizeof(uint32_t));

    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

	memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_DSA_PRIME_VALUE01, sizeof(TEE_ATTR_DSA_PRIME_VALUE01));
	memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_DSA_PRIME_VALUE01), (void *)TEE_ATTR_DSA_SUBPRIME_VALUE01, sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01));
   memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_DSA_PRIME_VALUE01)+sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01), (void *)TEE_ATTR_DSA_BASE_VALUE01, sizeof(TEE_ATTR_DSA_BASE_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_DSA_PRIME_VALUE01)+sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01)+sizeof(TEE_ATTR_DSA_BASE_VALUE01), (void *)TEE_ATTR_DSA_PRIVATE_VALUE_VALUE01, sizeof(TEE_ATTR_DSA_PRIVATE_VALUE_VALUE01));
  memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_DSA_PRIME_VALUE01)+sizeof(TEE_ATTR_DSA_SUBPRIME_VALUE01)+sizeof(TEE_ATTR_DSA_BASE_VALUE01)+sizeof(TEE_ATTR_DSA_PRIVATE_VALUE_VALUE01), (void *)TEE_ATTR_DSA_PUBLIC_VALUE_VALUE01, sizeof(TEE_ATTR_DSA_PUBLIC_VALUE_VALUE01));

    //Invoke_Crypto_InitObjectWithKeys
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_DSA_KEYPAIR;
    operation.params[0].value.b = SIZE_DSA_KEYPAIR_768/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }

    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA224;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_RSA_KEYPAIR_2048/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    operation.params[1].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey2, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}



TEEC_Result Invoke_Crypto_SetOperationKey_Success ()
{
    TEEC_Result result;
    TEEC_Context context02;
    TEEC_Session session01;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }

    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("1 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }

    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_AES_ECB_NOPAD;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("2 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_02;
    //operation.params[1].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("3 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //Invoke_Crypto_CipherInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
   // memcpy(SharedMem1.buffer, IV2_VALUE_128bits_AES, sizeof(IV2_VALUE_128bits_AES));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 0;//sizeof(IV2_VALUE_128bits_AES);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("4 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_CipherUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("5 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //Invoke_Crypto_CipherUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("6 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //Invoke_Crypto_CipherDoFinal
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherDoFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("7 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("8 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("9 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}


TEEC_Result Invoke_Crypto_SetOperationKey_expect_two_keys ()
{
    TEEC_Result result;
    TEEC_Context context02;
    TEEC_Session session01;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }

    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("1 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }
	 //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("1 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }

    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_AES_XTS;
    operation.params[0].value.b = TEE_MODE_DECRYPT;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_AES_256/8;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("2 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    //operation.params[1].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("3 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("8 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("9 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}


TEEC_Result Invoke_Crypto_SetOperationKey_expects_no_key ()
{
    TEEC_Result result;
    TEEC_Context context02;
    TEEC_Session session01;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_RSA_MODULUS), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
   memcpy(IN_AttributeID+12, retrieveUint32toBuffer(TEE_ATTR_RSA_PUBLIC_EXPONENT), sizeof(uint32_t));
    memcpy(IN_AttributeID+16, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+20, retrieveUint32toBuffer(sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01)), sizeof(uint32_t));
   memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
     memcpy(SharedMem2.buffer, (void *)TEE_ATTR_RSA_MODULUS_VALUE01, sizeof(TEE_ATTR_RSA_MODULUS_VALUE01));
	memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_RSA_MODULUS_VALUE01), (void *)TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01, sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01));
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }

    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_RSA_PUBLIC_KEY;
    operation.params[0].value.b = SIZE_RSA_KEYPAIR_2048/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_RSA_MODULUS_VALUE01)+sizeof(TEE_ATTR_RSA_PUBLIC_EXPONENT_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("1 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }

    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_MD5;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_ZERO + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("2 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    //operation.params[1].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("3 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}



TEEC_Result Invoke_Crypto_SetOperationKey_invalid_value_handle_key ()
{
    TEEC_Result result;
    TEEC_Context context02;
    TEEC_Session session01;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_DES3_192_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_DES3_192_VALUE01, sizeof(TEE_ATTR_DES3_192_VALUE01));
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }

    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_DES3;
    operation.params[0].value.b = SIZE_DES3_192/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_DES3_192_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("1 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }

    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_DES3_CBC_MAC_NOPAD;
    operation.params[0].value.b = TEE_MODE_MAC;
    operation.params[1].value.a = SIZE_DES3_192/8 + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("2 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_INVALID;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("3 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_SetOperationKey_invalid_value_handle_operation ()
{
    TEEC_Result result;
    TEEC_Context context02;
    TEEC_Session session01;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }

    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("1 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }

    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_INVALID;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    //operation.params[1].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("3 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

cleanup_4:
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_FreeAllKeysAndOperations_Success ()
{
    TEEC_Result result;
    TEEC_Context context02;
    TEEC_Session session01;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }

    operation.started = 1;

    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_SHA512;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_ZERO + SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("2 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("8 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("9 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_FreeAllKeysAndOperations_operation_handle_not_valid ()
{
    TEEC_Result result;
    TEEC_Context context02;
    TEEC_Session session01;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    operation.started = 1;
cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_INVALID;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("8 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_AEDecryptFinal_AES_32_bits_TEE_ALG_AES_CCM_Success()
{
    TEEC_Result result = Invoke_Crypto_AEDecryptFinal_AES_TEE_ALG_AES_CCM_Success(AES_32_bits, VALID_MAC, TEE_ALG_AES_CCM, OUTPUT_BUFFER_NORMAL, TEE_MODE_ENCRYPT, 0);
    return result;
}

TEEC_Result Invoke_Crypto_AEDecryptFinal_AES_112_bits_TEE_ALG_AES_CCM_Success ()
{
   TEEC_Result result = Invoke_Crypto_AEDecryptFinal_AES_112_bits_TEE_ALG_AES_CCM(AES_112_bits, VALID_MAC, TEE_ALG_AES_CCM, OUTPUT_BUFFER_NORMAL, TEE_MODE_ENCRYPT, 0);
    return result;
}

TEEC_Result Invoke_Crypto_AEDecryptFinal_AES_128_bits_TEE_ALG_AES_CCM_Success  ()
{
   TEEC_Result result = Invoke_Crypto_AEDecryptFinal_AES_128_bits_TEE_ALG_AES_CCM(AES_128_bits, VALID_MAC, TEE_ALG_AES_CCM, OUTPUT_BUFFER_NORMAL, TEE_MODE_ENCRYPT, 0);
    return result;
}

TEEC_Result Invoke_Crypto_AEDecryptFinal_AES_48_bits_TEE_ALG_AES_CCM_Success  ()
{
   TEEC_Result result = Invoke_Crypto_AEDecryptFinal_AES_48_bits_TEE_ALG_AES_CCM(AES_48_bits, VALID_MAC, TEE_ALG_AES_CCM, OUTPUT_BUFFER_NORMAL, TEE_MODE_ENCRYPT, 0);
    return result;
}

TEEC_Result Invoke_Crypto_AEDecryptFinal_AES_64_bits_TEE_ALG_AES_CCM_Success  ()
{
   TEEC_Result result = Invoke_Crypto_AEDecryptFinal_AES_64_bits_TEE_ALG_AES_CCM(AES_64_bits, VALID_MAC, TEE_ALG_AES_CCM, OUTPUT_BUFFER_NORMAL, TEE_MODE_ENCRYPT, 0);
    return result;
}

TEEC_Result Invoke_Crypto_AEDecryptFinal_AES_96_bits_TEE_ALG_AES_CCM_Success  ()
{
   TEEC_Result result = Invoke_Crypto_AEDecryptFinal_AES_96_bits_TEE_ALG_AES_CCM(AES_96_bits, VALID_MAC, TEE_ALG_AES_CCM, OUTPUT_BUFFER_NORMAL, TEE_MODE_ENCRYPT, 0);
    return result;
}

TEEC_Result Invoke_Crypto_AEDecryptFinal_invalid_mac   ()
{
   TEEC_Result result = Invoke_Crypto_AEDecryptFinal_invalid_mac_01(AES_128_bits, VALID_MAC, TEE_ALG_AES_CCM, OUTPUT_BUFFER_NORMAL, TEE_MODE_ENCRYPT, 0);
    return result;
}

TEEC_Result Invoke_Crypto_AEDecryptFinal_invalid_operation_class   ()
{
   TEEC_Result result = Invoke_Crypto_AEDecryptFinal_invalid_operation_01(AES_128_bits, VALID_MAC, TEE_ALG_AES_CCM, OUTPUT_BUFFER_NORMAL, TEE_MODE_ENCRYPT, 0);
    return result;
}

TEEC_Result Invoke_Crypto_AEDecryptFinal_invalid_value_handle   ()
{
   TEEC_Result result = Invoke_Crypto_AEDecryptFinal_invalid_value_handle_01(AES_128_bits, VALID_MAC, TEE_ALG_AES_CCM, OUTPUT_BUFFER_NORMAL, TEE_MODE_ENCRYPT, 0);
    return result;
}

TEEC_Result Invoke_Crypto_AEDecryptFinal_operation_not_started   ()
{
   TEEC_Result result = Invoke_Crypto_AEDecryptFinal_operation_not_started_01(AES_128_bits, VALID_MAC, TEE_ALG_AES_CCM, OUTPUT_BUFFER_NORMAL, TEE_MODE_ENCRYPT, 0);
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricDecrypt_TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA1_Success()
{
    TEEC_Result result = Invoke_Crypto_AsymmetricDecrypt_TEE_ALG_RSAES_PKCS1_OAEP_MGF1_Success(TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA1);
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricDecrypt_TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA224_Success()
{
    TEEC_Result result = Invoke_Crypto_AsymmetricDecrypt_TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA224_Success_01(TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA224);
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricDecrypt_TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA256_Success()
{
    TEEC_Result result = Invoke_Crypto_AsymmetricDecrypt_TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA256_Success_01(TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA256);
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricDecrypt_TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA384_Success()
{
    TEEC_Result result = Invoke_Crypto_AsymmetricDecrypt_TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA384_Success_01(TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA384);
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricDecrypt_TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA512_Success()
{
    TEEC_Result result = Invoke_Crypto_AsymmetricDecrypt_TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA512_Success_01(TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA512);
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricDecrypt_TEE_ALG_RSAES_PKCS1_V1_5_Success()
{
    TEEC_Result result = Invoke_Crypto_AsymmetricDecrypt_TEE_ALG_RSAES_PKCS1_OAEP_MGF1_Success(TEE_ALG_RSAES_PKCS1_V1_5);
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricDecrypt_TEE_ALG_RSA_NOPAD_TEE_MODE_DECRYPT_Success()
{
    TEEC_Result result = Invoke_Crypto_AsymmetricDecrypt_TEE_ALG_RSA_NOPAD_TEE_MODE_DECRYPT_Success_01(TEE_ALG_RSA_NOPAD);
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricDecrypt_incompatible_mode()
{
    TEEC_Result result = Invoke_Crypto_AsymmetricDecrypt_incompatible_mode_01(TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA1);
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricDecrypt_invalid_operation_class()
{
    TEEC_Result result = Invoke_Crypto_AsymmetricDecrypt_invalid_operation_class_01(TEE_ALG_RSA_NOPAD);
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricDecrypt_invalid_value_handle()
{
    TEEC_Result result = Invoke_Crypto_AsymmetricDecrypt_invalid_value_handle_01(TEE_ALG_RSA_NOPAD);
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricDecrypt_no_key_programmed()
{
    TEEC_Result result = Invoke_Crypto_AsymmetricDecrypt_no_key_programmed_01(TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA512);
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricDecrypt_short_buffer()
{
    TEEC_Result result = Invoke_Crypto_AsymmetricDecrypt_short_buffer_01(TEE_ALG_RSA_NOPAD);
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricEncrypt_incompatible_mode()
{
    TEEC_Result result = Invoke_Crypto_AsymmetricEncrypt_incompatible_mode_01(TEE_ALG_RSAES_PKCS1_V1_5);
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricEncrypt_invalid_operation_class()
{
    TEEC_Result result = Invoke_Crypto_AsymmetricEncrypt_invalid_operation_class_01(TEE_ALG_SHA512);
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricEncrypt_invalid_value_handle()
{
    TEEC_Result result = Invoke_Crypto_AsymmetricEncrypt_invalid_value_handle_01(TEE_ALG_SHA512);
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricEncrypt_no_key_programmed()
{
    TEEC_Result result = Invoke_Crypto_AsymmetricEncrypt_no_key_programmed_01(TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA384);
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricEncrypt_short_buffer()
{
    TEEC_Result result = Invoke_Crypto_AsymmetricEncrypt_short_buffer_01(TEE_ALG_RSA_NOPAD);
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricSignDigest_TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1_Success()
{
    TEEC_Result result = Invoke_Crypto_AsymmetricSignDigest_TEE_ALG_RSASSA_PKCS1(TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1, TEE_ALG_SHA1);
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricVerifyDigest_TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1_Success()
{
    TEEC_Result result = Invoke_Crypto_AsymmetricVerifyDigest_TEE_ALG_RSASSA_PKCS1(TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1, TEE_ALG_SHA1);
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricSignDigest_TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224_Success()
{
    TEEC_Result result = Invoke_Crypto_AsymmetricSignDigest_TEE_ALG_RSASSA_PKCS1(TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224, TEE_ALG_SHA224);
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricVerifyDigest_TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224_Success()
{
    TEEC_Result result = Invoke_Crypto_AsymmetricVerifyDigest_TEE_ALG_RSASSA_PKCS1(TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224, TEE_ALG_SHA224);
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricSignDigest_TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256_Success()
{
    TEEC_Result result = Invoke_Crypto_AsymmetricSignDigest_TEE_ALG_RSASSA_PKCS1(TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256, TEE_ALG_SHA256);
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricVerifyDigest_TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256_Success()
{
    TEEC_Result result = Invoke_Crypto_AsymmetricVerifyDigest_TEE_ALG_RSASSA_PKCS1(TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256, TEE_ALG_SHA256);
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricSignDigest_TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384_Success()
{
    TEEC_Result result = Invoke_Crypto_AsymmetricSignDigest_TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384_Success_01(TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384, TEE_ALG_SHA384);
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricVerifyDigest_TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384_Success()
{
    TEEC_Result result = Invoke_Crypto_AsymmetricVerifyDigest_TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384_Success_01(TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384, TEE_ALG_SHA384);
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricSignDigest_TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512_Success()
{
    TEEC_Result result = Invoke_Crypto_AsymmetricSignDigest_TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384_Success_01(TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512, TEE_ALG_SHA512);
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricVerifyDigest_TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512_Success()
{
    TEEC_Result result = Invoke_Crypto_AsymmetricVerifyDigest_TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384_Success_01(TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512, TEE_ALG_SHA512);
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricSignDigest_TEE_ALG_RSASSA_PKCS1_V1_5_SHA1_Success()
{
    TEEC_Result result = Invoke_Crypto_AsymmetricSignDigest_TEE_ALG_RSASSA_PKCS1(TEE_ALG_RSASSA_PKCS1_V1_5_SHA1, TEE_ALG_SHA1);
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricVerifyDigest_TEE_ALG_RSASSA_PKCS1_V1_5_SHA1_Success()
{
    TEEC_Result result = Invoke_Crypto_AsymmetricVerifyDigest_TEE_ALG_RSASSA_PKCS1(TEE_ALG_RSASSA_PKCS1_V1_5_SHA1, TEE_ALG_SHA1);
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricSignDigest_TEE_ALG_RSASSA_PKCS1_V1_5_SHA224_Success()
{
    TEEC_Result result = Invoke_Crypto_AsymmetricSignDigest_TEE_ALG_RSASSA_PKCS1(TEE_ALG_RSASSA_PKCS1_V1_5_SHA224, TEE_ALG_SHA224);
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricVerifyDigest_TEE_ALG_RSASSA_PKCS1_V1_5_SHA224_Success()
{
    TEEC_Result result = Invoke_Crypto_AsymmetricVerifyDigest_TEE_ALG_RSASSA_PKCS1(TEE_ALG_RSASSA_PKCS1_V1_5_SHA224, TEE_ALG_SHA224);
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricSignDigest_TEE_ALG_RSASSA_PKCS1_V1_5_SHA256_Success()
{
    TEEC_Result result = Invoke_Crypto_AsymmetricSignDigest_TEE_ALG_RSASSA_PKCS1(TEE_ALG_RSASSA_PKCS1_V1_5_SHA256, TEE_ALG_SHA256);
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricVerifyDigest_TEE_ALG_RSASSA_PKCS1_V1_5_SHA256_Success()
{
    TEEC_Result result = Invoke_Crypto_AsymmetricVerifyDigest_TEE_ALG_RSASSA_PKCS1(TEE_ALG_RSASSA_PKCS1_V1_5_SHA256, TEE_ALG_SHA256);
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricSignDigest_TEE_ALG_RSASSA_PKCS1_V1_5_SHA384_Success()
{
    TEEC_Result result = Invoke_Crypto_AsymmetricSignDigest_TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384_Success_01(TEE_ALG_RSASSA_PKCS1_V1_5_SHA384, TEE_ALG_SHA384);
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricVerifyDigest_TEE_ALG_RSASSA_PKCS1_V1_5_SHA384_Success()
{
    TEEC_Result result = Invoke_Crypto_AsymmetricVerifyDigest_TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384_Success_01(TEE_ALG_RSASSA_PKCS1_V1_5_SHA384, TEE_ALG_SHA384);
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricSignDigest_TEE_ALG_RSASSA_PKCS1_V1_5_SHA512_Success()
{
    TEEC_Result result = Invoke_Crypto_AsymmetricSignDigest_TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384_Success_01(TEE_ALG_RSASSA_PKCS1_V1_5_SHA512, TEE_ALG_SHA512);
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricVerifyDigest_TEE_ALG_RSASSA_PKCS1_V1_5_SHA512_Success()
{
    TEEC_Result result = Invoke_Crypto_AsymmetricVerifyDigest_TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384_Success_01(TEE_ALG_RSASSA_PKCS1_V1_5_SHA512, TEE_ALG_SHA512);
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricSignDigest_incompatible_mode()
{
    TEEC_Result result = Invoke_Crypto_AsymmetricSignDigest_incompatible_mode_01(TEE_ALG_RSASSA_PKCS1_V1_5_SHA1, TEE_ALG_SHA1);
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricSignDigest_invalid_operation_class()
{
    TEEC_Result result = Invoke_Crypto_AsymmetricSignDigest_invalid_operation_class_01(TEE_ALG_SHA256, TEE_ALG_SHA256);
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricSignDigest_invalid_value_handle()
{
    TEEC_Result result = Invoke_Crypto_AsymmetricSignDigest_invalid_value_handle_01(TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1, TEE_ALG_SHA256);
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricSignDigest_no_key_programmed()
{
    TEEC_Result result = Invoke_Crypto_AsymmetricSignDigest_no_key_programmed_01(TEE_ALG_DSA_SHA1, TEE_ALG_SHA256);
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricSignDigest_short_buffer()
{
    TEEC_Result result = Invoke_Crypto_AsymmetricSignDigest_short_buffer_01(TEE_ALG_DSA_SHA1, TEE_ALG_SHA256);
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricVerifyDigest_incompatible_mode()
{
    TEEC_Result result = Invoke_Crypto_AsymmetricVerifyDigest_incompatible_mode_01(TEE_ALG_DSA_SHA1, TEE_ALG_SHA256);
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricVerifyDigest_invalid_operation_class()
{
    TEEC_Result result = Invoke_Crypto_AsymmetricVerifyDigest_invalid_operation_class_01(TEE_ALG_MD5, TEE_ALG_MD5);
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricVerifyDigest_invalid_signature()
{
    TEEC_Result result = Invoke_Crypto_AsymmetricVerifyDigest_invalid_signature_01(TEE_ALG_DSA_SHA1 , TEE_ALG_MD5);
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricVerifyDigest_invalid_value_handle()
{
    TEEC_Result result = Invoke_Crypto_AsymmetricVerifyDigest_invalid_value_handle_01(TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1, TEE_ALG_SHA1);
    return result;
}

TEEC_Result Invoke_Crypto_AsymmetricVerifyDigest_no_key_programmed()
{
    TEEC_Result result = Invoke_Crypto_AsymmetricVerifyDigest_no_key_programmed_01(TEE_ALG_DSA_SHA1, TEE_ALG_SHA256);
    return result;
}

TEEC_Result Invoke_Crypto_AEDecryptFinal_short_buffer()
{
    TEEC_Result result = Invoke_Crypto_AEDecryptFinal_short_buffer_01(AES_128_bits, VALID_MAC, TEE_ALG_AES_GCM, OUTPUT_BUFFER_TOO_SHORT, TEE_MODE_ENCRYPT, 0);
    return result;
}

TEEC_Result Invoke_Crypto_AEEncryptFinal_invalid_operation_class()
{
    TEEC_Result result = Invoke_Crypto_AEEncryptFinal_invalid_operation_class_01(AES_128_bits, VALID_MAC, TEE_ALG_SHA224, OUTPUT_BUFFER_NORMAL, TEE_MODE_DIGEST, 0);
    return result;
}

TEEC_Result Invoke_Crypto_AEEncryptFinal_invalid_value_handle()
{
    TEEC_Result result = Invoke_Crypto_AEEncryptFinal_invalid_value_handle_01(AES_128_bits, VALID_MAC, TEE_ALG_AES_GCM, OUTPUT_BUFFER_NORMAL, TEE_MODE_ENCRYPT, 0);
    return result;
}

TEEC_Result Invoke_Crypto_AEEncryptFinal_operation_not_started()
{
    TEEC_Result result = Invoke_Crypto_AEEncryptFinal_operation_not_started_01(AES_128_bits, VALID_MAC, TEE_ALG_AES_CCM, OUTPUT_BUFFER_NORMAL, TEE_MODE_ENCRYPT, 0);
    return result;
}

TEEC_Result Invoke_Crypto_AEEncryptFinal_short_buffer()
{
    TEEC_Result result = Invoke_Crypto_AEEncryptFinal_short_buffer_01(AES_128_bits, VALID_MAC, TEE_ALG_AES_GCM, OUTPUT_BUFFER_TOO_SHORT, TEE_MODE_ENCRYPT, 0);
    return result;
}

TEEC_Result Invoke_Crypto_AEInit_AES_104_bits_TEE_ALG_AES_CCM_tag_length_not_supported()
{
    TEEC_Result result = Invoke_Crypto_AEInit_AES_104_bits_TEE_ALG_AES_CCM_tag_length_not_supported_01(AES_104_bits, VALID_MAC, TEE_ALG_AES_CCM, OUTPUT_BUFFER_NORMAL, TEE_MODE_DECRYPT, 0);
    return result;
}

TEEC_Result Invoke_Crypto_AEInit_AES_120_bits_TEE_ALG_AES_CCM_tag_length_not_supported()
{
    TEEC_Result result = Invoke_Crypto_AEInit_AES_120_bits_TEE_ALG_AES_CCM_tag_length_not_supported_01(AES_120_bits, VALID_MAC, TEE_ALG_AES_CCM, OUTPUT_BUFFER_NORMAL, TEE_MODE_DECRYPT, 0);
    return result;
}

TEEC_Result Invoke_Crypto_AEInit_AES_32_bits_TEE_ALG_AES_GCM_tag_length_not_supported()
{
    TEEC_Result result = Invoke_Crypto_AEInit_AES_32_bits_TEE_ALG_AES_GCM_tag_length_not_supported_01(AES_32_bits, VALID_MAC, TEE_ALG_AES_GCM, OUTPUT_BUFFER_NORMAL, TEE_MODE_ENCRYPT, 0);
    return result;
}

TEEC_Result Invoke_Crypto_AEInit_AES_48_bits_TEE_ALG_AES_GCM_tag_length_not_supported()
{
    TEEC_Result result = Invoke_Crypto_AEInit_AES_48_bits_TEE_ALG_AES_GCM_tag_length_not_supported_01(AES_120_bits, VALID_MAC, TEE_ALG_AES_CCM, OUTPUT_BUFFER_NORMAL, TEE_MODE_DECRYPT, 0);
    return result;
}

TEEC_Result Invoke_Crypto_AEInit_AES_64_bits_TEE_ALG_AES_GCM_tag_length_not_supported()
{
    TEEC_Result result = Invoke_Crypto_AEInit_AES_64_bits_TEE_ALG_AES_GCM_tag_length_not_supported_01(AES_64_bits, VALID_MAC, TEE_ALG_AES_GCM, OUTPUT_BUFFER_NORMAL, TEE_MODE_DECRYPT, 0);
    return result;
}

TEEC_Result Invoke_Crypto_AEInit_incompatible_nonce_length()
{
    TEEC_Result result = Invoke_Crypto_AEInit_incompatible_nonce_length_01(AES_128_bits, VALID_MAC, TEE_ALG_AES_GCM, OUTPUT_BUFFER_NORMAL, TEE_MODE_ENCRYPT, 0);
    return result;
}

TEEC_Result Invoke_Crypto_AEInit_invalid_operation_class()
{
    TEEC_Result result = Invoke_Crypto_AEInit_invalid_operation_class_01(AES_128_bits, VALID_MAC, TEE_ALG_AES_ECB_NOPAD, OUTPUT_BUFFER_NORMAL, TEE_MODE_ENCRYPT, 0);
    return result;
}

TEEC_Result Invoke_Crypto_AEInit_invalid_value_handle()
{
    TEEC_Result result = Invoke_Crypto_AEInit_invalid_value_handle_01(AES_128_bits, VALID_MAC, TEE_ALG_AES_ECB_NOPAD, OUTPUT_BUFFER_NORMAL, TEE_MODE_ENCRYPT, 0);
    return result;
}

TEEC_Result Invoke_Crypto_AEInit_no_key_programmed()
{
    TEEC_Result result = Invoke_Crypto_AEInit_no_key_programmed_01(AES_128_bits, VALID_MAC, TEE_ALG_AES_GCM, OUTPUT_BUFFER_NORMAL, TEE_MODE_DECRYPT, 0);
    return result;
}

TEEC_Result Invoke_Crypto_AEUpdateAAD_AAD_length_reached()
{
    TEEC_Result result = Invoke_Crypto_AEUpdateAAD_AAD_length_reached_01(AES_128_bits, VALID_MAC, TEE_ALG_AES_CCM, OUTPUT_BUFFER_NORMAL, TEE_MODE_DECRYPT, 0);
    return result;
}

TEEC_Result Invoke_Crypto_AEUpdateAAD_invalid_operation_class()
{
    TEEC_Result result = Invoke_Crypto_AEUpdateAAD_invalid_operation_class_01(AES_128_bits, VALID_MAC, TEE_ALG_MD5, OUTPUT_BUFFER_NORMAL, TEE_MODE_DIGEST, 0);
    return result;
}

TEEC_Result Invoke_Crypto_AEUpdateAAD_invalid_value_handle()
{
    TEEC_Result result = Invoke_Crypto_AEUpdateAAD_invalid_value_handle_01(AES_128_bits, VALID_MAC, TEE_ALG_MD5, OUTPUT_BUFFER_NORMAL, TEE_MODE_DIGEST, 0);
    return result;
}

TEEC_Result Invoke_Crypto_AEUpdateAAD_operation_not_started()
{
    TEEC_Result result = Invoke_Crypto_AEUpdateAAD_operation_not_started_01(AES_32_bits, VALID_MAC, TEE_ALG_AES_GCM, OUTPUT_BUFFER_NORMAL, TEE_MODE_DIGEST, 0);
    return result;
}

TEEC_Result Invoke_Crypto_AEUpdate_AAD_length_not_provided()
{
    TEEC_Result result = Invoke_Crypto_AEUpdate_AAD_length_not_provided_01(AES_128_bits, VALID_MAC, TEE_ALG_AES_CCM, OUTPUT_BUFFER_NORMAL, TEE_MODE_ENCRYPT, 0);
    return result;
}

TEEC_Result Invoke_Crypto_AEUpdate_invalid_operation_class()
{
    TEEC_Result result = Invoke_Crypto_AEUpdate_invalid_operation_class_01(AES_128_bits, VALID_MAC, TEE_ALG_MD5, OUTPUT_BUFFER_NORMAL, TEE_MODE_DIGEST, 0);
    return result;
}

TEEC_Result Invoke_Crypto_AEUpdate_invalid_value_handle()
{
    TEEC_Result result = Invoke_Crypto_AEUpdate_invalid_value_handle_01(AES_128_bits, VALID_MAC, TEE_ALG_MD5, OUTPUT_BUFFER_NORMAL, TEE_MODE_DIGEST, 0);
    return result;
}

TEEC_Result Invoke_Crypto_AEUpdate_short_buffer()
{
    TEEC_Result result = Invoke_Crypto_AEDecryptFinal_AES_TEE_ALG_AES_CCM_Success(AES_128_bits, VALID_MAC, TEE_ALG_AES_CCM, OUTPUT_BUFFER_TOO_SHORT, TEE_MODE_SIGN, 1);
    #if 0
    if(result == TEE_ERROR_SHORT_BUFFER)
        result = TEEC_SUCCESS;
    #endif
    return result;
}

TEEC_Result Invoke_Crypto_CopyOperation_source_key_empty_Success()
{
    TEEC_Result result;
    TEEC_Context context02;
    TEEC_Session session01;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));
    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.started = 1;
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }
    //Invoke_Crypto_InitObjectWithKeys
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }

    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_AES_XTS;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_AES_256/8;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_01;
    operation.params[1].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey2, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_AES_XTS;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_AES_256/8;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

     //Invoke_Crypto_GetOperationInfo
     operation.paramTypes = TEEC_PARAM_TYPES(
         TEEC_VALUE_INOUT,
         TEEC_VALUE_OUTPUT,
         TEEC_VALUE_OUTPUT,
         TEEC_VALUE_OUTPUT);
     operation.params[0].value.a = OPERATION_HANDLE_02;
     result = TEEC_InvokeCommand(&session01, CMD_Crypto_GetOperationInfo, &operation, &origin);
     if (result != TEEC_SUCCESS) {
         TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
         goto cleanup_4;
     }

     //check output param is right or not
     if(operation.params[0].value.a == TEE_ALG_AES_XTS &&
         operation.params[0].value.b == TEE_OPERATION_CIPHER &&
         operation.params[1].value.a == TEE_MODE_ENCRYPT &&
         operation.params[1].value.b == SIZE_ZERO &&
         operation.params[2].value.a == (SIZE_AES_256/8 + SIZE_AES_256/8) &&
         operation.params[2].value.b == SIZE_AES_256/8 &&
         operation.params[3].value.a == TEE_USAGE_ENCRYPT &&
         operation.params[3].value.b == 0x000c0000){
         TEEC_Debug("Invoke_Crypto_GetOperationInfo success\n");
     }else{
         TEEC_Error("Invoke_Crypto_GetOperationInfo failed\n");
         TEEC_Error("OUT_algorithm=%x, OUT_operationClass=%x\n", operation.params[0].value.a, operation.params[0].value.b);
         TEEC_Error("OUT_mode=%x, OUT_digestLength=%x\n", operation.params[1].value.a, operation.params[1].value.b);
         TEEC_Error("OUT_maxKeySize_object1=%x, OUT_keySize=%x\n", operation.params[2].value.a, operation.params[2].value.b);
         TEEC_Error("OUT_requiredKeyUsage=%x, OUT_handleState=%x\n", operation.params[3].value.a, operation.params[3].value.b);
     }

    //Invoke_Crypto_CopyOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CopyOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }

    //Invoke_Crypto_GetOperationInfo
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INOUT,
        TEEC_VALUE_OUTPUT,
        TEEC_VALUE_OUTPUT,
        TEEC_VALUE_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_GetOperationInfo, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //check output param is right or not
    if(operation.params[0].value.a == TEE_ALG_AES_XTS &&
        operation.params[0].value.b == TEE_OPERATION_CIPHER &&
        operation.params[1].value.a == TEE_MODE_ENCRYPT &&
        operation.params[1].value.b == SIZE_ZERO &&
        operation.params[2].value.a == (SIZE_AES_256/8 + SIZE_AES_256/8) &&
        operation.params[2].value.b == 0 &&
        operation.params[3].value.a == TEE_USAGE_ENCRYPT &&
        operation.params[3].value.b == 0x00080000){
        TEEC_Debug("Invoke_Crypto_GetOperationInfo success\n");
    }else{
        TEEC_Error("Invoke_Crypto_GetOperationInfo failed\n");
        TEEC_Error("OUT_algorithm=%x, OUT_operationClass=%x\n", operation.params[0].value.a, operation.params[0].value.b);
        TEEC_Error("OUT_mode=%x, OUT_digestLength=%x\n", operation.params[1].value.a, operation.params[1].value.b);
        TEEC_Error("OUT_maxKeySize_object1=%x, OUT_keySize=%x\n", operation.params[2].value.a, operation.params[2].value.b);
        TEEC_Error("OUT_requiredKeyUsage=%x, OUT_handleState=%x\n", operation.params[3].value.a, operation.params[3].value.b);
    }

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_CopyOperation_source_key_not_empty_Success()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[3][32] = {0};
    uint8_t decrypt_result[3][32] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
	operation.started = 1;
//Invoke_Crypto_InitObjectWithKeys
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("1 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }
	//Invoke_Crypto_InitObjectWithKeys
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("2 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }


    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_AES_XTS;//TEE_ALG_AES_ECB_NOPAD;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_AES_256/8;//
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("3  invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_SetOperationKey2
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_02;
    operation.params[1].value.a = OBJECT_HANDLE_01;

    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey2, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("4 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
	//Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_AES_XTS;//TEE_ALG_AES_ECB_NOPAD;
    operation.params[0].value.b = TEE_MODE_ENCRYPT;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_AES_256/8;//
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("5 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
	//Invoke_Crypto_CopyOperation
	operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;//TEE_ALG_AES_ECB_NOPAD;
    operation.params[0].value.b = OPERATION_HANDLE_02;

    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CopyOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("6  invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
	//Invoke_Crypto_CipherInit
	memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(SharedMem1.buffer, (void *)IV2_VALUE_128bits_AES, sizeof(IV2_VALUE_128bits_AES));

    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(IV2_VALUE_128bits_AES);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("7 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    //Invoke_Crypto_CipherUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("8 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[0], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART1));

    //Invoke_Crypto_CipherUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("9 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[1], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART2));

    //Invoke_Crypto_CipherDoFinal
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CipherDoFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("10 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
    memcpy(encrypt_result[2], SharedMem2.buffer, sizeof(DATA_FOR_CRYPTO1_PART3));

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("11 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("12 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_CopyOperation_algo_and_modes_differ()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[3][32] = {0};
    uint8_t decrypt_result[3][32] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }
    operation.started = 1;
    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_MD5;//TEE_ALG_AES_ECB_NOPAD;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_ZERO + SIZE_ZERO;//
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("1 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
     //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_SHA224;//TEE_ALG_AES_ECB_NOPAD;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_ZERO + SIZE_ZERO;//
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("2 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
	//Invoke_Crypto_CopyOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;//TEE_ALG_AES_ECB_NOPAD;
    operation.params[0].value.b = OPERATION_HANDLE_02;

    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CopyOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("2 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_CopyOperation_dst_operation_handle_not_valid()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[3][32] = {0};
    uint8_t decrypt_result[3][32] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
    }
	operation.started = 1;
     //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_MD5;//TEE_ALG_AES_ECB_NOPAD;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_ZERO + SIZE_ZERO;//
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("1 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
	//Invoke_Crypto_CopyOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_INVALID;//TEE_ALG_AES_ECB_NOPAD;
    operation.params[0].value.b = OPERATION_HANDLE_02;

    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CopyOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("2 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_CopyOperation_src_key_size_greater_than_dest_max_key_size()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[3][32] = {0};
    uint8_t decrypt_result[3][32] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_HMAC_SHA256_512_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_HMAC_SHA256_512_VALUE01, sizeof(TEE_ATTR_HMAC_SHA256_512_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
	operation.started = 1;
//Invoke_Crypto_InitObjectWithKeys
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_HMAC_SHA256;
    operation.params[0].value.b = SIZE_HMAC_SHA256_512/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_HMAC_SHA256_512_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("1 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }

    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_HMAC_SHA256;//TEE_ALG_AES_ECB_NOPAD;
    operation.params[0].value.b = TEE_MODE_MAC;
    operation.params[1].value.a = SIZE_HMAC_SHA256_512/8 +SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("3  invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_01;

    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("4 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
	//Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_HMAC_SHA256;//TEE_ALG_AES_ECB_NOPAD;
    operation.params[0].value.b = TEE_MODE_MAC;
    operation.params[1].value.a = SIZE_HMAC_SHA224_256/8 +SIZE_ZERO;//
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("5 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
	//Invoke_Crypto_CopyOperation
	operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;//TEE_ALG_AES_ECB_NOPAD;
    operation.params[0].value.b = OPERATION_HANDLE_01;

    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CopyOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("6  invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_CopyOperation_src_operation_handle_not_valid()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[3][32] = {0};
    uint8_t decrypt_result[3][32] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_HMAC_SHA256_512_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_HMAC_SHA256_512_VALUE01, sizeof(TEE_ATTR_HMAC_SHA256_512_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
	operation.started = 1;

    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_SHA256;//TEE_ALG_AES_ECB_NOPAD;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_ZERO+SIZE_ZERO;
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("3  invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
	//Invoke_Crypto_CopyOperation
	operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;//TEE_ALG_AES_ECB_NOPAD;
    operation.params[0].value.b = OPERATION_HANDLE_INVALID;

    result = TEEC_InvokeCommand(&session01, CMD_Crypto_CopyOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("6  invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_DeriveKey_invalid_value_handle()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[3][32] = {0};
    uint8_t decrypt_result[3][32] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");

    }
	operation.started = 1;

   //Invoke_Crypto_DeriveKey
	operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_INVALID;//TEE_ALG_AES_ECB_NOPAD;
    operation.params[0].value.b = OBJECT_HANDLE_01;

    result = TEEC_InvokeCommand(&session01, CMD_Crypto_DeriveKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("6  invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

cleanup_4:
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_GetOperationInfo_operation_handle_not_valid()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[3][32] = {0};
    uint8_t decrypt_result[3][32] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }
	operation.started = 1;

	//Invoke_Crypto_GetOperationInfo
     operation.paramTypes = TEEC_PARAM_TYPES(
         TEEC_VALUE_INOUT,
         TEEC_VALUE_OUTPUT,
         TEEC_VALUE_OUTPUT,
         TEEC_VALUE_OUTPUT);
     operation.params[0].value.a = OPERATION_HANDLE_INVALID;
     result = TEEC_InvokeCommand(&session01, CMD_Crypto_GetOperationInfo, &operation, &origin);
     if (result != TEEC_SUCCESS) {
         TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
         goto cleanup_4;
     }

     //check output param is right or not
     if(operation.params[0].value.a == TEE_ALG_AES_CBC_NOPAD &&
         operation.params[0].value.b == TEE_OPERATION_MAC &&
         operation.params[1].value.a == TEE_MODE_VERIFY &&
         operation.params[1].value.b == SIZE_AES_256/8 &&
         operation.params[2].value.a == (SIZE_AES_256/8 + SIZE_AES_256/8) &&
         operation.params[2].value.b == SIZE_AES_256/8 &&
         operation.params[3].value.a == 0 &&
         operation.params[3].value.b == 0x000e0000){
         TEEC_Debug("Invoke_Crypto_GetOperationInfo success\n");
     }else{
         TEEC_Error("Invoke_Crypto_GetOperationInfo failed\n");
         TEEC_Error("OUT_algorithm=%x, OUT_operationClass=%x\n", operation.params[0].value.a, operation.params[0].value.b);
         TEEC_Error("OUT_mode=%x, OUT_digestLength=%x\n", operation.params[1].value.a, operation.params[1].value.b);
         TEEC_Error("OUT_maxKeySize_object1=%x, OUT_keySize=%x\n", operation.params[2].value.a, operation.params[2].value.b);
         TEEC_Error("OUT_requiredKeyUsage=%x, OUT_handleState=%x\n", operation.params[3].value.a, operation.params[3].value.b);
     }
cleanup_4:
cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_DeriveKey_incompatible_mode_invalid_operation_class()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[3][32] = {0};
    uint8_t decrypt_result[3][32] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
	operation.started = 1;
    //Invoke_Crypto_InitObjectWithKeys
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("1 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }

    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_AES_CCM;//TEE_ALG_AES_ECB_NOPAD;
    operation.params[0].value.b = TEE_MODE_DECRYPT;
    operation.params[1].value.a = SIZE_AES_256/8 + SIZE_ZERO;//
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("3  invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[0].value.b = OBJECT_HANDLE_02;

    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("4 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
	//Invoke_Crypto_DeriveKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;//TEE_ALG_AES_ECB_NOPAD;
    operation.params[0].value.b = OBJECT_HANDLE_01;

    result = TEEC_InvokeCommand(&session01, CMD_Crypto_DeriveKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("5 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_DeriveKey_no_key_programmed()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[3][32] = {0};
    uint8_t decrypt_result[3][32] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_DH_PRIME), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_DH_PRIME_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+12, retrieveUint32toBuffer(TEE_ATTR_DH_BASE), sizeof(uint32_t));
    memcpy(IN_AttributeID+16, retrieveUint32toBuffer(sizeof(TEE_ATTR_DH_PRIME_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+20, retrieveUint32toBuffer(sizeof(TEE_ATTR_DH_BASE_VALUE01)), sizeof(uint32_t));
    memcpy(IN_AttributeID+24, retrieveUint32toBuffer(TEE_ATTR_DH_PUBLIC_VALUE), sizeof(uint32_t)); //
    memcpy(IN_AttributeID+28, retrieveUint32toBuffer(sizeof(TEE_ATTR_DH_PRIME_VALUE01)+sizeof(TEE_ATTR_DH_BASE_VALUE01)), sizeof(uint32_t));//
    memcpy(IN_AttributeID+32, retrieveUint32toBuffer(sizeof(TEE_ATTR_DH_PUBLIC_VALUE_VALUE01)), sizeof(uint32_t));//
    memcpy(IN_AttributeID+36, retrieveUint32toBuffer(TEE_ATTR_DH_PRIVATE_VALUE), sizeof(uint32_t)); //
    memcpy(IN_AttributeID+40, retrieveUint32toBuffer(sizeof(TEE_ATTR_DH_PRIME_VALUE01)+sizeof(TEE_ATTR_DH_BASE_VALUE01)+sizeof(TEE_ATTR_DH_PUBLIC_VALUE_VALUE01)), sizeof(uint32_t));//
    memcpy(IN_AttributeID+44, retrieveUint32toBuffer(sizeof(TEE_ATTR_DH_PRIVATE_VALUE_VALUE01)), sizeof(uint32_t));//

	memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_DH_PRIME_VALUE01, sizeof(TEE_ATTR_DH_PRIME_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_DH_PRIME_VALUE01), (void *)TEE_ATTR_DH_BASE_VALUE01, sizeof(TEE_ATTR_DH_BASE_VALUE01));
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_DH_PRIME_VALUE01)+sizeof(TEE_ATTR_DH_BASE_VALUE01), (void *)TEE_ATTR_DH_PUBLIC_VALUE_VALUE01, sizeof(TEE_ATTR_DH_PUBLIC_VALUE_VALUE01));//
    memcpy(SharedMem2.buffer+sizeof(TEE_ATTR_DH_PRIME_VALUE01)+sizeof(TEE_ATTR_DH_BASE_VALUE01)+sizeof(TEE_ATTR_DH_PUBLIC_VALUE_VALUE01), (void *)TEE_ATTR_DH_PRIVATE_VALUE_VALUE01, sizeof(TEE_ATTR_DH_PRIVATE_VALUE_VALUE01));//

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
	operation.started = 1;
    //Invoke_Crypto_InitObjectWithKeys
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_DH_KEYPAIR;
    operation.params[0].value.b = SIZE_DH_KEYPAIR_1024/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_DH_PRIME_VALUE01)+sizeof(TEE_ATTR_DH_BASE_VALUE01)+sizeof(TEE_ATTR_DH_PUBLIC_VALUE_VALUE01)+sizeof(TEE_ATTR_DH_PRIVATE_VALUE_VALUE01);//
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("1 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }

    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_DH_DERIVE_SHARED_SECRET;//TEE_ALG_AES_ECB_NOPAD;
    operation.params[0].value.b = TEE_MODE_DERIVE;
    operation.params[1].value.a = SIZE_DH_KEYPAIR_1024/8 + SIZE_ZERO;//
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("3  invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

	//Invoke_Crypto_DeriveKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;//TEE_ALG_AES_ECB_NOPAD;
    operation.params[0].value.b = OBJECT_HANDLE_01;

    result = TEEC_InvokeCommand(&session01, CMD_Crypto_DeriveKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("5 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_DigestDoFinal_invalid_operation_class()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[3][32] = {0};
    uint8_t decrypt_result[3][32] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
	operation.started = 1;

	//Invoke_Crypto_InitObjectWithKeys
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_AES;
    operation.params[0].value.b = SIZE_AES_256/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_AES_256_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("2 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }


    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_AES_CBC_MAC_NOPAD;//TEE_ALG_AES_ECB_NOPAD;
    operation.params[0].value.b = TEE_MODE_MAC;
    operation.params[1].value.a = SIZE_AES_256/8 +SIZE_ZERO;//
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("3  invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_SetOperationKey
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[0].value.b = OBJECT_HANDLE_01;

    result = TEEC_InvokeCommand(&session01, CMD_Crypto_SetOperationKey, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("4 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_MACInit
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 0;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACInit, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_4;
    }
	//Invoke_Crypto_MACUpdate
	memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
	operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);//IN_AttributeID
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("4 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
	//Invoke_Crypto_MACUpdate
	memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
	operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);//IN_AttributeID
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("4 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
	//Invoke_Crypto_DigestDoFinal
	memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
	memcpy(SharedMem2.buffer, (void *)DATA_FOR_CRYPTO1, sizeof(DATA_FOR_CRYPTO1));
	operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);//IN_AttributeID
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1);//IN_AttributeID
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_DigestDoFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("4 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_DigestDoFinal_invalid_value_handle()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[3][32] = {0};
    uint8_t decrypt_result[3][32] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    //memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
	operation.started = 1;

	//Invoke_Crypto_DigestDoFinal
	memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
	memcpy(SharedMem2.buffer, (void *)DATA_FOR_CRYPTO1, sizeof(DATA_FOR_CRYPTO1));
	operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_INVALID;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);//IN_AttributeID
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1);//IN_AttributeID
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_DigestDoFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("4 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
cleanup_4:
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_DigestDoFinal_short_buffer()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[3][32] = {0};
    uint8_t decrypt_result[3][32] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    //memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    //memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_AES_256_VALUE01)), sizeof(uint32_t));
   // memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
   // memcpy(SharedMem2.buffer, (void *)TEE_ATTR_AES_256_VALUE01, sizeof(TEE_ATTR_AES_256_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
	operation.started = 1;

    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_MD5;//TEE_ALG_AES_ECB_NOPAD;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_ZERO +SIZE_ZERO;//
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("3  invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

	//Invoke_Crypto_DigestUpdate
	memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
	operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);//IN_AttributeID

    result = TEEC_InvokeCommand(&session01, CMD_Crypto_DigestUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("4 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
	//Invoke_Crypto_DigestUpdate
	memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART2, sizeof(DATA_FOR_CRYPTO1_PART2));
	operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART2);//IN_AttributeID

    result = TEEC_InvokeCommand(&session01, CMD_Crypto_DigestUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("4 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
	//Invoke_Crypto_DigestDoFinal
	memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART3, sizeof(DATA_FOR_CRYPTO1_PART3));
	memcpy(SharedMem2.buffer, (void *)DATA_FOR_CRYPTO1, sizeof(DATA_FOR_CRYPTO1));
	operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART3);//IN_AttributeID
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = 1;//IN_AttributeID
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_DigestDoFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("4 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_DigestUpdate_invalid_operation_class()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[3][32] = {0};
    uint8_t decrypt_result[3][32] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_HMAC_SHA512_512_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_HMAC_SHA512_512_VALUE01, sizeof(TEE_ATTR_HMAC_SHA512_512_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
	operation.started = 1;

	//Invoke_Crypto_InitObjectWithKeys
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_HMAC_SHA512;
    operation.params[0].value.b = SIZE_HMAC_SHA512_512/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_HMAC_SHA512_512_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("2 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }


    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_HMAC_SHA512;//TEE_ALG_AES_ECB_NOPAD;
    operation.params[0].value.b = TEE_MODE_MAC;
    operation.params[1].value.a = SIZE_HMAC_SHA512_512/8 +SIZE_ZERO;//
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("3  invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

	//Invoke_Crypto_DigestUpdate
	memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
	operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);//IN_AttributeID
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_DigestUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("4 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_DigestUpdate_invalid_value_handle()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[3][32] = {0};
    uint8_t decrypt_result[3][32] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_HMAC_SHA512_512_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_HMAC_SHA512_512_VALUE01, sizeof(TEE_ATTR_HMAC_SHA512_512_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
	operation.started = 1;

	//Invoke_Crypto_DigestUpdate
	memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
	operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_INVALID;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);//IN_AttributeID

    result = TEEC_InvokeCommand(&session01, CMD_Crypto_DigestUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("4 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

cleanup_4:
    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;
}

TEEC_Result Invoke_Crypto_MACUpdate_invalid_operation_class()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[3][32] = {0};
    uint8_t decrypt_result[3][32] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
	operation.started = 1;

    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_MD5;//TEE_ALG_AES_ECB_NOPAD;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_ZERO +SIZE_ZERO;//
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("3  invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

	//Invoke_Crypto_MACUpdate
	memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
	operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);//IN_AttributeID

    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("4 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }

cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_MACCompareFinal_operation_not_started()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[3][32] = {0};
    uint8_t decrypt_result[3][32] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_DES_64_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_DES_64_VALUE01, sizeof(TEE_ATTR_DES_64_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
	operation.started = 1;

	//Invoke_Crypto_InitObjectWithKeys
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_DES;
    operation.params[0].value.b = SIZE_DES_64/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_DES_64_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("2 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }


    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_DES_CBC_MAC_PKCS5;//TEE_ALG_AES_ECB_NOPAD;
    operation.params[0].value.b = TEE_MODE_MAC;
    operation.params[1].value.a = SIZE_DES_64/8 +SIZE_ZERO;//
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("3  invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_MACCompareFinal
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    memcpy(SharedMem2.buffer, (void *)DATA_FOR_CRYPTO1, sizeof(DATA_FOR_CRYPTO1));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;//TEE_ALG_AES_ECB_NOPAD
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(DATA_FOR_CRYPTO1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACCompareFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("3  invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_MACComputeFinal_operation_not_started()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[3][32] = {0};
    uint8_t decrypt_result[3][32] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_DES_64_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_DES_64_VALUE01, sizeof(TEE_ATTR_DES_64_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
	operation.started = 1;

	//Invoke_Crypto_InitObjectWithKeys
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_DES;
    operation.params[0].value.b = SIZE_DES_64/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_DES_64_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("2 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }


    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_DES_CBC_MAC_PKCS5;//TEE_ALG_AES_ECB_NOPAD;
    operation.params[0].value.b = TEE_MODE_MAC;
    operation.params[1].value.a = SIZE_DES_64/8 +SIZE_ZERO;//
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("3  invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_MACComputeFinal
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    memcpy(SharedMem2.buffer, (void *)DATA_FOR_CRYPTO1, sizeof(DATA_FOR_CRYPTO1));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_MEMREF_PARTIAL_OUTPUT);
    operation.params[0].value.a = OPERATION_HANDLE_01;//TEE_ALG_AES_ECB_NOPAD
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);
    operation.params[3].memref.parent = &SharedMem2;
    operation.params[3].memref.offset = 0;
    operation.params[3].memref.size = sizeof(DATA_FOR_CRYPTO1);
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACComputeFinal, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("3  invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_MACUpdate_operation_not_started()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    TEEC_SharedMemory SharedMem1;
    TEEC_SharedMemory SharedMem2;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[3][32] = {0};
    uint8_t decrypt_result[3][32] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }
    //Allocate a shared memory
    SharedMem1.buffer = NULL;
    SharedMem1.size = BIG_SIZE;
    SharedMem1.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem1);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem1.buffer, 0, BIG_SIZE);
    memcpy(IN_AttributeID, retrieveUint32toBuffer(TEE_ATTR_SECRET_VALUE), sizeof(uint32_t));
    memcpy(IN_AttributeID+8, retrieveUint32toBuffer(sizeof(TEE_ATTR_DES_64_VALUE01)), sizeof(uint32_t));
    memcpy(SharedMem1.buffer, (void *)IN_AttributeID, sizeof(IN_AttributeID));

    SharedMem2.buffer = NULL;
    SharedMem2.size = DS_BIG_SIZE;
    SharedMem2.flags = TEEC_MEM_INOUT;
    result = TEEC_AllocateSharedMemory(
                &context02,
                &SharedMem2);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("allocate failed\n");
        goto cleanup_3;
    }
    memset(SharedMem2.buffer, 0, DS_BIG_SIZE);
    memcpy(SharedMem2.buffer, (void *)TEE_ATTR_DES_64_VALUE01, sizeof(TEE_ATTR_DES_64_VALUE01));

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_3;
    }
	operation.started = 1;

	//Invoke_Crypto_InitObjectWithKeys
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_TYPE_DES;
    operation.params[0].value.b = SIZE_DES_64/8;
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = 4*3*5;//IN_AttributeID
    operation.params[2].memref.parent = &SharedMem2;
    operation.params[2].memref.offset = 0;
    operation.params[2].memref.size = sizeof(TEE_ATTR_DES_64_VALUE01);
    operation.params[3].value.a = OBJECT_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_InitObjectWithKeys, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("2 invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
        goto cleanup_3;
    }


    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_DES_CBC_MAC_NOPAD;//TEE_ALG_AES_ECB_NOPAD;
    operation.params[0].value.b = TEE_MODE_MAC;
    operation.params[1].value.a = SIZE_DES_64/8 +SIZE_ZERO;//
    operation.params[3].value.a = OPERATION_HANDLE_01;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("3  invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
    //Invoke_Crypto_MACUpdate
    memcpy(SharedMem1.buffer, (void *)DATA_FOR_CRYPTO1_PART1, sizeof(DATA_FOR_CRYPTO1_PART1));
    //memcpy(SharedMem2.buffer, (void *)DATA_FOR_CRYPTO1, sizeof(DATA_FOR_CRYPTO1));
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_MEMREF_PARTIAL_INPUT,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;//TEE_ALG_AES_ECB_NOPAD
    operation.params[1].memref.parent = &SharedMem1;
    operation.params[1].memref.offset = 0;
    operation.params[1].memref.size = sizeof(DATA_FOR_CRYPTO1_PART1);

    result = TEEC_InvokeCommand(&session01, CMD_Crypto_MACUpdate, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("3  invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_01;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

    //CloseSession
    TEEC_CloseSession(&session01);
cleanup_3:
    if(SharedMem1.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem1);
    if(SharedMem2.buffer)
        TEEC_ReleaseSharedMemory(&SharedMem2);
cleanup_2:
    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

TEEC_Result Invoke_Crypto_GetOperationInfo_Success()
{
    TEEC_Context context02;
    TEEC_Session session01;
    TEEC_Result result;
    uint32_t origin, i;
    TEEC_Operation operation;
    uint8_t IN_AttributeID[60] = {0};
    uint8_t encrypt_result[3][32] = {0};
    uint8_t decrypt_result[3][32] = {0};

    memset(&operation, 0, sizeof(TEEC_Operation));
    result = TEEC_InitializeContext(NULL, &context02);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec initial failed\n");
        goto cleanup_1;
    }

    //OpenSession
    result = TEEC_OpenSession(&context02, &session01, &uuid,
            TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if(result != TEEC_SUCCESS) {
        TEEC_Error("teec open session failed\n");
        goto cleanup_2;
    }
	operation.started = 1;

    //Invoke_Crypto_AllocateOperation
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_VALUE_INPUT);
    operation.params[0].value.a = TEE_ALG_MD5;//TEE_ALG_AES_ECB_NOPAD;
    operation.params[0].value.b = TEE_MODE_DIGEST;
    operation.params[1].value.a = SIZE_ZERO +SIZE_ZERO;//
    operation.params[3].value.a = OPERATION_HANDLE_02;
    result = TEEC_InvokeCommand(&session01, CMD_Crypto_AllocateOperation, &operation, &origin);
    if (result != TEEC_SUCCESS) {
        TEEC_Error("3  invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
    }
	//Invoke_Crypto_GetOperationInfo
     operation.paramTypes = TEEC_PARAM_TYPES(
         TEEC_VALUE_INOUT,
         TEEC_VALUE_OUTPUT,
         TEEC_VALUE_OUTPUT,
         TEEC_VALUE_OUTPUT);
     operation.params[0].value.a = OPERATION_HANDLE_02;
     result = TEEC_InvokeCommand(&session01, CMD_Crypto_GetOperationInfo, &operation, &origin);
     if (result != TEEC_SUCCESS) {
         TEEC_Error("invoke failed, codes=0x%x, origin=0x%x\n", result, origin);
         goto cleanup_4;
     }

     //check output param is right or not
     if(operation.params[0].value.a == TEE_ALG_MD5 &&
         operation.params[0].value.b == TEE_OPERATION_DIGEST &&
         operation.params[1].value.a == TEE_MODE_DIGEST &&
         operation.params[1].value.b == SIZE_ZERO &&
         operation.params[2].value.a == (SIZE_ZERO + SIZE_ZERO) &&
         operation.params[2].value.b == SIZE_ZERO &&
         operation.params[3].value.a == 0 &&
         operation.params[3].value.b == 0x00040000){
         TEEC_Debug("Invoke_Crypto_GetOperationInfo success\n");
     }else{
         TEEC_Error("Invoke_Crypto_GetOperationInfo failed\n");
         TEEC_Error("OUT_algorithm=%x, OUT_operationClass=%x\n", operation.params[0].value.a, operation.params[0].value.b);
         TEEC_Error("OUT_mode=%x, OUT_digestLength=%x\n", operation.params[1].value.a, operation.params[1].value.b);
         TEEC_Error("OUT_maxKeySize_object1=%x, OUT_keySize=%x\n", operation.params[2].value.a, operation.params[2].value.b);
         TEEC_Error("OUT_requiredKeyUsage=%x, OUT_handleState=%x\n", operation.params[3].value.a, operation.params[3].value.b);
     }
cleanup_4:
    //Invoke_Crypto_FreeAllKeysAndOperations
    operation.paramTypes = TEEC_PARAM_TYPES(
        TEEC_VALUE_INPUT,
        TEEC_NONE,
        TEEC_NONE,
        TEEC_NONE);
    operation.params[0].value.a = OPERATION_HANDLE_02;
    TEEC_InvokeCommand(&session01, CMD_Crypto_FreeAllKeysAndOperations, &operation, &origin);

cleanup_2:
	//CloseSession
    TEEC_CloseSession(&session01);

    //FinalizeContext
    TEEC_FinalizeContext(&context02);
cleanup_1:
    return result;

}

Test_GP_FUNC test_gp_func[] =
{
    COMMAND(Invoke_Crypto_GenerateRandom, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_AllocateOperation_TEE_ALG_AES_CBC_NOPAD_mode_not_allowed, TEEC_ERROR_NOT_SUPPORTED),
    COMMAND(Invoke_Crypto_AllocateOperation_TEE_ALG_AES_CMAC_mode_not_allowed, TEEC_ERROR_NOT_SUPPORTED),
    COMMAND(Invoke_Crypto_AllocateOperation_TEE_ALG_AES_CTR_mode_not_allowed, TEEC_ERROR_NOT_SUPPORTED),
    COMMAND(Invoke_Crypto_AllocateOperation_TEE_ALG_AES_ECB_NOPAD_mode_not_allowed, TEEC_ERROR_NOT_SUPPORTED),
    COMMAND(Invoke_Crypto_AllocateOperation_TEE_ALG_AES_XTS_mode_not_allowed, TEEC_ERROR_NOT_SUPPORTED),
    COMMAND(Invoke_Crypto_AllocateOperation_TEE_ALG_DES_CBC_NOPAD_mode_not_allowed, TEEC_ERROR_NOT_SUPPORTED),
    COMMAND(Invoke_Crypto_AllocateOperation_TEE_ALG_DES_ECB_NOPAD_mode_not_allowed, TEEC_ERROR_NOT_SUPPORTED),
    COMMAND(Invoke_Crypto_AllocateOperation_TEE_ALG_DES3_CBC_NOPAD_mode_not_allowed, TEEC_ERROR_NOT_SUPPORTED),
    COMMAND(Invoke_Crypto_AllocateOperation_TEE_ALG_DES3_ECB_NOPAD_mode_not_allowed, TEEC_ERROR_NOT_SUPPORTED),
    COMMAND(Invoke_Crypto_AllocateOperation_TEE_ALG_HMAC_SHA1_mode_not_allowed, TEEC_ERROR_NOT_SUPPORTED),
    COMMAND(Invoke_Crypto_AllocateOperation_TEE_ALG_HMAC_SHA224_mode_not_allowed, TEEC_ERROR_NOT_SUPPORTED),
    COMMAND(Invoke_Crypto_AllocateOperation_TEE_ALG_HMAC_SHA256_mode_not_allowed, TEEC_ERROR_NOT_SUPPORTED),
    COMMAND(Invoke_Crypto_AllocateOperation_TEE_ALG_HMAC_SHA384_mode_not_allowed, TEEC_ERROR_NOT_SUPPORTED),
    COMMAND(Invoke_Crypto_AllocateOperation_TEE_ALG_HMAC_SHA512_mode_not_allowed, TEEC_ERROR_NOT_SUPPORTED),
    COMMAND(Invoke_Crypto_AllocateOperation_TEE_ALG_RSA_NOPAD_mode_not_allowed, TEEC_ERROR_NOT_SUPPORTED),
    COMMAND(Invoke_Crypto_AllocateOperation_TEE_ALG_SHA1_mode_not_allowed, TEEC_ERROR_NOT_SUPPORTED),
    COMMAND(Invoke_Crypto_AllocateOperation_TEE_ALG_SHA224_mode_not_allowed, TEEC_ERROR_NOT_SUPPORTED),
    COMMAND(Invoke_Crypto_AllocateOperation_TEE_ALG_SHA256_mode_not_allowed, TEEC_ERROR_NOT_SUPPORTED),
    COMMAND(Invoke_Crypto_AllocateOperation_TEE_ALG_SHA384_mode_not_allowed, TEEC_ERROR_NOT_SUPPORTED),
    COMMAND(Invoke_Crypto_AllocateOperation_TEE_ALG_SHA512_mode_not_allowed, TEEC_ERROR_NOT_SUPPORTED),
    COMMAND(Invoke_Crypto_FreeAllKeysAndOperations_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_SetOperationKey_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_CipherDoFinal_TEE_ALG_AES_CBC_NOPAD_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_CipherDoFinal_TEE_ALG_AES_CTR_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_CipherDoFinal_TEE_ALG_AES_CTS_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_CipherDoFinal_TEE_ALG_AES_ECB_NOPAD_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_CipherDoFinal_TEE_ALG_AES_XTS_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_CipherDoFinal_TEE_ALG_DES_CBC_NOPAD_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_CipherDoFinal_TEE_ALG_DES_ECB_NOPAD_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_CipherDoFinal_TEE_ALG_DES3_CBC_NOPAD_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_CipherDoFinal_TEE_ALG_DES3_ECB_NOPAD_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_MACComputeFinal_TEE_ALG_AES_CBC_MAC_NOPAD_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_MACCompareFinal_TEE_ALG_AES_CBC_MAC_NOPAD_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_MACComputeFinal_TEE_ALG_AES_CMAC_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_MACCompareFinal_TEE_ALG_AES_CMAC_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_MACComputeFinal_TEE_ALG_HMAC_SHA1_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_MACCompareFinal_TEE_ALG_HMAC_SHA1_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_MACComputeFinal_TEE_ALG_HMAC_SHA224_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_MACCompareFinal_TEE_ALG_HMAC_SHA224_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_MACComputeFinal_TEE_ALG_HMAC_SHA256_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_MACCompareFinal_TEE_ALG_HMAC_SHA256_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_MACComputeFinal_TEE_ALG_HMAC_SHA384_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_MACCompareFinal_TEE_ALG_HMAC_SHA384_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_MACComputeFinal_TEE_ALG_HMAC_SHA512_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_MACCompareFinal_TEE_ALG_HMAC_SHA512_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_AllocateOperation_not_enough_memory, TEEC_ERROR_OUT_OF_MEMORY),
    COMMAND(Invoke_Crypto_CipherDoFinal_short_buffer, TEEC_ERROR_SHORT_BUFFER),
    COMMAND(Invoke_Crypto_CipherUpdate_short_buffer, TEEC_ERROR_SHORT_BUFFER),
    COMMAND(Invoke_Crypto_MACComputeFinal_short_buffer, TEEC_ERROR_SHORT_BUFFER),
    COMMAND(Invoke_Crypto_CipherInit_operation_active_already_initialized_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_MACCompareFinal_invalid_mac, TEEC_ERROR_MAC_INVALID),
    COMMAND(Invoke_Crypto_AEDecryptFinal_AES_32_bits_TEE_ALG_AES_CCM_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_AEDecryptFinal_AES_48_bits_TEE_ALG_AES_CCM_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_AEDecryptFinal_AES_64_bits_TEE_ALG_AES_CCM_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_AEDecryptFinal_AES_96_bits_TEE_ALG_AES_CCM_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_AEDecryptFinal_AES_112_bits_TEE_ALG_AES_CCM_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_AEDecryptFinal_AES_128_bits_TEE_ALG_AES_CCM_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_AEDecryptFinal_invalid_mac, TEEC_ERROR_MAC_INVALID),
    COMMAND(Invoke_Crypto_AEInit_AES_104_bits_TEE_ALG_AES_CCM_tag_length_not_supported, TEEC_ERROR_NOT_SUPPORTED),
    COMMAND(Invoke_Crypto_AEInit_AES_120_bits_TEE_ALG_AES_CCM_tag_length_not_supported, TEEC_ERROR_NOT_SUPPORTED),
    COMMAND(Invoke_Crypto_AEUpdate_short_buffer, TEEC_ERROR_SHORT_BUFFER),
    COMMAND(Invoke_Crypto_AsymmetricDecrypt_TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA1_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_AsymmetricDecrypt_TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA224_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_AsymmetricDecrypt_TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA256_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_AsymmetricDecrypt_TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA384_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_AsymmetricDecrypt_TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA512_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_AsymmetricDecrypt_TEE_ALG_RSAES_PKCS1_V1_5_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_AsymmetricDecrypt_TEE_ALG_RSA_NOPAD_TEE_MODE_DECRYPT_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_AsymmetricSignDigest_TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_AsymmetricVerifyDigest_TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_AsymmetricSignDigest_TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_AsymmetricVerifyDigest_TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_AsymmetricSignDigest_TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_AsymmetricVerifyDigest_TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_AsymmetricSignDigest_TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_AsymmetricVerifyDigest_TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_AsymmetricSignDigest_TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_AsymmetricVerifyDigest_TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_AsymmetricSignDigest_TEE_ALG_RSASSA_PKCS1_V1_5_SHA1_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_AsymmetricVerifyDigest_TEE_ALG_RSASSA_PKCS1_V1_5_SHA1_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_AsymmetricSignDigest_TEE_ALG_RSASSA_PKCS1_V1_5_SHA224_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_AsymmetricVerifyDigest_TEE_ALG_RSASSA_PKCS1_V1_5_SHA224_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_AsymmetricSignDigest_TEE_ALG_RSASSA_PKCS1_V1_5_SHA256_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_AsymmetricVerifyDigest_TEE_ALG_RSASSA_PKCS1_V1_5_SHA256_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_AsymmetricSignDigest_TEE_ALG_RSASSA_PKCS1_V1_5_SHA384_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_AsymmetricVerifyDigest_TEE_ALG_RSASSA_PKCS1_V1_5_SHA384_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_AsymmetricSignDigest_TEE_ALG_RSASSA_PKCS1_V1_5_SHA512_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_AsymmetricVerifyDigest_TEE_ALG_RSASSA_PKCS1_V1_5_SHA512_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_AllocateOperation_TEE_ALG_AES_CBC_MAC_NOPAD_mode_not_allowed, TEEC_ERROR_NOT_SUPPORTED),
    COMMAND(Invoke_Crypto_AllocateOperation_TEE_ALG_AES_CCM_mode_not_allowed, TEEC_ERROR_NOT_SUPPORTED),
    COMMAND(Invoke_Crypto_AllocateOperation_TEE_ALG_AES_CTS_mode_not_allowed, TEEC_ERROR_NOT_SUPPORTED),
    COMMAND(Invoke_Crypto_AllocateOperation_TEE_ALG_DH_DERIVE_SHARED_SECRET_mode_not_allowed, TEEC_ERROR_NOT_SUPPORTED),
    COMMAND(Invoke_Crypto_AllocateOperation_TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA1_mode_not_allowed, TEEC_ERROR_NOT_SUPPORTED),
    COMMAND(Invoke_Crypto_AllocateOperation_TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA224_mode_not_allowed, TEEC_ERROR_NOT_SUPPORTED),
    COMMAND(Invoke_Crypto_AllocateOperation_TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA256_mode_not_allowed, TEEC_ERROR_NOT_SUPPORTED),
    COMMAND(Invoke_Crypto_AllocateOperation_TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA384_mode_not_allowed, TEEC_ERROR_NOT_SUPPORTED),
    COMMAND(Invoke_Crypto_AllocateOperation_TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA512_mode_not_allowed, TEEC_ERROR_NOT_SUPPORTED),
    COMMAND(Invoke_Crypto_AllocateOperation_TEE_ALG_RSAES_PKCS1_V1_5_mode_not_allowed, TEEC_ERROR_NOT_SUPPORTED),
    COMMAND(Invoke_Crypto_AllocateOperation_TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1_mode_not_allowed, TEEC_ERROR_NOT_SUPPORTED),
    COMMAND(Invoke_Crypto_AllocateOperation_TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224_mode_not_allowed, TEEC_ERROR_NOT_SUPPORTED),
    COMMAND(Invoke_Crypto_AllocateOperation_TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256_mode_not_allowed, TEEC_ERROR_NOT_SUPPORTED),
    COMMAND(Invoke_Crypto_AllocateOperation_TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384_mode_not_allowed, TEEC_ERROR_NOT_SUPPORTED),
    COMMAND(Invoke_Crypto_AllocateOperation_TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512_mode_not_allowed, TEEC_ERROR_NOT_SUPPORTED),
    COMMAND(Invoke_Crypto_AllocateOperation_TEE_ALG_RSASSA_PKCS1_V1_5_SHA1_mode_not_allowed, TEEC_ERROR_NOT_SUPPORTED),
    COMMAND(Invoke_Crypto_AllocateOperation_TEE_ALG_RSASSA_PKCS1_V1_5_SHA224_mode_not_allowed, TEEC_ERROR_NOT_SUPPORTED),
    COMMAND(Invoke_Crypto_AllocateOperation_TEE_ALG_RSASSA_PKCS1_V1_5_SHA256_mode_not_allowed, TEEC_ERROR_NOT_SUPPORTED),
    COMMAND(Invoke_Crypto_AllocateOperation_TEE_ALG_RSASSA_PKCS1_V1_5_SHA384_mode_not_allowed, TEEC_ERROR_NOT_SUPPORTED),
    COMMAND(Invoke_Crypto_AllocateOperation_TEE_ALG_RSASSA_PKCS1_V1_5_SHA512_mode_not_allowed, TEEC_ERROR_NOT_SUPPORTED),
    COMMAND(Invoke_Crypto_CipherInit_operation_not_active_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_AsymmetricEncrypt_short_buffer, TEEC_ERROR_SHORT_BUFFER),
    COMMAND(Invoke_Crypto_AsymmetricDecrypt_short_buffer, TEEC_ERROR_SHORT_BUFFER),
    COMMAND(Invoke_Crypto_SetOperationKey2_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_ResetOperation_Success, TEEC_SUCCESS),
    COMMAND(Invoke_Crypto_CopyOperation_source_key_empty_Success, TEEC_SUCCESS),//pass
    COMMAND(Invoke_Crypto_CopyOperation_source_key_not_empty_Success, TEEC_SUCCESS),//pass
    //target dead
    COMMAND(Invoke_Crypto_DigestUpdate_invalid_value_handle, 0xFFFF3024),
    COMMAND(Invoke_Crypto_ResetOperation_invalid_value_handle, 0xFFFF3024),//TEE_ERROR_TARGET_DEAD
    COMMAND(Invoke_Crypto_SetOperationKey_invalid_value_handle_operation, 0xFFFF3024),//TEE_ERROR_TARGET_DEAD
    COMMAND(Invoke_Crypto_SetOperationKey2_invalid_value_handle_operation, 0xFFFF3024),//TEE_ERROR_TARGET_DEAD
    COMMAND(Invoke_Crypto_SetOperationKey2_key1_handle_not_valid, 0xFFFF3024),//TEE_ERROR_TARGET_DEAD
    COMMAND(Invoke_Crypto_SetOperationKey2_key2_handle_not_valid, 0xFFFF3024),//TEE_ERROR_TARGET_DEAD
    COMMAND(Invoke_Crypto_CipherDoFinal_invalid_value_handle, 0xFFFF3024),//TEE_ERROR_TARGET_DEAD
    COMMAND(Invoke_Crypto_CipherInit_invalid_value_handle, 0xFFFF3024),//TEE_ERROR_TARGET_DEAD
    COMMAND(Invoke_Crypto_CipherUpdate_invalid_value_handle, 0xFFFF3024),//TEE_ERROR_TARGET_DEAD
    COMMAND(Invoke_Crypto_AEDecryptFinal_invalid_value_handle, 0xFFFF3024),//TEE_ERROR_TARGET_DEAD
    COMMAND(Invoke_Crypto_AEEncryptFinal_invalid_value_handle, 0xFFFF3024),//TEE_ERROR_TARGET_DEAD
    COMMAND(Invoke_Crypto_AEInit_invalid_value_handle, 0xFFFF3024),//TEE_ERROR_TARGET_DEAD
    COMMAND(Invoke_Crypto_AEUpdate_invalid_value_handle, 0xFFFF3024),//TEE_ERROR_TARGET_DEAD
    COMMAND(Invoke_Crypto_AEUpdateAAD_invalid_value_handle, 0xFFFF3024),//TEE_ERROR_TARGET_DEAD
    COMMAND(Invoke_Crypto_AsymmetricDecrypt_invalid_value_handle, 0xFFFF3024),//TEE_ERROR_TARGET_DEAD
    COMMAND(Invoke_Crypto_AsymmetricEncrypt_invalid_value_handle, 0xFFFF3024),//TEE_ERROR_TARGET_DEAD
    COMMAND(Invoke_Crypto_AsymmetricSignDigest_invalid_value_handle, 0xFFFF3024),//TEE_ERROR_TARGET_DEAD
    COMMAND(Invoke_Crypto_AsymmetricVerifyDigest_invalid_value_handle, 0xFFFF3024),//TEE_ERROR_TARGET_DEAD
    COMMAND(Invoke_Crypto_FreeAllKeysAndOperations_operation_handle_not_valid, 0xFFFF3024),//TEE_ERROR_TARGET_DEAD
    COMMAND(Invoke_Crypto_CopyOperation_src_operation_handle_not_valid, 0xFFFF3024),//TEE_ERROR_TARGET_DEAD
    COMMAND(Invoke_Crypto_GetOperationInfo_operation_handle_not_valid, 0xFFFF3024),//TEE_ERROR_TARGET_DEAD
    COMMAND(Invoke_Crypto_DeriveKey_invalid_value_handle, 0xFFFF3024),//TEE_ERROR_TARGET_DEAD
    COMMAND(Invoke_Crypto_DigestDoFinal_invalid_value_handle, 0xFFFF3024),//TEE_ERROR_TARGET_DEAD
    #if 0
    //failed
    COMMAND(Invoke_Crypto_CipherDoFinal_invalid_operation_class, 0xFFFF3024),
    COMMAND(Invoke_Crypto_CipherInit_invalid_operation_class, 0xFFFF3024),
    COMMAND(Invoke_Crypto_CipherInit_no_key_programmed, 0xFFFF3024),
    COMMAND(Invoke_Crypto_CipherUpdate_invalid_operation_class, 0xFFFF3024),
    COMMAND(Invoke_Crypto_CopyOperation_algo_and_modes_differ, 0xFFFF3024),//void
    COMMAND(Invoke_Crypto_CopyOperation_dst_operation_handle_not_valid, 0xFFFF3024),//void
    COMMAND(Invoke_Crypto_CopyOperation_src_key_size_greater_than_dest_max_key_size, 0xFFFF3024),//void
    COMMAND(Invoke_Crypto_SetOperationKey_expects_no_key, 0xFFFF3024),
    COMMAND(Invoke_Crypto_SetOperationKey_invalid_value_handle_key, 0xFFFF3024),
    COMMAND(Invoke_Crypto_SetOperationKey2_operation_expects_no_key, 0xFFFF3024),
    COMMAND(Invoke_Crypto_CipherInit_length_too_short, 0xFFFF3024),
    COMMAND(Invoke_Crypto_DeriveKey_incompatible_mode_invalid_operation_class, 0xFFFF3024),//void
    COMMAND(Invoke_Crypto_DigestDoFinal_invalid_operation_class, 0xFFFF3024),//code=0xffff0006
    COMMAND(Invoke_Crypto_DigestUpdate_invalid_operation_class, 0xFFFF3024),//TATEEC_SUCCESS
    COMMAND(Invoke_Crypto_MACCompareFinal_invalid_operation_class, 0xFFFF3024),
    COMMAND(Invoke_Crypto_MACCompareFinal_invalid_value_handle, 0xFFFF3024),
    COMMAND(Invoke_Crypto_MACComputeFinal_invalid_operation_class, 0xFFFF3024),
    COMMAND(Invoke_Crypto_MACComputeFinal_invalid_value_handle, 0xFFFF3024),
    COMMAND(Invoke_Crypto_MACInit_invalid_value_handle, 0xFFFF3024),
    COMMAND(Invoke_Crypto_MACUpdate_invalid_value_handle, 0xFFFF3024),
    COMMAND(Invoke_Crypto_CipherDoFinal_operation_already_finalized, 0xFFFF3024),
    COMMAND(Invoke_Crypto_CipherDoFinal_operation_not_started, 0xFFFF3024),
    COMMAND(Invoke_Crypto_CipherUpdate_operation_already_finalized, 0xFFFF3024),
    COMMAND(Invoke_Crypto_CipherUpdate_operation_not_started, 0xFFFF3024),
    COMMAND(Invoke_Crypto_MACCompareFinal_operation_already_finalized, 0xFFFF3024),
    COMMAND(Invoke_Crypto_MACComputeFinal_operation_already_finalized, 0xFFFF3024),
    COMMAND(Invoke_Crypto_MACInit_init_vector_not_required_length, 0xFFFF3024),
    COMMAND(Invoke_Crypto_MACInit_no_key_programmed, 0xFFFF3024),
    COMMAND(Invoke_Crypto_MACUpdate_operation_already_finalized, 0xFFFF3024),
    COMMAND(Invoke_Crypto_AEDecryptFinal_invalid_operation_class, 0xFFFF3024),
    COMMAND(Invoke_Crypto_AEDecryptFinal_operation_not_started, 0xFFFF3024),
    COMMAND(Invoke_Crypto_AEEncryptFinal_invalid_operation_class, 0xFFFF3024),
    COMMAND(Invoke_Crypto_AEEncryptFinal_operation_not_started, 0xFFFF3024),
    COMMAND(Invoke_Crypto_AEInit_incompatible_nonce_length, 0xFFFF3024),
    COMMAND(Invoke_Crypto_AEInit_invalid_operation_class, 0xFFFF3024),
    COMMAND(Invoke_Crypto_AEInit_no_key_programmed, 0xFFFF3024),
    COMMAND(Invoke_Crypto_AEUpdate_AAD_length_not_provided, 0xFFFF3024),
    COMMAND(Invoke_Crypto_AEUpdate_invalid_operation_class, 0xFFFF3024),
    COMMAND(Invoke_Crypto_AEUpdate_payload_length_reached, 0xFFFF3024),
    COMMAND(Invoke_Crypto_AEUpdateAAD_AAD_length_reached, 0xFFFF3024),
    COMMAND(Invoke_Crypto_AEUpdateAAD_invalid_operation_class, 0xFFFF3024),
    COMMAND(Invoke_Crypto_AEUpdateAAD_operation_not_started, 0xFFFF3024),
    COMMAND(Invoke_Crypto_AsymmetricDecrypt_invalid_operation_class, 0xFFFF3024),
    COMMAND(Invoke_Crypto_AsymmetricDecrypt_no_key_programmed, 0xFFFF3024),
    COMMAND(Invoke_Crypto_AsymmetricEncrypt_invalid_operation_class, 0xFFFF3024),
    COMMAND(Invoke_Crypto_AsymmetricEncrypt_no_key_programmed, 0xFFFF3024),
    COMMAND(Invoke_Crypto_AsymmetricSignDigest_invalid_operation_class, 0xFFFF3024),
    COMMAND(Invoke_Crypto_AsymmetricEncrypt_incompatible_mode, 0xFFFF3024),
    COMMAND(Invoke_Crypto_AsymmetricDecrypt_incompatible_mode, 0xFFFF3024),
    COMMAND(Invoke_Crypto_AsymmetricSignDigest_incompatible_mode, 0xFFFF3024),
    COMMAND(Invoke_Crypto_SetOperationKey_expect_two_keys, 0xFFFF3024),
    COMMAND(Invoke_Crypto_DeriveKey_no_key_programmed, 0xFFFF3024),//TEE_ERROR_TARGET_DEAD
    #endif
};

#ifdef NOT_SUPPORT
    Invoke_Crypto_AllocateOperation_TEE_ALG_DSA_SHA1_mode_not_allowed ();
    Invoke_Crypto_AllocateOperation_TEE_ALG_HMAC_MD5_mode_not_allowed ();
    Invoke_Crypto_AllocateOperation_TEE_ALG_MD5_mode_not_allowed ();
    Invoke_Crypto_AllocateOperation_TEE_ALG_RSASSA_PKCS1_V1_5_MD5_mode_not_allowed ();
    Invoke_Crypto_AEInit_AES_32_bits_TEE_ALG_AES_GCM_tag_length_not_supported ();
    Invoke_Crypto_AEInit_AES_48_bits_TEE_ALG_AES_GCM_tag_length_not_supported ();
    Invoke_Crypto_AEInit_AES_64_bits_TEE_ALG_AES_GCM_tag_length_not_supported ();
    Invoke_Crypto_AllocateOperation_TEE_ALG_AES_CBC_MAC_PKCS5_mode_not_allowed ();
    Invoke_Crypto_AllocateOperation_TEE_ALG_AES_GCM_mode_not_allowed ();
    Invoke_Crypto_AllocateOperation_TEE_ALG_DES3_CBC_MAC_NOPAD_mode_not_allowed ();
    Invoke_Crypto_AllocateOperation_TEE_ALG_DES3_CBC_MAC_PKCS5_mode_not_allowed ();
    Invoke_Crypto_AllocateOperation_TEE_ALG_DES_CBC_MAC_NOPAD_mode_not_allowed ();
    Invoke_Crypto_AllocateOperation_TEE_ALG_DES_CBC_MAC_PKCS5_mode_not_allowed ();
    Invoke_Crypto_AsymmetricSignDigest_short_buffer ();
    Invoke_Crypto_AsymmetricVerifyDigest_incompatible_mode ();
    Invoke_Crypto_AEDecryptFinal_short_buffer ();//fail TEE_ERROR_TOO_SHORT_BUFFER code=0xffff000a 
    Invoke_Crypto_AEEncryptFinal_short_buffer ();//fail TEE_ERROR_TOO_SHORT_BUFFER  code=0xffff000a
    Invoke_Crypto_AsymmetricSignDigest_no_key_programmed ();//fail TEE_ERROR_TARGET_DEAD Segmentation fault
    Invoke_Crypto_AsymmetricVerifyDigest_invalid_operation_class ();//fail TEE_ERROR_TARGET_DEAD Segmentation fault
    Invoke_Crypto_AsymmetricVerifyDigest_invalid_signature ();//fail TEE_ERROR_SIGNATURE_INVALID Segmentation fault
    Invoke_Crypto_MACInit_invalid_operation_class ();//fail TEE_ERROR_TARGET_DEAD code=0xffff0000
    Invoke_Crypto_SetOperationKey2_operation_expects_one_key ();//
    Invoke_Crypto_AsymmetricVerifyDigest_no_key_programmed ();//fail TEE_ERROR_TARGET_DEAD TRUSTED_APP_ERROR_ALLOCATE_TRANSIENT_OBJECT_FAILED = 0x0000F005DSA
    Invoke_Crypto_DigestDoFinal_short_buffer();
    Invoke_Crypto_MACUpdate_invalid_operation_class();
    Invoke_Crypto_MACCompareFinal_operation_not_started();
    Invoke_Crypto_MACComputeFinal_operation_not_started();
    Invoke_Crypto_MACUpdate_operation_not_started();
    Invoke_Crypto_GetOperationInfo_Success();
#endif
static char *failed_func_name[64] = {NULL};
void main(void)
{
    int i = 0;
    int pass=0, fail=0;
    TEEC_Result ret;
    int num = sizeof(test_gp_func)/sizeof(test_gp_func[0]);
    TEEC_Debug("=====================================================\n");
    TEEC_Debug("==============crypto gp testsuite start==============\n");
    for(i=0; i<num; i++){
        ret = test_gp_func[i].test_func();
        if(ret != test_gp_func[i].result){
            TEEC_Error("%s failed!, ret = %x\n", test_gp_func[i].name, ret);
            failed_func_name[fail] = (char *)malloc(strlen(test_gp_func[i].name)+1);
            memcpy(failed_func_name[fail], test_gp_func[i].name, strlen(test_gp_func[i].name)+1);
            fail++;
        }else{
            TEEC_Debug("%s successful!\n", test_gp_func[i].name);
            pass++;
        }
    }
    //TEEC_Debug("total 242, pass %d, fail %d, not support %d\n", pass, fail, 242-num);
	TEEC_Debug("total 139, pass %d, fail %d\n", pass, fail);
	for(i=0;i<64;i++){
			if(failed_func_name[i] != NULL){
					TEEC_Error("failed case%d: %s\n", i, failed_func_name[i]);
					free(failed_func_name[i]);
			}
	}
	TEEC_Debug("==============crypto gp testsuite end================\n");
    TEEC_Debug("=====================================================\n");
}
